Option Explicit
'===============================================================================
' Unified Conversation Exporter for Outlook (VBA) — Hardened Late-Bound Build
' Patched Edition (2025-10-31)
' - Fixes Error 450 in Items loop (explicit Items.Item(i), extra guards)
' - Robust ISO-8601 date parsing (state/manifest)
' - UNC-safe folder creation; safer UNC disk-space check
' - Respects cfg.MaxPathLength everywhere
' - Improved marketing/auto-gen detection; winmail.dat skip
' - Empty-recipient filtering & HTML->text fallback for bodies
' - Locale-independent Search Folder detection
' - Minor resiliency, diagnostics, and correctness tweaks
'===============================================================================

'============================== USER CONFIG ====================================
Private Const CFG_OutRoot_Default As String = ""   ' "" -> auto Desktop\Outlook
Private Const CFG_PickFolders As Boolean = True    ' True -> picker; False -> use CFG_Folders
Private CFG_Folders As Variant                     ' e.g. Array("\\Mailbox - Me\Inbox", "\\Mailbox - Me\Sent Items")
Private Const CFG_Full As Boolean = False          ' True -> ignore state/Since; export all
Private Const CFG_Since As String = "auto"         ' "auto" -> _state.json; else ISO or local date/time
Private Const CFG_NoState As Boolean = False       ' True -> never read/write _state.json
Private Const CFG_SaveState As Boolean = True      ' True -> write state (unless NoState True)

' Start with offline strict disabled to avoid profile quirks; flip True once clean.
Private Const CFG_OfflineStrict As Boolean = False

' Scanning selector (failsafe default)
Private Const CFG_ForceItemsLoop As Boolean = True ' True = Items loop only; False = allow GetTable (with guards)

' Processing
Private Const CFG_IncludeAttachments As Boolean = True
Private Const CFG_IncludeBodies As Boolean = True
Private Const CFG_IncludeNestedAttachments As Boolean = True
Private Const CFG_NestedDepth As Long = 2
Private Const CFG_LeavesOnly As Boolean = True

' Path / naming
Private Const CFG_EnableLongPaths As Boolean = False
Private Const CFG_MaxPathLength As Long = 180

' Filters (leave Empty to disable)
Private CFG_IncludePathPattern As Variant
Private CFG_ExcludePathPattern As Variant
Private CFG_AllowSenders As Variant
Private CFG_RejectSenders As Variant
Private CFG_RejectDomains As Variant
Private CFG_RejectSubjectRegex As Variant
Private CFG_RejectBodyRegex As Variant
Private Const CFG_ExcludeMarketing As Boolean = True
Private Const CFG_ExcludeAutoGenerated As Boolean = True

' Bodies / cleaning
Private Const CFG_CleanBodies As Boolean = True
Private Const CFG_MinBodyChars As Long = 20
Private Const CFG_EmitChunks As Boolean = False
Private Const CFG_ChunkSizeChars As Long = 3600
Private Const CFG_ChunkOverlapChars As Long = 400
Private Const CFG_NoBomEncoding As Boolean = True

' Inline logos
Private Const CFG_InlineLogoMaxKB As Long = 50
Private Const CFG_SkipInlineLogos As Boolean = True

' Logging (optional)
Private Const CFG_LogPath As String = ""          ' e.g. "C:\Temp\ucx_log.txt" or "" to disable

'============================== TYPES ==========================================
Public Type UCX_Config
    outRoot As String
    folders As Variant
    PickFolders As Boolean
    Full As Boolean
    Since As String
    NoState As Boolean
    SaveState As Boolean
    OfflineStrict As Boolean

    IncludeAttachments As Boolean
    includeBodies As Boolean
    IncludeNestedAttachments As Boolean
    NestedDepth As Long
    LeavesOnly As Boolean

    EnableLongPaths As Boolean
    MaxPathLength As Long

    IncludePathPattern As Variant
    ExcludePathPattern As Variant
    AllowSenders As Variant
    RejectSenders As Variant
    RejectDomains As Variant
    RejectSubjectRegex As Variant
    RejectBodyRegex As Variant
    ExcludeMarketing As Boolean
    ExcludeAutoGenerated As Boolean

    CleanBodies As Boolean
    MinBodyChars As Long
    EmitChunks As Boolean
    ChunkSizeChars As Long
    ChunkOverlapChars As Long
    NoBomEncoding As Boolean

    InlineLogoMaxKB As Long
    SkipInlineLogos As Boolean

    LogPath As String
End Type

'============================= CONSTANTS =======================================
' Outlook-ish constants we need (numeric)
Private Const OL_TO As Long = 1
Private Const OL_CC As Long = 2
Private Const OL_FORMAT_HTML As Long = 2
Private Const OL_DOWNLOADSTATE_COMPLETE As Long = 1
Private Const OLCM_CachedOffline As Long = 400
Private Const OLCM_Disconnected As Long = 500

' MAPI named property tags
Private Const PR_CONV_ID As String = "http://schemas.microsoft.com/mapi/proptag/0x30130102"
Private Const PR_CONV_INDEX As String = "http://schemas.microsoft.com/mapi/proptag/0x00710102"
Private Const PR_HDRS_W As String = "http://schemas.microsoft.com/mapi/proptag/0x007D001F"
Private Const PR_HDRS_A As String = "http://schemas.microsoft.com/mapi/proptag/0x007D001E"
Private Const PR_ATTACH_CIDW As String = "http://schemas.microsoft.com/mapi/proptag/0x3712001F"
Private Const PR_ATTACH_CIDA As String = "http://schemas.microsoft.com/mapi/proptag/0x3712001E"
Private Const PR_ATTACH_CONTENT_DISP As String = "http://schemas.microsoft.com/mapi/proptag/0x3716001F"
Private Const STATE_FILE As String = "_state.json"
Private Const LOCK_FILE As String = "_export.lock"

' Path budgets
Private Const MAX_PATH_SAFE As Long = 240   ' legacy fallback

' Performance & Magic Numbers
Private Const MIN_DISK_SPACE_MB As Long = 100
Private Const BYTES_PER_MB As Long = 1048576
Private Const LOOP_DOEVENTS_STEP As Long = 500
Private Const BODY_PREVIEW_LENGTH As Long = 4000

' CryptoAPI (SHA-256) -----------------------------------------------------------
#If VBA7 Then
Private Declare PtrSafe Function CryptAcquireContext Lib "advapi32.dll" Alias "CryptAcquireContextA" (ByRef phProv As LongPtr, ByVal pszContainer As String, ByVal pszProvider As String, ByVal dwProvType As Long, ByVal dwFlags As Long) As Long
Private Declare PtrSafe Function CryptReleaseContext Lib "advapi32.dll" (ByVal hProv As LongPtr, ByVal dwFlags As Long) As Long
Private Declare PtrSafe Function CryptCreateHash Lib "advapi32.dll" (ByVal hProv As LongPtr, ByVal Algid As Long, ByVal hKey As LongPtr, ByVal dwFlags As Long, ByRef phHash As LongPtr) As Long
Private Declare PtrSafe Function CryptHashData Lib "advapi32.dll" (ByVal hHash As LongPtr, ByRef pbData As Any, ByVal dwDataLen As Long, ByVal dwFlags As Long) As Long
Private Declare PtrSafe Function CryptGetHashParam Lib "advapi32.dll" (ByVal hHash As LongPtr, ByVal dwParam As Long, ByRef pbData As Any, ByRef pdwDataLen As Long, ByVal dwFlags As Long) As Long
Private Declare PtrSafe Function CryptDestroyHash Lib "advapi32.dll" (ByVal hHash As LongPtr) As Long
#Else
Private Declare Function CryptAcquireContext Lib "advapi32.dll" Alias "CryptAcquireContextA" (ByRef phProv As Long, ByVal pszContainer As String, ByVal pszProvider As String, ByVal dwProvType As Long, ByVal dwFlags As Long) As Long
Private Declare Function CryptReleaseContext Lib "advapi32.dll" (ByVal hProv As Long) As Long
Private Declare Function CryptCreateHash Lib "advapi32.dll" (ByVal hProv As Long, ByVal Algid As Long, ByVal hKey As Long, ByVal dwFlags As Long, ByRef phHash As Long) As Long
Private Declare Function CryptHashData Lib "advapi32.dll" (ByVal hHash As Long, ByRef pbData As Any, ByVal dwDataLen As Long, ByVal dwFlags As Long) As Long
Private Declare Function CryptGetHashParam Lib "advapi32.dll" (ByVal hHash As Long, ByVal dwParam As Long, ByRef pbData As Any, ByRef pdwDataLen As Long, ByVal dwFlags As Long) As Long
Private Declare Function CryptDestroyHash Lib "advapi32.dll" (ByVal hHash As Long) As Long
#End If

Private Const PROV_RSA_AES As Long = &HF&
Private Const CRYPT_VERIFYCONTEXT As Long = &HF0000000
Private Const CALG_SHA_256 As Long = &H800C&
Private Const HP_HASHVAL As Long = 2
Private Const HP_HASHSIZE As Long = 4

' Timezone APIs (DST-correct conversion) ---------------------------------------
#If VBA7 Then
Private Declare PtrSafe Function GetTimeZoneInformation Lib "kernel32" (lpTimeZoneInformation As TIME_ZONE_INFORMATION) As Long
Private Declare PtrSafe Function SystemTimeToTzSpecificLocalTime Lib "kernel32" (lpTimeZoneInformation As TIME_ZONE_INFORMATION, lpUniversalTime As SYSTEMTIME, lpLocalTime As SYSTEMTIME) As Long
Private Declare PtrSafe Function TzSpecificLocalTimeToSystemTime Lib "kernel32" (lpTimeZoneInformation As TIME_ZONE_INFORMATION, lpLocalTime As SYSTEMTIME, lpUniversalTime As SYSTEMTIME) As Long
#Else
Private Declare Function GetTimeZoneInformation Lib "kernel32" (lpTimeZoneInformation As TIME_ZONE_INFORMATION) As Long
Private Declare Function SystemTimeToTzSpecificLocalTime Lib "kernel32" (lpTimeZoneInformation As TIME_ZONE_INFORMATION, lpUniversalTime As SYSTEMTIME, lpLocalTime As SYSTEMTIME) As Long
Private Declare Function TzSpecificLocalTimeToSystemTime Lib "kernel32" (lpTimeZoneInformation As TIME_ZONE_INFORMATION, lpLocalTime As SYSTEMTIME, lpUniversalTime As SYSTEMTIME) As Long
#End If

Public Type SYSTEMTIME
    wYear As Integer
    wMonth As Integer
    wDayOfWeek As Integer
    wDay As Integer
    wHour As Integer
    wMinute As Integer
    wSecond As Integer
    wMilliseconds As Integer
End Type

Public Type TIME_ZONE_INFORMATION
    Bias As Long
    StandardName(0 To 63) As Integer
    StandardDate As SYSTEMTIME
    StandardBias As Long
    DaylightName(0 To 63) As Integer
    DaylightDate As SYSTEMTIME
    DaylightBias As Long
End Type

'============================ ENTRY POINTS =====================================

Public Sub UCX_Run_Default()
    Dim cfg As UCX_Config: cfg = UCX_DefaultConfig()
    cfg.PickFolders = True
    If Len(CFG_OutRoot_Default) > 0 Then
        cfg.outRoot = CFG_OutRoot_Default
    Else
        cfg.outRoot = DesktopOutRoot()
    End If
    UCX_Export cfg
End Sub

Public Sub UCX_Run_FullExample()
    Dim cfg As UCX_Config: cfg = UCX_DefaultConfig()
    cfg.outRoot = DesktopOutRoot() & "\FullExport"
    cfg.Full = True
    cfg.PickFolders = True
    UCX_Export cfg
End Sub

'============================= CONFIG BUILD ====================================

Private Function UCX_DefaultConfig() As UCX_Config
    Dim c As UCX_Config
    If Len(CFG_OutRoot_Default) > 0 Then
        c.outRoot = CFG_OutRoot_Default
    Else
        c.outRoot = DesktopOutRoot()
    End If
    c.folders = CFG_Folders
    c.PickFolders = CFG_PickFolders
    c.Full = CFG_Full
    c.Since = CFG_Since
    c.NoState = CFG_NoState
    c.SaveState = CFG_SaveState
    c.OfflineStrict = CFG_OfflineStrict

    c.IncludeAttachments = CFG_IncludeAttachments
    c.includeBodies = CFG_IncludeBodies
    c.IncludeNestedAttachments = CFG_IncludeNestedAttachments
    c.NestedDepth = CFG_NestedDepth
    c.LeavesOnly = CFG_LeavesOnly

    c.EnableLongPaths = CFG_EnableLongPaths
    c.MaxPathLength = CFG_MaxPathLength

    c.IncludePathPattern = CFG_IncludePathPattern
    c.ExcludePathPattern = CFG_ExcludePathPattern
    c.AllowSenders = CFG_AllowSenders
    c.RejectSenders = CFG_RejectSenders
    c.RejectDomains = CFG_RejectDomains
    c.RejectSubjectRegex = CFG_RejectSubjectRegex
    c.RejectBodyRegex = CFG_RejectBodyRegex
    c.ExcludeMarketing = CFG_ExcludeMarketing
    c.ExcludeAutoGenerated = CFG_ExcludeAutoGenerated

    c.CleanBodies = CFG_CleanBodies
    c.MinBodyChars = CFG_MinBodyChars
    c.EmitChunks = CFG_EmitChunks
    c.ChunkSizeChars = CFG_ChunkSizeChars
    c.ChunkOverlapChars = CFG_ChunkOverlapChars
    c.NoBomEncoding = CFG_NoBomEncoding

    c.InlineLogoMaxKB = CFG_InlineLogoMaxKB
    c.SkipInlineLogos = CFG_SkipInlineLogos
    c.LogPath = CFG_LogPath

    ValidateConfig c
    UCX_DefaultConfig = c
End Function

Private Sub ValidateConfig(ByRef cfg As UCX_Config)
    If cfg.NestedDepth < 0 Then cfg.NestedDepth = 0
    If cfg.NestedDepth > 5 Then cfg.NestedDepth = 5
    If cfg.MaxPathLength < 50 Then cfg.MaxPathLength = 50
    If cfg.MaxPathLength > 32000 Then cfg.MaxPathLength = 32000
    If cfg.MinBodyChars < 0 Then cfg.MinBodyChars = 0
    If cfg.ChunkSizeChars <= 0 Then cfg.ChunkSizeChars = 1000
    If cfg.ChunkOverlapChars < 0 Then cfg.ChunkOverlapChars = 0
    If cfg.ChunkOverlapChars >= cfg.ChunkSizeChars Then cfg.ChunkOverlapChars = cfg.ChunkSizeChars - 1
    If cfg.InlineLogoMaxKB < 0 Then cfg.InlineLogoMaxKB = 0
    If cfg.InlineLogoMaxKB > 10000 Then cfg.InlineLogoMaxKB = 10000
    ValidateRegexPatterns cfg.RejectSubjectRegex
    ValidateRegexPatterns cfg.RejectBodyRegex
End Sub

Private Sub ValidateRegexPatterns(ByRef patterns As Variant)
    If IsEmpty(patterns) Or IsNull(patterns) Then Exit Sub
    If Not IsArray(patterns) Then Exit Sub
    On Error Resume Next
    Dim re As Object: Set re = CreateObject("VBScript.RegExp")
    Dim i As Long
    For i = LBound(patterns) To UBound(patterns)
        If Len(CStr(patterns(i))) > 0 Then
            re.pattern = CStr(patterns(i))
            If Err.Number <> 0 Then
                Warn "Invalid regex pattern will be skipped: " & CStr(patterns(i))
                Err.Clear
            End If
        End If
    Next i
    On Error GoTo 0
End Sub

'=========================== CORE EXPORT =======================================

Private Sub UCX_Export(ByRef cfg As UCX_Config)
    On Error GoTo ErrHandler

    Debug.Print "=== UCX_Export STARTED ==="
    MsgBox "Export started. Check View > Immediate Window (Ctrl+G) for progress.", vbInformation, "UCX Export"

    If cfg.OfflineStrict Then
        Debug.Print "Checking offline status..."
        AssertOffline
        Debug.Print "Offline check passed"
    Else
        Debug.Print "Offline check skipped (CFG_OfflineStrict=False)"
    End If

    Dim outRoot As String: outRoot = EnsureFolderDeep(ChooseRoot(cfg.outRoot))
    Debug.Print "Output root: " & outRoot

    ' Lock
    Dim lockFile As String: lockFile = outRoot & "\" & LOCK_FILE
    If AcquireExportLock(lockFile) = False Then
        Err.Raise vbObjectError + 101, , "Another export is already running. Lock file exists: " & lockFile & vbCrLf & _
            "If no other export is running, manually delete this file and retry."
    End If
    Debug.Print "Lock acquired"

    ' Space check (100 MB)
    If Not CheckDiskSpace(outRoot, MIN_DISK_SPACE_MB * BYTES_PER_MB) Then
        Call ReleaseExportLock(outRoot & "\" & LOCK_FILE)
        Err.Raise vbObjectError + 102, , "Insufficient disk space. At least 100MB required in: " & outRoot
    End If
    Debug.Print "Disk space OK"

    CleanupOrphanedTempFiles outRoot

    ' State
    Dim stateLastUTC As Date
    If cfg.Full Then
        stateLastUTC = 0
        Debug.Print "Mode: FULL export (ignoring state)"
    ElseIf LCase$(Trim$(cfg.Since)) = "auto" And Not cfg.NoState Then
        stateLastUTC = ReadStateLastUTC(outRoot)
        Dim syncMsg As String
        If stateLastUTC = 0 Then
            syncMsg = "(never)"
        Else
            syncMsg = Format$(stateLastUTC, "yyyy-mm-dd hh:nn:ss")
        End If
        Debug.Print "Mode: DELTA from state file. Last sync: " & syncMsg
    ElseIf Len(Trim$(cfg.Since)) > 0 And LCase$(Trim$(cfg.Since)) <> "auto" Then
        stateLastUTC = SafeParseDate(cfg.Since)
        Debug.Print "Mode: DELTA from config. Since: " & Format$(stateLastUTC, "yyyy-mm-dd hh:nn:ss")
    End If

    ' Folders
    Dim folders As Collection
    Set folders = ResolveFolders(cfg.folders, cfg.PickFolders)
    If folders Is Nothing Or folders.count = 0 Then Err.Raise vbObjectError + 1, , "No folders selected."

    Debug.Print "Folders selected: " & folders.count
    Dim f As Object, fidx As Long
    For Each f In folders
        fidx = fidx + 1
        On Error Resume Next
        Debug.Print "  " & fidx & ". " & f.FolderPath & " (" & f.Items.Count & " items)"
        On Error GoTo ErrHandler
    Next f

    If cfg.ExcludeMarketing Then Debug.Print "WARNING: Marketing messages EXCLUDED by default (CFG_ExcludeMarketing=True)"
    If cfg.ExcludeAutoGenerated Then Debug.Print "WARNING: Auto-generated messages EXCLUDED by default (CFG_ExcludeAutoGenerated=True)"

    Dim filter As String
    If cfg.Full Or stateLastUTC = 0 Then
        filter = vbNullString
        Debug.Print "Filter: NONE (full export)"
    Else
        filter = "[ReceivedTime] >= '" & Format$(LocalFromUTC(stateLastUTC), "mm/dd/yyyy hh:nn") & "'"
        Debug.Print "Filter: " & filter
    End If

    Dim existing As Object: Set existing = CreateObject("Scripting.Dictionary")
    ScanExistingPacks outRoot, existing
    Debug.Print "Existing conversation packs: " & existing.count

    Dim conv As Object: Set conv = CreateObject("Scripting.Dictionary")

    Dim totalRows As Long
    Debug.Print "Scanning folders for messages..."
    For Each f In folders
        Dim rowsInFolder As Long
        Dim searchFolder As Boolean: searchFolder = IsSearchFolder(f)

        If CFG_ForceItemsLoop Or searchFolder Then
            Dim filterToUse As String
            If searchFolder Then
                filterToUse = ""
            Else
                filterToUse = filter
            End If
            rowsInFolder = LoadFolderViaItemsLoop(f, filterToUse, cfg, conv)
        Else
            rowsInFolder = LoadFolderIntoBuckets(f, filter, cfg, conv)
            If rowsInFolder = 0 Then
                Debug.Print "    GetTable returned 0 rows — falling back to Items loop"
                rowsInFolder = LoadFolderViaItemsLoop(f, filter, cfg, conv)
            End If
        End If

        Debug.Print "  Scanned " & f.FolderPath & ": " & rowsInFolder & " rows, " & conv.Count & " conversations so far"
        totalRows = totalRows + rowsInFolder
        DoEvents
    Next f
    Debug.Print "Total rows scanned: " & totalRows
    Debug.Print "Total conversations found: " & conv.count

    ' Export
    Dim key As Variant, exported As Long
    Debug.Print "Exporting conversations..."
    For Each key In conv.keys
        exported = exported + ExportConversationGroup(CStr(key), conv(key), existing, cfg, outRoot)
        If exported Mod 10 = 0 And exported > 0 Then Debug.Print "  Exported " & exported & " conversations..."
        If exported Mod 50 = 0 Then DoEvents
    Next key
    Debug.Print "Export complete. Total conversations written: " & exported

    ' Save state
    If cfg.SaveState And Not cfg.NoState Then
        WriteState outRoot, NowUTC(), FoldersToPaths(folders)
        Debug.Print "State saved"
    End If

    Call ReleaseExportLock(outRoot & "\" & LOCK_FILE)
    Debug.Print "Lock released"

    If exported = 0 Then
        MsgBox "Done. No conversations written (already current or filtered)." & vbCrLf & _
               "Scanned " & totalRows & " messages from " & folders.count & " folder(s)." & vbCrLf & _
               "Output: " & outRoot, vbInformation, "UCX Export Complete"
        Info "Done. No conversations written (already current or filtered)."
    Else
        MsgBox "Done. Conversations written or updated: " & exported & vbCrLf & _
               "Scanned " & totalRows & " messages from " & folders.count & " folder(s)." & vbCrLf & _
               "Output: " & outRoot, vbInformation, "UCX Export Complete"
        Info "Done. Conversations written or updated: " & exported
    End If

    Debug.Print "=== UCX_Export COMPLETED ==="
    Exit Sub

ErrHandler:
    ' Preserve original error before any cleanup overwrites Err
    Dim eNumber As Long, eDesc As String, eSrc As String
    eNumber = Err.Number: eDesc = Err.Description: eSrc = Err.source

    On Error Resume Next
    If Len(outRoot) > 0 Then Call ReleaseExportLock(outRoot & "\" & LOCK_FILE)
    On Error GoTo 0

    Dim errMsg As String
    errMsg = "Error during export:" & vbCrLf & _
             "Number: " & CStr(eNumber) & vbCrLf & _
             "Description: " & eDesc & vbCrLf & _
             "Source: " & eSrc
    MsgBox errMsg, vbCritical, "UCX Export Error"
    Warn "Error: " & eNumber & " - " & eDesc & " (source: " & eSrc & ")"
    Debug.Print "=== UCX_Export FAILED ==="
End Sub

'========================= SCAN / BUCKETING ====================================

Private Function RowVal(ByVal r As Object, ByVal name As String) As String
    On Error Resume Next
    RowVal = CStr(r(name))
    If Err.Number <> 0 Then RowVal = "": Err.Clear
End Function

Private Function IsSearchFolder(ByVal f As Object) As Boolean
    On Error Resume Next
    IsSearchFolder = (LCase$(TypeName(f)) = "searchfolder")
    If Err.Number <> 0 Or IsSearchFolder = False Then
        IsSearchFolder = (InStr(1, LCase$(f.FolderPath), "\search", vbTextCompare) > 0)
        Err.Clear
    End If
End Function

' Optional GetTable path (kept for completeness)
Private Function LoadFolderIntoBuckets(ByVal f As Object, ByVal filter As String, ByRef cfg As UCX_Config, ByRef conv As Object) As Long
    On Error GoTo CleanExit
    If f Is Nothing Then Exit Function
    Debug.Print "    LoadFolderIntoBuckets: " & f.FolderPath

    If HasAnyPattern(cfg.IncludePathPattern) Then If Not LikeAny(f.FolderPath, cfg.IncludePathPattern) Then Exit Function
    If HasAnyPattern(cfg.ExcludePathPattern) Then If LikeAny(f.FolderPath, cfg.ExcludePathPattern) Then Exit Function

    Dim tbl As Object
    On Error Resume Next
    If Len(filter) > 0 Then
        Debug.Print "    Calling GetTable with filter: " & filter
        Set tbl = f.GetTable(filter)
    Else
        Debug.Print "    Calling GetTable with empty string (all items)"
        Set tbl = f.GetTable("")
    End If
    If Err.Number <> 0 Then Err.Clear: Exit Function
    If tbl Is Nothing Then Exit Function
    On Error GoTo CleanExit
    Debug.Print "    GetTable succeeded"

    On Error Resume Next
    tbl.Columns.Add "EntryID": Err.Clear
    On Error GoTo CleanExit
    Debug.Print "    Table columns configured (safe set)"

    Dim r As Object, n As Long
    Debug.Print "    Starting row iteration (EndOfTable=" & tbl.EndOfTable & ")..."

    Do While Not tbl.EndOfTable
        Set r = tbl.GetNextRow
        n = n + 1

        Dim eid As String: eid = RowVal(r, "EntryID")
        If Len(eid) = 0 Then GoTo NextRow

        Dim it As Object
        Set it = GetItemWithRetry(eid, f.StoreID, 3)
        If it Is Nothing Then GoTo NextRow
        If TypeName(it) <> "MailItem" Then GoTo NextRow

        Dim mi As Object: Set mi = it
        ProcessMailItemToConversation mi, f, cfg, conv
NextRow:
        Set it = Nothing
    Loop

    LoadFolderIntoBuckets = n
CleanExit:
    If Err.Number <> 0 Then Debug.Print "    ERROR in LoadFolderIntoBuckets: " & Err.Description
End Function

' Helper function to process a single MailItem - eliminates code duplication
Private Sub ProcessMailItemToConversation(ByVal mi As Object, ByVal f As Object, _
                                          ByRef cfg As UCX_Config, ByRef conv As Object)
    On Error Resume Next
    
    Dim headersRaw As String: headersRaw = GetRawHeaders(mi)
    Dim headers As Object: Set headers = ParseHeaders(headersRaw)

    Dim meta As Object: Set meta = CreateObject("Scripting.Dictionary")
    meta("EntryID") = SafeStr(mi, "EntryID")
    meta("StoreID") = SafeParentStoreID(mi)
    meta("FolderPath") = SafeFolderPath(f)
    meta("Subject") = NzStr(mi.Subject)
    meta("SmartSubject") = SmartSubject(NzStr(mi.Subject))
    meta("From") = GetSenderSmtp(mi)
    meta("To") = GetRecipientsArray(mi, OL_TO)
    meta("CC") = GetRecipientsArray(mi, OL_CC)
    meta("ReceivedUtc") = ToUTC(NzDate(mi.ReceivedTime))
    meta("SentOnUtc") = ToUTC(NzDate(mi.SentOn))
    meta("Headers") = headers

    Dim preview As String
    If cfg.includeBodies And mi.DownloadState = OL_DOWNLOADSTATE_COMPLETE Then
        preview = Left$(NzStr(mi.Body), 4000)
    Else
        preview = vbNullString
    End If
    meta("BodyPreview") = preview
    meta("MessageId") = HeaderVal(headers, "Message-ID")
    meta("InReplyTo") = HeaderVal(headers, "In-Reply-To")
    meta("References") = SplitRefs(HeaderVal(headers, "References"))

    If Not ShouldExcludeByPolicy(meta, f.FolderPath, cfg) Then
        meta("ConvoKey") = PickConvoKey(mi, headers, meta)
        Dim sUtc As Date
        If meta("ReceivedUtc") <> 0 Then
            sUtc = meta("ReceivedUtc")
        Else
            sUtc = meta("SentOnUtc")
        End If
        meta("SortUtc") = sUtc
        If Not conv.Exists(meta("ConvoKey")) Then conv.Add meta("ConvoKey"), New Collection
        conv(meta("ConvoKey")).Add meta
    End If
End Sub

' Hardened Items loop (default)
Private Function LoadFolderViaItemsLoop(ByVal f As Object, ByVal filter As String, _
                                        ByRef cfg As UCX_Config, ByRef conv As Object) As Long
    On Error GoTo CleanExit
    If f Is Nothing Then Exit Function
    Debug.Print "    LoadFolderViaItemsLoop: " & f.FolderPath

    If HasAnyPattern(cfg.IncludePathPattern) Then If Not LikeAny(f.FolderPath, cfg.IncludePathPattern) Then Exit Function
    If HasAnyPattern(cfg.ExcludePathPattern) Then If LikeAny(f.FolderPath, cfg.ExcludePathPattern) Then Exit Function

    Dim itms As Object, view As Object
    Set itms = f.Items  ' Case-sensitive in late binding!

    If Len(filter) > 0 And Not IsSearchFolder(f) Then
        On Error Resume Next
        Set view = itms.Restrict(filter)
        If Err.Number <> 0 Or view Is Nothing Then
            Debug.Print "      Restrict() ignored (fallback to unfiltered): " & Err.Description
            Err.Clear
            Set view = itms
        End If
        On Error GoTo CleanExit
    Else
        Set view = itms
    End If

    Dim cnt As Long
    On Error Resume Next
    cnt = view.Count
    If Err.Number <> 0 Then
        Debug.Print "      Could not read .Count; will For Each enumerate. Reason: " & Err.Description
        Err.Clear
        cnt = -1
    End If
    On Error GoTo CleanExit

    Dim processed As Long
    Dim stepDo As Long: stepDo = LOOP_DOEVENTS_STEP

    If cnt >= 0 Then
        Dim idx As Long
        For idx = 1 To cnt
            On Error GoTo SkipItem
            Dim it As Object
            ' Explicit default property: avoids Error 450 on some hosts
            Set it = view.Item(idx)
            If Not it Is Nothing Then
                If TypeName(it) = "MailItem" Then
                    Dim mi As Object: Set mi = it

                    Dim headersRaw As String: headersRaw = GetRawHeaders(mi)
                    Dim headers As Object: Set headers = ParseHeaders(headersRaw)

                    Dim meta As Object: Set meta = CreateObject("Scripting.Dictionary")
                    meta("EntryID") = SafeStr(mi, "EntryID")
                    meta("StoreID") = SafeParentStoreID(mi)
                    meta("FolderPath") = SafeFolderPath(f)
                    meta("Subject") = NzStr(mi.Subject)
                    meta("SmartSubject") = SmartSubject(NzStr(mi.Subject))
                    meta("From") = GetSenderSmtp(mi)
                    meta("To") = GetRecipientsArray(mi, OL_TO)
                    meta("CC") = GetRecipientsArray(mi, OL_CC)
                    meta("ReceivedUtc") = ToUTC(NzDate(mi.ReceivedTime))
                    meta("SentOnUtc") = ToUTC(NzDate(mi.SentOn))
                    meta("Headers") = headers

                    Dim preview As String
                    If cfg.includeBodies And mi.DownloadState = OL_DOWNLOADSTATE_COMPLETE Then
                        preview = Left$(NzStr(mi.Body), 4000)
                    Else
                        preview = vbNullString
                    End If
                    meta("BodyPreview") = preview
                    meta("MessageId") = HeaderVal(headers, "Message-ID")
                    meta("InReplyTo") = HeaderVal(headers, "In-Reply-To")
                    meta("References") = SplitRefs(HeaderVal(headers, "References"))

                    If Not ShouldExcludeByPolicy(meta, f.FolderPath, cfg) Then
                        meta("ConvoKey") = PickConvoKey(mi, headers, meta)
                        Dim sUtc As Date
                        If meta("ReceivedUtc") <> 0 Then
                            sUtc = meta("ReceivedUtc")
                        Else
                            sUtc = meta("SentOnUtc")
                        End If
                        meta("SortUtc") = sUtc
                        If Not conv.Exists(meta("ConvoKey")) Then conv.Add meta("ConvoKey"), New Collection
                        conv(meta("ConvoKey")).Add meta
                    End If
                End If
            End If
            processed = processed + 1
SkipItem:
            Warn "Skipping item in LoadFolderViaItemsLoop due to error " & Err.Number & ": " & Err.Description
            Err.Clear
            If processed Mod stepDo = 0 Then DoEvents
        Next idx
    Else
        Dim it2 As Object
        For Each it2 In view
            On Error GoTo SkipItem2
            If Not it2 Is Nothing Then
                If TypeName(it2) = "MailItem" Then
                    Dim mi2 As Object: Set mi2 = it2

                    Dim headersRaw2 As String: headersRaw2 = GetRawHeaders(mi2)
                    Dim headers2 As Object: Set headers2 = ParseHeaders(headersRaw2)

                    Dim meta2 As Object: Set meta2 = CreateObject("Scripting.Dictionary")
                    meta2("EntryID") = SafeStr(mi2, "EntryID")
                    meta2("StoreID") = SafeParentStoreID(mi2)
                    meta2("FolderPath") = SafeFolderPath(f)
                    meta2("Subject") = NzStr(mi2.Subject)
                    meta2("SmartSubject") = SmartSubject(NzStr(mi2.Subject))
                    meta2("From") = GetSenderSmtp(mi2)
                    meta2("To") = GetRecipientsArray(mi2, OL_TO)
                    meta2("CC") = GetRecipientsArray(mi2, OL_CC)
                    meta2("ReceivedUtc") = ToUTC(NzDate(mi2.ReceivedTime))
                    meta2("SentOnUtc") = ToUTC(NzDate(mi2.SentOn))
                    meta2("Headers") = headers2

                    Dim preview2 As String
                    If cfg.includeBodies And mi2.DownloadState = OL_DOWNLOADSTATE_COMPLETE Then
                        preview2 = Left$(NzStr(mi2.Body), 4000)
                    Else
                        preview2 = vbNullString
                    End If
                    meta2("BodyPreview") = preview2
                    meta2("MessageId") = HeaderVal(headers2, "Message-ID")
                    meta2("InReplyTo") = HeaderVal(headers2, "In-Reply-To")
                    meta2("References") = SplitRefs(HeaderVal(headers2, "References"))

                    If Not ShouldExcludeByPolicy(meta2, f.FolderPath, cfg) Then
                        meta2("ConvoKey") = PickConvoKey(mi2, headers2, meta2)
                        Dim sUtc2 As Date
                        If meta2("ReceivedUtc") <> 0 Then
                            sUtc2 = meta2("ReceivedUtc")
                        Else
                            sUtc2 = meta2("SentOnUtc")
                        End If
                        meta2("SortUtc") = sUtc2
                        If Not conv.Exists(meta2("ConvoKey")) Then conv.Add meta2("ConvoKey"), New Collection
                        conv(meta2("ConvoKey")).Add meta2
                    End If
                End If
            End If
            processed = processed + 1
SkipItem2:
            Warn "Skipping item in LoadFolderViaItemsLoop (ForEach) due to error " & Err.Number & ": " & Err.Description
            Err.Clear
            If processed Mod stepDo = 0 Then DoEvents
        Next it2
    End If

    LoadFolderViaItemsLoop = processed
CleanExit:
    If Err.Number <> 0 Then Debug.Print "    ERROR in LoadFolderViaItemsLoop: " & Err.Description
End Function

'======================= CONVERSATION EXPORT ===================================

Private Function ExportConversationGroup(ByVal convoKey As String, ByVal msgs As Collection, _
    ByRef existing As Object, ByRef cfg As UCX_Config, ByVal outRoot As String) As Long

    On Error GoTo EH
    If msgs Is Nothing Or msgs.count = 0 Then Exit Function

    Dim sorted As Collection: Set sorted = SortedCopyByKey(msgs, "SortUtc", True)
    Dim newest As Object: Set newest = sorted(sorted.count)

    Dim smart As String
    If newest.Exists("SmartSubject") Then smart = newest("SmartSubject") Else smart = "_"

    Dim startUtc As Date, lastUtc As Date
    startUtc = NzDate(sorted(1)("SortUtc"))
    lastUtc = NzDate(newest("SortUtc"))

    Dim emit As Collection
    If cfg.LeavesOnly Then
        Set emit = ComputeLeaves(sorted)
        If emit.count = 0 Then Set emit = New Collection: emit.Add newest
        Set emit = SortedCopyByKey(emit, "SortUtc", False)
    Else
        Set emit = sorted
    End If

    Dim desiredName As String
    desiredName = ComputeConvoDirName(smart, lastUtc, convoKey, outRoot, cfg)
    Dim existingPack As Object: Set existingPack = Nothing
    If existing.Exists(convoKey) Then Set existingPack = existing(convoKey)

    Dim convDir As String
    If Not existingPack Is Nothing Then convDir = existingPack("Path") Else convDir = EnsureFolderDeep(outRoot & "\" & desiredName)
    Dim attDir As String: attDir = EnsureFolderDeep(convDir & "\attachments")

    Dim shaToName As Object: Set shaToName = CreateObject("Scripting.Dictionary")
    SeedAttachmentMapFromManifest convDir, shaToName

    Dim attMeta As Object: Set attMeta = CreateObject("Scripting.Dictionary")
    Dim attCount As Long: attCount = 0

    If cfg.IncludeAttachments Then
        Dim j As Long
        For j = 1 To sorted.count
            Dim m As Object: Set m = sorted(j)
            SaveAttachmentsForItem m, attDir, shaToName, attMeta, attCount, cfg
        Next j
    End If

    Dim rawLines As New Collection
    Dim cleanLines As New Collection
    Dim chunks As New Collection

    Dim e As Long
    For e = 1 To emit.count
        Dim mm As Object: Set mm = emit(e)
        rawLines.Add String$(80, "-")
        rawLines.Add Format$(NzDate(mm("SortUtc")), "yyyy-mm-dd\Thh:nn:ss\Z") & _
                    " | From: " & NzStr(mm("From")) & _
                    " | To: " & JoinEmails(mm("To"))
        If CountRecipients(mm("CC")) > 0 Then rawLines.Add "Cc: " & JoinEmails(mm("CC"))
        rawLines.Add "Subject: " & NzStr(mm("Subject"))
        rawLines.Add vbNullString

        Dim bodyText As String
        If cfg.includeBodies Then
            bodyText = NzStr(mm("BodyPreview"))
            If Len(bodyText) = 0 Then bodyText = SafeGetBody(mm("EntryID"), mm("StoreID"))
            If Len(bodyText) = 0 Then bodyText = "(no body extracted)"
        Else
            bodyText = "(bodies disabled)"
        End If
        rawLines.Add bodyText
        rawLines.Add vbNullString

        If cfg.CleanBodies Then
            Dim clean As String: clean = CleanBodyForNLP(bodyText)
            If Len(clean) >= cfg.MinBodyChars Then
                cleanLines.Add String$(80, "-")
                cleanLines.Add Format$(NzDate(mm("SortUtc")), "yyyy-mm-dd\Thh:nn:ss\Z") & _
                              " | From: " & LCase$(NzStr(mm("From"))) & _
                              " | To: " & JoinEmailsNormalized(mm("To"))
                cleanLines.Add vbNullString
                cleanLines.Add clean
                cleanLines.Add vbNullString

                If cfg.EmitChunks Then
                    Dim parts As Variant: parts = SplitIntoChunks(clean, cfg.ChunkSizeChars, cfg.ChunkOverlapChars)
                    Dim pos As Long
                    For pos = LBound(parts) To UBound(parts)
                        Dim cj As Object: Set cj = CreateObject("Scripting.Dictionary")
                        cj("conversation_key") = convoKey
                        cj("message_id") = NzStr(mm("MessageId"))
                        Dim sortUtcVal As Date: sortUtcVal = NzDate(mm("SortUtc"))
                        If sortUtcVal <> 0 Then cj("sort_utc") = Format$(sortUtcVal, "yyyy-mm-dd\Thh:nn:ss\Z") Else cj("sort_utc") = Null
                        cj("subject") = NzStr(mm("SmartSubject"))
                        cj("from") = LCase$(NzStr(mm("From")))
                        cj("to") = RecipsToLower(mm("To"))
                        cj("position") = (pos - LBound(parts) + 1)
                        cj("text") = CStr(parts(pos))
                        chunks.Add cj
                    Next pos
                End If
            End If
        End If
    Next e

    WriteTextFile convDir & "\Conversation.txt", JoinCollection(rawLines, vbCrLf), cfg.NoBomEncoding
    If cfg.CleanBodies Then WriteTextFile convDir & "\Conversation.clean.txt", JoinCollection(cleanLines, vbCrLf), cfg.NoBomEncoding
    If cfg.EmitChunks And chunks.count > 0 Then
        Dim sb As String, k As Long
        For k = 1 To chunks.count
            sb = sb & JsonSerializeDict(chunks(k)) & vbCrLf
        Next k
        WriteTextFile convDir & "\chunks.jsonl", sb, cfg.NoBomEncoding
    End If

    Dim participants As Object: Set participants = UniqueParticipants(sorted)
    Dim messagesArr As Object: Set messagesArr = MessagesArray(sorted, cfg.includeBodies)
    Dim hasAtt As Boolean: hasAtt = (attCount > 0)

    Dim manifest As Object: Set manifest = CreateObject("Scripting.Dictionary")
    manifest("conversation_key") = convoKey
    manifest("smart_subject") = smart
    If startUtc <> 0 Then manifest("conversation_start_utc") = Format$(startUtc, "yyyy-mm-dd\Thh:nn:ss\Z") Else manifest("conversation_start_utc") = Null
    If lastUtc <> 0 Then manifest("last_message_utc") = Format$(lastUtc, "yyyy-mm-dd\Thh:nn:ss\Z") Else manifest("last_message_utc") = Null
    manifest("from") = LCase$(NzStr(newest("From")))
    manifest("to") = RecipsToLower(newest("To"))
    manifest("cc") = RecipsToLower(newest("CC"))
    manifest("participants") = participants
    manifest("messages_count") = sorted.count
    manifest("has_attachment") = hasAtt
    manifest("attachments") = DictValues(attMeta)
    manifest("message_ids") = CollectMessageIds(sorted)

    Dim nlp As Object: Set nlp = CreateObject("Scripting.Dictionary")
    nlp("cleaned_bodies") = cfg.CleanBodies
    nlp("emit_chunks") = cfg.EmitChunks
    nlp("chunk_size_chars") = cfg.ChunkSizeChars
    nlp("chunk_overlap_chars") = cfg.ChunkOverlapChars
    nlp("min_body_chars") = cfg.MinBodyChars
    nlp("leaves_only") = cfg.LeavesOnly
    manifest("nlp") = nlp
    manifest("messages") = messagesArr

    If Not ValidateManifest(manifest, attDir) Then
        Warn "Manifest validation failed for conversation: " & convoKey
    End If

    WriteTextFile convDir & "\manifest.json", JsonSerializeDict(manifest), cfg.NoBomEncoding
    ExportConversationGroup = 1
    Exit Function
EH:
    Warn "ExportConversationGroup error: " & Err.Number & " - " & Err.Description
End Function

'============================= ATTACHMENTS =====================================

Private Sub SaveAttachmentsForItem(ByVal meta As Object, ByVal attDir As String, _
    ByRef shaToName As Object, ByRef attMeta As Object, ByRef attCount As Long, ByRef cfg As UCX_Config)
    On Error GoTo ExitSub

    Dim mi As Object
    If Application.Session Is Nothing Then
        Warn "Application.Session is Nothing in SaveAttachmentsForItem"
        GoTo ExitSub
    End If
    Set mi = Application.Session.GetItemFromID(CStr(meta("EntryID")), CStr(meta("StoreID")))
    If mi Is Nothing Then GoTo ExitSub
    If mi.DownloadState <> OL_DOWNLOADSTATE_COMPLETE Then GoTo ExitSub
    If mi.Attachments.Count = 0 Then GoTo ExitSub

    Dim htmlBody As String
    If mi.BodyFormat = OL_FORMAT_HTML Then On Error Resume Next: htmlBody = mi.htmlBody: On Error GoTo ExitSub

    Dim a As Object
    For Each a In mi.Attachments
        If a Is Nothing Then GoTo NextA

        ' Early skip: TNEF container and trivial inline/logo/p7s
        Dim lnameEarly As String: lnameEarly = LCase$(NzStr(a.fileName))
        If lnameEarly = "winmail.dat" Then GoTo NextA
        If AttachmentIsInline(a, htmlBody, cfg) Then GoTo NextA

        Dim tmp As String: tmp = attDir & "\_tmp_" & CreateRandomName()
        On Error Resume Next
        a.SaveAsFile tmp
        If Err.Number <> 0 Then Err.Clear: GoTo NextA
        On Error GoTo ExitSub

        Dim sha As String: sha = SHA256_File(tmp)
        Dim finalName As String
        If Len(sha) = 0 Then
            KillSafe tmp
            Warn "Attachment hash failed for: " & NzStr(a.fileName) & " - skipping"
            GoTo NextA
        ElseIf shaToName.Exists(sha) Then
            finalName = shaToName(sha)
            If Len(Dir$(attDir & "\" & finalName)) = 0 Then FileCopy tmp, attDir & "\" & finalName
        Else
            finalName = UniqueDestFile(attDir, SanitizeName(NzStr(a.fileName)), cfg)
            FileCopy tmp, attDir & "\" & finalName
            shaToName(sha) = finalName
        End If
        KillSafe tmp

        Dim fi As Object: Set fi = CreateObject("Scripting.FileSystemObject").GetFile(attDir & "\" & finalName)
        Dim md As Object: Set md = CreateObject("Scripting.Dictionary")
        md("filename") = finalName
        md("extension") = GetExtension(finalName)
        md("filetype") = Null
        md("size_bytes") = CLng(fi.size)
        If Len(sha) > 0 Then
            md("sha256") = sha
        Else
            md("sha256") = Null
        End If
        attCount = attCount + 1
        attMeta(attCount) = md

NextA:
    Next a

    ' One-level nested .msg
    If cfg.IncludeNestedAttachments And cfg.NestedDepth > 0 Then
        For Each a In mi.Attachments
            If a Is Nothing Then GoTo NextB
            Dim lname As String: lname = LCase$(NzStr(a.fileName))
            If Right$(lname, 4) = ".msg" Then
                Dim tmpMsg As String: tmpMsg = attDir & "\_tmp_" & CreateRandomName() & ".msg"
                On Error Resume Next
                a.SaveAsFile tmpMsg
                If Err.Number = 0 Then
                    On Error GoTo ExitSub
                    Dim nested As Object
                    Set nested = Application.CreateItemFromTemplate(tmpMsg)
                    If Not nested Is Nothing Then
                        Dim na As Object
                        For Each na In nested.Attachments
                            Dim nlow As String: nlow = LCase$(NzStr(na.fileName))
                            If Right$(nlow, 4) = ".msg" Then GoTo NextNA
                            Dim t2 As String: t2 = attDir & "\_tmp_" & CreateRandomName()
                            On Error Resume Next
                            na.SaveAsFile t2
                            If Err.Number = 0 Then
                                On Error GoTo ExitSub
                                Dim nsha As String: nsha = SHA256_File(t2)
                                If Len(nsha) > 0 And Not shaToName.Exists(nsha) Then
                                    Dim nFinal As String: nFinal = UniqueDestFile(attDir, SanitizeName(na.fileName), cfg)
                                    FileCopy t2, attDir & "\" & nFinal
                                    shaToName(nsha) = nFinal
                                    Dim nfi As Object: Set nfi = CreateObject("Scripting.FileSystemObject").GetFile(attDir & "\" & nFinal)
                                    Dim nmd As Object: Set nmd = CreateObject("Scripting.Dictionary")
                                    nmd("filename") = nFinal
                                    nmd("extension") = GetExtension(nFinal)
                                    nmd("filetype") = Null
                                    nmd("size_bytes") = CLng(nfi.size)
                                    nmd("sha256") = nsha
                                    attCount = attCount + 1
                                    attMeta(attCount) = nmd
                                End If
                            End If
                            KillSafe t2
NextNA:
                        Next na
                    End If
                End If
                KillSafe tmpMsg
            End If
NextB:
        Next a
    End If

ExitSub:
    On Error Resume Next
    Set mi = Nothing
End Sub

'============================= UTILITIES =======================================

Private Function FoldersToPaths(ByVal coll As Collection) As Variant
    Dim arr() As String
    ReDim arr(0 To coll.count - 1)
    Dim i As Long
    For i = 1 To coll.count
        arr(i - 1) = coll(i).FolderPath
    Next i
    FoldersToPaths = arr
End Function

Private Function NowUTC() As Date: NowUTC = ToUTC(Now): End Function

Private Function ToUTC(ByVal d As Date) As Date
    If d = 0 Then ToUTC = 0: Exit Function
    Dim tz As TIME_ZONE_INFORMATION, stLocal As SYSTEMTIME, stUtc As SYSTEMTIME
    GetTimeZoneInformation tz
    DateToSystemTime d, stLocal
    If TzSpecificLocalTimeToSystemTime(tz, stLocal, stUtc) <> 0 Then
        ToUTC = SystemTimeToDate(stUtc)
    Else
        ToUTC = d
    End If
End Function

Private Function LocalFromUTC(ByVal d As Date) As Date
    If d = 0 Then LocalFromUTC = 0: Exit Function
    Dim tz As TIME_ZONE_INFORMATION, stLocal As SYSTEMTIME, stUtc As SYSTEMTIME
    GetTimeZoneInformation tz
    DateToSystemTime d, stUtc
    If SystemTimeToTzSpecificLocalTime(tz, stUtc, stLocal) <> 0 Then
        LocalFromUTC = SystemTimeToDate(stLocal)
    Else
        LocalFromUTC = d
    End If
End Function

Private Sub DateToSystemTime(ByVal dt As Date, ByRef st As SYSTEMTIME)
    st.wYear = Year(dt)
    st.wMonth = Month(dt)
    st.wDay = Day(dt)
    st.wHour = Hour(dt)
    st.wMinute = Minute(dt)
    st.wSecond = Second(dt)
    st.wMilliseconds = 0
End Sub

Private Function SystemTimeToDate(ByRef st As SYSTEMTIME) As Date
    SystemTimeToDate = DateSerial(st.wYear, st.wMonth, st.wDay) + _
                       TimeSerial(st.wHour, st.wMinute, st.wSecond)
End Function

' ---- ISO-8601 parsing (fixes state/manifest roundtrip) ----
Private Function ParseIso8601Utc(ByVal s As String) As Date
    Dim re As Object: Set re = CreateObject("VBScript.RegExp")
    re.Global = False: re.IgnoreCase = True
    re.pattern = "^\s*(\d{4})-(\d{2})-(\d{2})[T\s](\d{2}):(\d{2}):(\d{2})Z\s*$"
    Dim m As Object: Set m = re.Execute(s)
    If m.count > 0 Then
        ParseIso8601Utc = DateSerial(CInt(m(0).SubMatches(0)), CInt(m(0).SubMatches(1)), CInt(m(0).SubMatches(2))) + _
                          TimeSerial(CInt(m(0).SubMatches(3)), CInt(m(0).SubMatches(4)), CInt(m(0).SubMatches(5)))
    Else
        On Error Resume Next
        ParseIso8601Utc = CDate(s)
        On Error GoTo 0
    End If
End Function

Private Function SafeParseDate(ByVal s As String) As Date
    SafeParseDate = ParseIso8601Utc(s)
End Function

Private Function NzDate(ByVal d As Date) As Date
    If d = 0 Then
        NzDate = 0
    Else
        NzDate = d
    End If
End Function

Private Function NzStr(ByVal s As String) As String
    If Len(s) = 0 Then
        NzStr = ""
    Else
        NzStr = s
    End If
End Function

Private Sub AssertOffline()
    On Error Resume Next
    Dim s As Object: Set s = Application.Session
    Dim isOffline As Boolean
    If s Is Nothing Then Exit Sub
    If s.Offline Then
        isOffline = True
    Else
        Dim mode As Long: mode = s.ExchangeConnectionMode
        If mode = OLCM_CachedOffline Or mode = OLCM_Disconnected Then isOffline = True
    End If
    On Error GoTo 0
    If Not isOffline Then
        Err.Raise vbObjectError + 100, , "Outlook is not offline. Switch to 'Work Offline' (or set CFG_OfflineStrict=False)."
    End If
End Sub

Private Function DesktopOutRoot() As String
    Dim ws As Object: Set ws = CreateObject("WScript.Shell")
    DesktopOutRoot = EnsureFolderDeep(ws.SpecialFolders("Desktop") & "\Outlook")
End Function

Private Function ChooseRoot(ByVal s As String) As String
    If Len(Trim$(s)) > 0 Then
        ChooseRoot = s
    Else
        ChooseRoot = DesktopOutRoot()
    End If
End Function

' ---- UNC-aware deep folder creation ----
Private Function EnsureFolderDeep(ByVal path As String) As String
    Dim fso As Object: Set fso = CreateObject("Scripting.FileSystemObject")
    If fso.FolderExists(path) Then EnsureFolderDeep = path: Exit Function

    Dim parts As Variant: parts = Split(path, "\")
    Dim cur As String, i As Long

    If Left$(path, 2) = "\\" Then
        If UBound(parts) < 3 Then Err.Raise vbObjectError + 701, , "UNC path missing share: " & path
        cur = "\\" & parts(2) & "\" & parts(3)  ' \\server\share
        i = 4
    Else
        cur = parts(0)
        i = 1
    End If

    For i = i To UBound(parts)
        If Len(parts(i)) > 0 Then
            cur = cur & "\" & parts(i)
            If Not fso.FolderExists(cur) Then fso.CreateFolder cur
        End If
    Next i

    EnsureFolderDeep = path
End Function

'--------------------- Folder resolution ---------------------------------------

Private Function ResolveFolders(ByVal spec As Variant, ByVal pick As Boolean) As Collection
    Dim result As New Collection
    If Application.Session Is Nothing Then
        Err.Raise vbObjectError + 999, "ResolveFolders", "Application.Session is Nothing"
    End If
    
    If pick Or IsEmpty(spec) Or IsNull(spec) Then
        Do
            Dim f As Object
            Set f = Application.Session.PickFolder
            If f Is Nothing Then Exit Do
            result.Add f
        Loop While MsgBox("Pick another folder?", vbQuestion + vbYesNo) = vbYes
    Else
        Dim i As Long
        For i = LBound(spec) To UBound(spec)
            Dim one As String: one = CStr(spec(i))
            Dim mf As Object: Set mf = FindFolderByPath(one)
            If Not mf Is Nothing Then result.Add mf Else Warn "Folder not found: " & one
        Next i
        If result.count = 0 Then
            Dim f2 As Object: Set f2 = Application.Session.PickFolder
            If Not f2 Is Nothing Then result.Add f2
        End If
    End If
    Set ResolveFolders = result
End Function

Private Function FindFolderByPath(ByVal path As String) As Object
    On Error Resume Next
    If Application.Session Is Nothing Then Exit Function
    If Left$(path, 2) = "\\" Then path = mid$(path, 3)
    Dim parts As Variant: parts = Split(path, "\")
    Dim st As Object
    For Each st In Application.Session.Stores
        If LCase$(st.DisplayName) = LCase$(parts(0)) Then
            Dim f As Object: Set f = st.GetRootFolder
            Dim i As Long
            For i = 1 To UBound(parts)
                Set f = f.Folders(parts(i))
                If f Is Nothing Then Exit For
            Next i
            If Not f Is Nothing Then Set FindFolderByPath = f: Exit Function
        End If
    Next st
    Set FindFolderByPath = Nothing
End Function

'---------------------- Headers / keys -----------------------------------------

Private Function GetRawHeaders(ByVal mi As Object) As String
    On Error Resume Next
    If mi Is Nothing Then Exit Function
    Dim pa As Object: Set pa = mi.PropertyAccessor
    If pa Is Nothing Then Exit Function
    Dim raw As String: raw = NzStr(pa.GetProperty(PR_HDRS_W))
    If Len(raw) = 0 Then raw = NzStr(pa.GetProperty(PR_HDRS_A))
    GetRawHeaders = raw
End Function

Private Function ParseHeaders(ByVal raw As String) As Object
    Dim dict As Object: Set dict = CreateObject("Scripting.Dictionary")
    If Len(raw) = 0 Then Set ParseHeaders = dict: Exit Function

    Dim lines As Variant: lines = Split(Replace(raw, vbCrLf, vbLf), vbLf)
    Dim i As Long, lastKey As String
    For i = LBound(lines) To UBound(lines)
        Dim ln As String: ln = lines(i)
        If Len(ln) = 0 Then GoTo cont
        If (Left$(ln, 1) = " " Or Left$(ln, 1) = vbTab) And Len(lastKey) > 0 Then
            dict(lastKey) = dict(lastKey) & " " & Trim$(ln): GoTo cont
        End If
        Dim p As Long: p = InStr(1, ln, ":", vbBinaryCompare)
        If p > 0 Then
            Dim k As String, v As String
            k = Trim$(Left$(ln, p - 1)): v = Trim$(mid$(ln, p + 1))
            lastKey = k
            dict(k) = v
        End If
cont:
    Next i

    Set ParseHeaders = dict
End Function

Private Function HeaderVal(ByVal headers As Object, ByVal key As String) As String
    Dim k As Variant
    For Each k In headers.keys
        If LCase$(CStr(k)) = LCase$(key) Then HeaderVal = headers(k): Exit Function
    Next k
    HeaderVal = vbNullString
End Function

Private Function SplitRefs(ByVal refs As String) As Variant
    If Len(Trim$(refs)) = 0 Then SplitRefs = Array(): Exit Function
    SplitRefs = Split(Trim$(refs), " ")
End Function

Private Function SmartSubject(ByVal s As String) As String
    Dim t As String: t = Trim$(s)
    Dim prefixes As Variant: prefixes = Array("re: ", "fw: ", "fwd: ", "sv: ", "aw: ", "wg: ", "antw: ")
    Dim changed As Boolean
    Do
        changed = False
        Dim i As Long
        For i = LBound(prefixes) To UBound(prefixes)
            If LCase$(Left$(t, Len(prefixes(i)))) = prefixes(i) Then
                t = mid$(t, Len(prefixes(i)) + 1)
                changed = True
                Exit For
            End If
        Next i
    Loop While changed
    If Len(t) = 0 Then SmartSubject = "_" Else SmartSubject = t
End Function

Private Function NormalizeEmail(ByVal s As String) As String
    Dim m1 As Long, m2 As Long
    s = Trim$(s)
    m1 = InStr(1, s, "<", vbTextCompare)
    m2 = InStr(1, s, ">", vbTextCompare)
    If m1 > 0 And m2 > m1 Then
        NormalizeEmail = LCase$(Trim$(mid$(s, m1 + 1, m2 - m1 - 1)))
    Else
        NormalizeEmail = LCase$(s)
    End If
End Function

Private Function GetSenderSmtp(ByVal mi As Object) As String
    On Error Resume Next
    Dim ae As Object: Set ae = mi.Sender
    If Not ae Is Nothing Then
        If ae.Type = "EX" Then
            Dim ex As Object: Set ex = ae.GetExchangeUser
            If Not ex Is Nothing Then GetSenderSmtp = ex.PrimarySmtpAddress: Exit Function
            Dim dl As Object: Set dl = ae.GetExchangeDistributionList
            If Not dl Is Nothing Then GetSenderSmtp = dl.PrimarySmtpAddress: Exit Function
        End If
        If Len(NzStr(ae.Address)) > 0 Then GetSenderSmtp = ae.Address: Exit Function
    End If
    GetSenderSmtp = NzStr(mi.SenderEmailAddress)
End Function

Private Function GetRecipientSmtp(ByVal r As Object) As String
    On Error Resume Next
    Dim ae As Object: Set ae = r.AddressEntry
    If Not ae Is Nothing Then
        If ae.Type = "EX" Then
            Dim ex As Object: Set ex = ae.GetExchangeUser
            If Not ex Is Nothing Then GetRecipientSmtp = ex.PrimarySmtpAddress: Exit Function
            Dim dl As Object: Set dl = ae.GetExchangeDistributionList
            If Not dl Is Nothing Then GetRecipientSmtp = dl.PrimarySmtpAddress: Exit Function
        End If
        If Len(NzStr(ae.Address)) > 0 Then GetRecipientSmtp = ae.Address: Exit Function
    End If
    GetRecipientSmtp = ""
End Function

Private Function GetRecipientsArray(ByVal mi As Object, ByVal typ As Long) As Object
    Dim arr As Object: Set arr = CreateObject("Scripting.Dictionary")
    If mi Is Nothing Then Set GetRecipientsArray = arr: Exit Function
    On Error Resume Next
    Dim r As Object
    For Each r In mi.Recipients
        If Not r Is Nothing And r.Type = typ Then
            Dim o As Object: Set o = CreateObject("Scripting.Dictionary")
            o("name") = NzStr(r.Name)
            o("smtp") = GetRecipientSmtp(r)
            If Len(o("smtp")) = 0 Then o("smtp") = NormalizeEmail(NzStr(r.Address))
            If Len(o("smtp")) > 0 Then
                arr(arr.count + 1) = o
            End If
        End If
    Next r
    On Error GoTo 0
    Set GetRecipientsArray = arr
End Function

Private Function PickConvoKey(ByVal mi As Object, ByVal headers As Object, ByVal meta As Object) As String
    On Error Resume Next
    Dim pa As Object: Set pa = mi.PropertyAccessor
    Dim v As Variant: v = pa.GetProperty(PR_CONV_ID)
    If Not IsEmpty(v) Then
        Dim b64 As String: b64 = Base64OfBytes(v)
        If Len(b64) > 0 Then PickConvoKey = "cid:" & b64: Exit Function
    End If
    Dim v2 As Variant: v2 = pa.GetProperty(PR_CONV_INDEX)
    If Not IsEmpty(v2) Then
        Dim b64_2 As String: b64_2 = Base64OfBytes(v2)
        If Len(b64_2) >= 22 Then PickConvoKey = "ti:" & Left$(b64_2, 22): Exit Function
    End If
    Dim refs As Variant: refs = SplitRefs(HeaderVal(headers, "References"))
    Dim irt As String: irt = HeaderVal(headers, "In-Reply-To")
    Dim top As String
    If UBoundSafe(refs) >= 0 Then
        top = refs(0)
    Else
        top = irt
    End If
    If Len(top) > 0 Then PickConvoKey = "ref:" & top: Exit Function
    Dim subu As String: subu = SmartSubject(NzStr(meta("Subject")))
    Dim fromE As String: fromE = NormalizeEmail(NzStr(meta("From")))
    Dim toS As String: toS = JoinEmailsNormalized(meta("To"))
    PickConvoKey = "sub:" & SHA256_StringUTF8(subu & "|" & fromE & "|" & toS)
End Function

Private Function UBoundSafe(ByVal arr As Variant) As Long
    On Error Resume Next: UBoundSafe = -1: If IsArray(arr) Then UBoundSafe = UBound(arr)
End Function

'------------------------- Policies / filters ----------------------------------

Private Function ShouldExcludeByPolicy(ByVal meta As Object, ByVal folderPath As String, ByRef cfg As UCX_Config) As Boolean
    If HasAnyPattern(cfg.IncludePathPattern) Then If Not LikeAny(folderPath, cfg.IncludePathPattern) Then ShouldExcludeByPolicy = True: Exit Function
    If HasAnyPattern(cfg.ExcludePathPattern) Then If LikeAny(folderPath, cfg.ExcludePathPattern) Then ShouldExcludeByPolicy = True: Exit Function

    Dim fromAddr As String: fromAddr = NormalizeEmail(NzStr(meta("From")))
    If HasAnyPattern(cfg.AllowSenders) Then If Not AddressMatches(fromAddr, cfg.AllowSenders) Then ShouldExcludeByPolicy = True: Exit Function
    If HasAnyPattern(cfg.RejectSenders) Then If AddressMatches(fromAddr, cfg.RejectSenders) Then ShouldExcludeByPolicy = True: Exit Function
    If HasAnyPattern(cfg.RejectDomains) Then
        Dim i As Long
        For i = LBound(cfg.RejectDomains) To UBound(cfg.RejectDomains)
            If Right$(fromAddr, Len(cfg.RejectDomains(i)) + 1) = "@" & LCase$(cfg.RejectDomains(i)) Then ShouldExcludeByPolicy = True: Exit Function
        Next i
    End If
    If HasAnyPattern(cfg.RejectSubjectRegex) Then If AnyRegexMatch(cfg.RejectSubjectRegex, NzStr(meta("Subject"))) Then ShouldExcludeByPolicy = True: Exit Function
    If HasAnyPattern(cfg.RejectBodyRegex) Then If AnyRegexMatch(cfg.RejectBodyRegex, NzStr(meta("BodyPreview"))) Then ShouldExcludeByPolicy = True: Exit Function
    If cfg.ExcludeMarketing Then If IsMarketingMessage(meta("Headers")) Then ShouldExcludeByPolicy = True: Exit Function
    If cfg.ExcludeAutoGenerated Then If IsAutoGeneratedMessage(meta("Headers")) Then ShouldExcludeByPolicy = True: Exit Function
End Function

Private Function HasAnyPattern(ByVal v As Variant) As Boolean
    On Error Resume Next
    HasAnyPattern = Not (IsEmpty(v) Or IsNull(v) Or (IsArray(v) And (UBound(v) < LBound(v))))
End Function

Private Function LikeAny(ByVal s As String, ByVal arr As Variant) As Boolean
    Dim i As Long
    For i = LBound(arr) To UBound(arr)
        If s Like CStr(arr(i)) Then LikeAny = True: Exit Function
    Next i
End Function

Private Function AddressMatches(ByVal addr As String, ByVal arr As Variant) As Boolean
    Dim i As Long, y As String
    For i = LBound(arr) To UBound(arr)
        y = NormalizeEmail(CStr(arr(i)))
        If addr = y Then AddressMatches = True: Exit Function
        If Left$(y, 1) = "@" Then
            Dim domainPart As String: domainPart = mid$(y, 2)
            If Len(addr) > Len(domainPart) Then
                If Right$(addr, Len(domainPart)) = domainPart And mid$(addr, Len(addr) - Len(domainPart), 1) = "@" Then
                    AddressMatches = True: Exit Function
                End If
            End If
        End If
    Next i
End Function

Private Function AnyRegexMatch(ByVal patterns As Variant, ByVal text As String) As Boolean
    On Error Resume Next
    Dim re As Object: Set re = CreateObject("VBScript.RegExp")
    re.IgnoreCase = True: re.Global = False
    Dim i As Long
    For i = LBound(patterns) To UBound(patterns)
        Dim pat As String: pat = CStr(patterns(i))
        If Len(pat) = 0 Then GoTo NextPattern
        re.pattern = pat
        If Err.Number <> 0 Then
            Warn "Invalid regex pattern: " & pat
            Err.Clear
            GoTo NextPattern
        End If
        If re.Test(text) Then AnyRegexMatch = True: Exit Function
NextPattern:
    Next i
    On Error GoTo 0
End Function

' ---- Improved marketing & auto-generated detection ----
Private Function IsMarketingMessage(ByVal headers As Object) As Boolean
    Dim precedence As String: precedence = LCase$(HeaderVal(headers, "Precedence"))
    Dim xMailer As String: xMailer = LCase$(HeaderVal(headers, "X-Mailer"))
    Dim listId As String: listId = HeaderVal(headers, "List-Id")

    If precedence Like "*bulk*" Or precedence Like "*junk*" Or precedence Like "*list*" Then IsMarketingMessage = True: Exit Function
    If Len(listId) > 0 Then IsMarketingMessage = True: Exit Function

    If xMailer Like "*mailchimp*" Or xMailer Like "*sendgrid*" Or xMailer Like "*hubspot*" Or _
       xMailer Like "*marketo*" Or xMailer Like "*pardot*" Or xMailer Like "*eloqua*" Then
        IsMarketingMessage = True: Exit Function
    End If
End Function

Private Function IsAutoGeneratedMessage(ByVal headers As Object) As Boolean
    Dim autoV As String: autoV = LCase$(HeaderVal(headers, "Auto-Submitted"))
    Dim suppress As String: suppress = LCase$(HeaderVal(headers, "X-Auto-Response-Suppress"))
    If (autoV Like "*auto-replied*" And suppress Like "*oof*") Or (autoV Like "*vacation*") Then IsAutoGeneratedMessage = True: Exit Function
    If suppress Like "*oof*" Then IsAutoGeneratedMessage = True: Exit Function
End Function

'--------------------- Attachments heuristics ----------------------------------

Private Function AttachmentIsInline(ByVal a As Object, ByVal html As String, ByRef cfg As UCX_Config) As Boolean
    On Error Resume Next
    Dim pa As Object: Set pa = a.PropertyAccessor
    Dim cid As String: cid = NzStr(pa.GetProperty(PR_ATTACH_CIDW))
    If Len(cid) = 0 Then cid = NzStr(pa.GetProperty(PR_ATTACH_CIDA))
    Dim disp As String: disp = NzStr(pa.GetProperty(PR_ATTACH_CONTENT_DISP))
    If LCase$(disp) = "inline" Then AttachmentIsInline = True: Exit Function

    ' Early skip: TNEF / p7s, small logos, etc.
    Dim n As String: n = LCase$(NzStr(a.fileName))
    If n = "winmail.dat" Then AttachmentIsInline = True: Exit Function
    If Len(cid) > 0 And Len(html) > 0 Then
        Dim lc As String: lc = LCase$(cid)
        Dim h As String: h = LCase$(html)
        If InStr(1, h, "cid:" & lc, vbBinaryCompare) > 0 Or InStr(1, h, "cid:<" & lc & ">", vbBinaryCompare) > 0 Then
            AttachmentIsInline = True: Exit Function
        End If
    End If
    If cfg.SkipInlineLogos Then
        If n Like "*.p7s" Then AttachmentIsInline = True: Exit Function
        If (n Like "*.png" Or n Like "*.gif" Or n Like "*.jpg" Or n Like "*.jpeg" Or n Like "*.bmp" Or n Like "*.ico") Then
            If (n Like "*logo*" Or n Like "image#*" Or n Like "image*") And (a.Size < (cfg.InlineLogoMaxKB * 1024)) Then AttachmentIsInline = True: Exit Function
        End If
    End If
End Function

'--------------------- Cleaning pipeline ---------------------------------------

Private Function NormalizeWhitespace(ByVal s As String) As String
    Dim x As String: x = Replace(s, vbCr, "")
    x = ReplaceMultiple(x, Array(vbTab, "  ", "   ", "    "), " ")
    NormalizeWhitespace = Trim$(Replace(x, " " & vbLf, vbLf))
End Function

Private Function StripQuotedSections(ByVal s As String) As String
    Dim lines As Variant: lines = Split(Replace(s, vbCrLf, vbLf), vbLf)
    Dim out As New Collection, i As Long
    For i = LBound(lines) To UBound(lines)
        Dim L As String: L = lines(i)
        If L Like ">*" Then GoTo nxt
        If L Like "On * wrote:*" Then GoTo nxt
        If L Like "From: *" Then GoTo nxt
        out.Add L
nxt:
    Next i
    StripQuotedSections = JoinCollection(out, vbLf)
End Function

Private Function StripSignature(ByVal s As String) As String
    Dim lines As Variant: lines = Split(Replace(s, vbCrLf, vbLf), vbLf)
    Dim i As Long
    For i = UBound(lines) To LBound(lines) Step -1
        If Trim$(lines(i)) = "--" Then
            If i > 0 Then
                Dim j As Long, out As New Collection
                For j = LBound(lines) To i - 1: out.Add lines(j): Next j
                StripSignature = JoinCollection(out, vbLf)
                Exit Function
            End If
        End If
    Next i
    StripSignature = s
End Function

Private Function StripDisclaimers(ByVal s As String) As String
    ' Remove common email disclaimers and confidentiality notices
    Dim patterns As Variant
    patterns = Array( _
        "This e-mail.*confidential", _
        "CONFIDENTIALITY NOTICE", _
        "This message.*intended recipient", _
        "If you.*not the intended recipient" _
    )
    
    Dim result As String: result = s
    Dim re As Object: Set re = CreateObject("VBScript.RegExp")
    re.Global = True
    re.IgnoreCase = True
    
    Dim i As Long
    For i = LBound(patterns) To UBound(patterns)
        re.pattern = patterns(i) & "[\s\S]*$"
        result = re.Replace(result, "")
    Next i
    
    StripDisclaimers = Trim$(result)
End Function

Private Function CleanBodyForNLP(ByVal body As String) As String
    Dim b As String: b = NormalizeWhitespace(body)
    b = StripQuotedSections(b)
    b = StripSignature(b)
    b = StripDisclaimers(b)
    CleanBodyForNLP = Trim$(b)
End Function

Private Function SplitIntoChunks(ByVal text As String, ByVal size As Long, ByVal overlap As Long) As Variant
    Dim out As New Collection
    If size <= 0 Then out.Add text: SplitIntoChunks = CollectionToArray(out): Exit Function
    If overlap >= size Then overlap = size - 1
    If overlap < 0 Then overlap = 0

    Dim i As Long: i = 1
    Dim stp As Long: stp = size - overlap
    If stp <= 0 Then stp = 1

    Do While i <= Len(text)
        out.Add mid$(text, i, size)
        i = i + stp
    Loop
    SplitIntoChunks = CollectionToArray(out)
End Function

'---------------------- Naming / paths -----------------------------------------

Private Function SanitizeName(ByVal s As String) As String
    If Len(Trim$(s)) = 0 Then s = "unnamed"
    
    ' Prevent path traversal attacks
    s = Replace(s, "..", "_")
    s = Replace(s, "~", "_")
    
    Dim bad As Variant: bad = Array("<", ">", ":", """", "/", "\", "|", "?", "*")
    Dim i As Long
    For i = LBound(bad) To UBound(bad)
        s = Replace(s, CStr(bad(i)), "_")
    Next i
    Do While Len(s) > 0 And (Right$(s, 1) = "." Or Right$(s, 1) = " "): s = Left$(s, Len(s) - 1): Loop
    If Len(s) = 0 Then s = "unnamed"
    Dim reserved As Variant: reserved = Array("CON", "PRN", "AUX", "NUL", "COM1", "COM2", "COM3", "COM4", "COM5", "COM6", "COM7", "COM8", "COM9", "LPT1", "LPT2", "LPT3", "LPT4", "LPT5", "LPT6", "LPT7", "LPT8", "LPT9")
    Dim upper As String: upper = UCase$(s)
    Dim r As Long
    For r = LBound(reserved) To UBound(reserved)
        If upper = reserved(r) Or upper Like reserved(r) & ".*" Then s = "_" & s: Exit For
    Next r
    SanitizeName = s
End Function

Private Function OptimizeNameForBase(ByVal basePath As String, ByVal nameOnly As String, ByRef cfg As UCX_Config) As String
    Dim budget As Long
    If cfg.EnableLongPaths Then
        budget = 32000
    Else
        budget = cfg.MaxPathLength
    End If
    Dim allow As Long: allow = budget - Len(basePath) - 1
    If allow < 1 Then allow = 1
    If Len(nameOnly) > allow Then
        OptimizeNameForBase = Left$(nameOnly, allow)
    Else
        OptimizeNameForBase = nameOnly
    End If
End Function

Private Function ShortKey(ByVal hex As String) As String
    If Len(hex) = 0 Then
        ShortKey = "0000000"
    Else
        ShortKey = Left$(hex, 7)
    End If
End Function

Private Function ComputeConvoDirName(ByVal smart As String, ByVal lastUtc As Date, ByVal key As String, ByVal outRoot As String, ByRef cfg As UCX_Config) As String
    Dim nameOnly As String
    nameOnly = SanitizeName(smart) & " [" & ShortKey(SHA256_StringUTF8(key)) & "]"
    ComputeConvoDirName = OptimizeNameForBase(outRoot, nameOnly, cfg)
End Function

Private Function UniqueDestFile(ByVal folder As String, ByVal baseName As String, ByRef cfg As UCX_Config) As String
    Dim budget As Long
    If cfg.EnableLongPaths Then
        budget = 32000
    Else
        budget = cfg.MaxPathLength
    End If
    Dim maxLocal As Long: maxLocal = budget - Len(folder) - 1
    If maxLocal < 1 Then maxLocal = 1
    baseName = Left$(baseName, maxLocal)
    Dim stem As String, ext As String, dot As Long
    dot = InStrRev(baseName, ".")
    Dim dest As String, n As Long
    If dot > 0 Then stem = Left$(baseName, dot - 1): ext = mid$(baseName, dot) Else stem = baseName: ext = ""
    dest = folder & "\" & baseName: n = 1
    Dim maxAttempts As Long: maxAttempts = 10000
    Do While Len(Dir$(dest)) > 0 And n <= maxAttempts
        dest = folder & "\" & stem & "_" & n & ext
        n = n + 1
    Loop
    
    If n > maxAttempts Then
        ' Last resort: use timestamp-based hash
        dest = folder & "\" & stem & "_" & Left$(SHA256_StringUTF8(baseName & CStr(Timer * 10000#)), 12) & ext
        If Len(Dir$(dest)) > 0 Then
            Err.Raise vbObjectError + 999, "UniqueDestFile", "Failed to create unique filename after " & maxAttempts & " attempts for: " & baseName
        End If
    End If
    
    UniqueDestFile = mid$(dest, Len(folder) + 2)
End Function

Private Function GetExtension(ByVal nameOnly As String) As String
    Dim dot As Long: dot = InStrRev(nameOnly, ".")
    If dot > 0 Then GetExtension = mid$(nameOnly, dot) Else GetExtension = ""
End Function

'---------------------- Leaves selection ---------------------------------------

Private Function ComputeLeaves(ByVal msgs As Collection) As Collection
    Dim refs As Object: Set refs = CreateObject("Scripting.Dictionary")
    Dim i As Long, m As Object, j As Long, arr As Variant
    For i = 1 To msgs.count
        Set m = msgs(i)
        arr = m("References")
        If IsArray(arr) Then
            For j = LBound(arr) To UBound(arr)
                If Len(arr(j)) > 0 Then refs(LCase$(arr(j))) = True
            Next j
        End If
        If Len(NzStr(m("InReplyTo"))) > 0 Then refs(LCase$(m("InReplyTo"))) = True
    Next i
    Dim out As New Collection
    For i = 1 To msgs.count
        Set m = msgs(i)
        Dim mid As String: mid = LCase$(NzStr(m("MessageId")))
        If Len(mid) = 0 Or Not refs.Exists(mid) Then out.Add m
    Next i
    Set ComputeLeaves = out
End Function

'---------------------- Existing manifest scan ---------------------------------

Private Sub ScanExistingPacks(ByVal outRoot As String, ByRef existing As Object)
    On Error Resume Next
    Dim fso As Object: Set fso = CreateObject("Scripting.FileSystemObject")
    If Not fso.FolderExists(outRoot) Then Exit Sub
    Dim folder As Object: Set folder = fso.GetFolder(outRoot)
    Dim subf As Object
    For Each subf In folder.SubFolders
        Dim m As String: m = subf.path & "\manifest.json"
        If fso.FileExists(m) Then
            Dim txt As String: txt = ReadAllText(m)
            Dim key As String: key = JsonFindString(txt, "conversation_key")
            If Len(key) > 0 Then
                Dim lastUtc As String: lastUtc = JsonFindString(txt, "last_message_utc")
                Dim rec As Object: Set rec = CreateObject("Scripting.Dictionary")
                rec("Path") = subf.path
                If Len(lastUtc) > 0 Then rec("LastUtc") = SafeParseDate(lastUtc) Else rec("LastUtc") = 0
                existing(key) = rec
            End If
        End If
    Next subf
End Sub

Private Sub SeedAttachmentMapFromManifest(ByVal convDir As String, ByRef shaToName As Object)
    On Error Resume Next
    Dim m As String: m = convDir & "\manifest.json"
    If Len(Dir$(m)) = 0 Then Exit Sub
    Dim txt As String: txt = ReadAllText(m)
    Dim re As Object: Set re = CreateObject("VBScript.RegExp")
    re.Global = True: re.IgnoreCase = True
    re.pattern = """filename""\s*:\s*""([^""]+)""\s*,\s*""extension""[\s\S]*?""sha256""\s*:\s*""([0-9a-f]{64})"""
    Dim mc As Object: Set mc = re.Execute(txt)
    Dim i As Long
    For i = 0 To mc.count - 1
        shaToName(mc(i).SubMatches(1)) = mc(i).SubMatches(0)
    Next i
End Sub

'------------------------ State file (_state.json) -----------------------------

Private Function ReadStateLastUTC(ByVal outRoot As String) As Date
    On Error Resume Next
    Dim p As String: p = outRoot & "\" & STATE_FILE
    If Len(Dir$(p)) = 0 Then Exit Function
    Dim txt As String: txt = ReadAllText(p)

    If Len(txt) < 10 Or InStr(1, txt, "LastSyncUTC", vbTextCompare) = 0 Then
        Warn "State file appears corrupted - will perform full export: " & p
        Exit Function
    End If

    Dim s As String: s = JsonFindString(txt, "LastSyncUTC")
    If Len(s) > 0 Then
        Dim d As Date: d = SafeParseDate(s)
        If d = 0 Then
            Warn "Invalid date in state file - will perform full export"
        Else
            ReadStateLastUTC = d
        End If
    End If
End Function

Private Sub WriteState(ByVal outRoot As String, ByVal lastUtc As Date, ByVal folders As Variant)
    On Error Resume Next
    Dim d As Object: Set d = CreateObject("Scripting.Dictionary")
    d("LastSyncUTC") = Format$(lastUtc, "yyyy-mm-dd\Thh:nn:ss\Z")
    d("Folders") = folders
    WriteTextFile outRoot & "\" & STATE_FILE, JsonSerializeDict(d), False
End Sub

'------------------------ JSON helpers (lightweight) ---------------------------

Private Function JsonEscape(ByVal s As String) As String
    s = Replace(s, "\", "\\")
    s = Replace(s, """", "\""")
    s = Replace(s, vbTab, "\t")
    s = Replace(s, vbCr, "\r")
    s = Replace(s, vbLf, "\n")
    s = Replace(s, Chr$(12), "\f") ' form feed
    s = Replace(s, Chr$(8), "\b")  ' backspace
    JsonEscape = s
End Function

Private Function JsonSerializeDict(ByVal d As Object) As String
    Dim sb As String: sb = "{"
    Dim k As Variant, first As Boolean: first = True
    For Each k In d.keys
        If Not first Then sb = sb & "," Else first = False
        sb = sb & """" & JsonEscape(CStr(k)) & """:"
        sb = sb & JsonValue(d(k))
    Next k
    sb = sb & "}"
    JsonSerializeDict = sb
End Function

Private Function JsonValue(ByVal v As Variant) As String
    If IsNull(v) Then
        JsonValue = "null"
    ElseIf IsObject(v) Then
        Dim t As String: t = TypeName(v)
        If t = "Dictionary" Then
            JsonValue = JsonSerializeDict(v)
        ElseIf t = "Collection" Then
            JsonValue = JsonArrayFromCollection(v)
        Else
            JsonValue = """" & JsonEscape(CStr(v)) & """"
        End If
    ElseIf IsArray(v) Then
        JsonValue = JsonArrayFromVariant(v)
    ElseIf VarType(v) = vbBoolean Then
        If v Then
            JsonValue = "true"
        Else
            JsonValue = "false"
        End If
    ElseIf IsDate(v) Then
        JsonValue = """" & Format$(CDate(v), "yyyy-mm-dd\Thh:nn:ss\Z") & """"
    ElseIf IsNumeric(v) Then
        JsonValue = CStr(v)
    Else
        JsonValue = """" & JsonEscape(CStr(v)) & """"
    End If
End Function

Private Function JsonArrayFromCollection(ByVal c As Collection) As String
    Dim i As Long, sb As String: sb = "["
    For i = 1 To c.count
        If i > 1 Then sb = sb & ","
        sb = sb & JsonValue(c(i))
    Next i
    sb = sb & "]"
    JsonArrayFromCollection = sb
End Function

Private Function JsonArrayFromVariant(ByVal arr As Variant) As String
    Dim i As Long, sb As String: sb = "["
    For i = LBound(arr) To UBound(arr)
        If i > LBound(arr) Then sb = sb & ","
        sb = sb & JsonValue(arr(i))
    Next i
    sb = sb & "]"
    JsonArrayFromVariant = sb
End Function

Private Function JsonFindString(ByVal json As String, ByVal key As String) As String
    On Error Resume Next
    Dim re As Object: Set re = CreateObject("VBScript.RegExp")
    re.Global = False: re.IgnoreCase = True
    re.pattern = """" & key & """\s*:\s*""([^""]*)"""
    Dim m As Object: Set m = re.Execute(json)
    If m.count > 0 Then JsonFindString = m(0).SubMatches(0)
End Function

'------------------------ Participants / messages ------------------------------

Private Function UniqueParticipants(ByVal msgs As Collection) As Object
    Dim setE As Object: Set setE = CreateObject("Scripting.Dictionary")
    If msgs Is Nothing Or msgs.count = 0 Then Set UniqueParticipants = New Collection: Exit Function
    Dim i As Long, m As Object, k As Variant
    For i = 1 To msgs.count
        Set m = msgs(i)
        If Not m Is Nothing And m.Exists("From") Then setE(NormalizeEmail(NzStr(m("From")))) = True
        If m.Exists("To") Then
            Dim t As Object: Set t = m("To")
            If Not t Is Nothing Then
                For Each k In t.keys
                    If t(k).Exists("smtp") Then setE(NormalizeEmail(NzStr(t(k)("smtp")))) = True
                Next k
            End If
        End If
        If m.Exists("CC") Then
            Dim c As Object: Set c = m("CC")
            If Not c Is Nothing Then
                For Each k In c.keys
                    If c(k).Exists("smtp") Then setE(NormalizeEmail(NzStr(c(k)("smtp")))) = True
                Next k
            End If
        End If
    Next i
    Dim out As Object: Set out = New Collection
    For Each k In setE.keys
        Dim p As Object: Set p = CreateObject("Scripting.Dictionary")
        p("given_name") = Null: p("surname") = Null: p("smtp") = k: p("job_title") = Null
        out.Add p
    Next k
    Set UniqueParticipants = out
End Function

Private Function MessagesArray(ByVal msgs As Collection, ByVal includeBodies As Boolean) As Object
    Dim out As New Collection, i As Long, m As Object, d As Object
    For i = 1 To msgs.count
        Set m = msgs(i)
        Set d = CreateObject("Scripting.Dictionary")
        If Len(NzStr(m("MessageId"))) > 0 Then
            d("id") = m("MessageId")
        Else
            d("id") = SHA256_StringUTF8(NzStr(m("Subject")) & "|" & Format$(NzDate(m("SortUtc")), "yyyy-mm-dd\Thh:nn:ss\Z"))
        End If
        Dim fromObj As Object: Set fromObj = CreateObject("Scripting.Dictionary")
        fromObj("name") = "": fromObj("smtp") = NormalizeEmail(NzStr(m("From")))
        d("from") = fromObj
        d("to") = DictValues(m("To"))
        d("cc") = DictValues(m("CC"))
        Dim msgSortUtc As Date: msgSortUtc = NzDate(m("SortUtc"))
        If msgSortUtc <> 0 Then d("date") = Format$(msgSortUtc, "yyyy-mm-dd\Thh:nn:ss\Z") Else d("date") = Null
        d("subject") = NzStr(m("Subject"))
        If includeBodies Then
            Dim txt As String: txt = NzStr(SafeGetBody(m("EntryID"), m("StoreID")))
            d("text") = txt
        Else
            d("text") = ""
        End If
        out.Add d
    Next i
    Set MessagesArray = out
End Function

Private Function CollectMessageIds(ByVal msgs As Collection) As Variant
    Dim out As New Collection, i As Long
    For i = 1 To msgs.count: out.Add NzStr(msgs(i)("MessageId")): Next i
    CollectMessageIds = CollectionToArray(out)
End Function

' ---- Safer body extraction with HTML fallback ----
Private Function SafeGetBody(ByVal entryId As String, ByVal storeId As String) As String
    On Error GoTo EH
    Dim mi As Object
    Set mi = GetItemWithRetry(entryId, storeId, 3)
    If Not mi Is Nothing Then
        If mi.DownloadState = OL_DOWNLOADSTATE_COMPLETE Then
            SafeGetBody = NzStr(mi.Body)
            If Len(SafeGetBody) = 0 Then
                Dim html As String
                On Error Resume Next
                html = mi.htmlBody
                On Error GoTo EH
                If Len(html) > 0 Then SafeGetBody = HtmlToText(html)
            End If
        End If
    End If
    Set mi = Nothing
    Exit Function
EH:
    SafeGetBody = ""
End Function

Private Function HtmlToText(ByVal html As String) As String
    On Error Resume Next
    Dim re As Object: Set re = CreateObject("VBScript.RegExp")
    re.Global = True: re.IgnoreCase = True
    re.pattern = "<script[\s\S]*?</script>|<style[\s\S]*?</style>"
    html = re.Replace(html, "")
    re.pattern = "<[^>]+>"
    html = re.Replace(html, "")
    HtmlToText = Trim$(NormalizeWhitespace(html))
End Function

Private Function GetItemWithRetry(ByVal entryId As String, ByVal storeId As String, ByVal maxRetries As Long) As Object
    Dim attempt As Long, it As Object
    If Application.Session Is Nothing Then
        Warn "GetItemWithRetry: Application.Session is Nothing"
        Set GetItemWithRetry = Nothing
        Exit Function
    End If
    For attempt = 1 To maxRetries
        On Error Resume Next
        Set it = Application.Session.GetItemFromID(entryId, storeId)
        If Not it Is Nothing Then Set GetItemWithRetry = it: Exit Function
        If Err.Number <> 0 Then
            If attempt < maxRetries Then
                Dim startTime As Single: startTime = Timer
                Do While Timer < startTime + (0.1 * (2 ^ (attempt - 1))): DoEvents: Loop
            End If
            Err.Clear
        End If
        On Error GoTo 0
    Next attempt
    Warn "GetItemWithRetry failed after " & maxRetries & " attempts for EntryID: " & Left$(entryId, 50)
    Set GetItemWithRetry = Nothing
End Function

'------------------------ Text / Files -----------------------------------------

Private Sub WriteTextFile(ByVal path As String, ByVal text As String, ByVal noBom As Boolean)
    On Error GoTo EH
    Dim tempPath As String: tempPath = path & ".tmp_" & CreateRandomName()  ' atomic write

    Dim s As Object: Set s = Nothing
    If noBom Then
        Dim b() As Byte: b = Utf8Bytes(text, True)
        WriteBinary tempPath, b
    Else
        Set s = CreateObject("ADODB.Stream")
        s.Type = 2: s.Charset = "utf-8"
        s.Open
        s.WriteText text
        s.SaveToFile tempPath, 2
        s.Close
        Set s = Nothing
    End If

    If Len(Dir$(path)) > 0 Then Kill path
    Name tempPath As path
    Exit Sub
EH:
    On Error Resume Next
    If Not s Is Nothing Then
        s.Close
        Set s = Nothing
    End If
    KillSafe tempPath
    Err.Raise Err.Number, "WriteTextFile", Err.Description
End Sub

Private Function ReadAllText(ByVal path As String) As String
    On Error GoTo EH
    Dim s As Object: Set s = CreateObject("ADODB.Stream")
    s.Type = 2: s.Charset = "utf-8"
    s.Open
    s.LoadFromFile path
    ReadAllText = s.ReadText
    s.Close
    Exit Function
EH:
    On Error Resume Next
    If Not s Is Nothing Then s.Close
    ReadAllText = ""
End Function

Private Sub WriteBinary(ByVal path As String, ByRef bytes() As Byte)
    On Error GoTo EH
    Dim s As Object: Set s = CreateObject("ADODB.Stream")
    s.Type = 1: s.Open
    s.Write bytes
    s.SaveToFile path, 2
    s.Close
    Exit Sub
EH:
    On Error Resume Next
    If Not s Is Nothing Then s.Close
    Err.Raise Err.Number, "WriteBinary", Err.Description
End Sub

Private Sub KillSafe(ByVal path As String)
    On Error Resume Next
    If Len(Dir$(path)) > 0 Then Kill path
End Sub

'------------------------ SHA-256 (32/64-bit) ----------------------------------

Private Function SHA256_StringUTF8(ByVal s As String) As String
    Dim bytes() As Byte: bytes = Utf8Bytes(s, True)
    SHA256_StringUTF8 = SHA256_Bytes(bytes)
End Function

Private Function SHA256_File(ByVal path As String) As String
#If VBA7 Then
    Dim hProv As LongPtr, hHash As LongPtr
#Else
    Dim hProv As Long, hHash As Long
#End If
    Dim st As Object: Set st = Nothing
    Dim contextAcquired As Boolean: contextAcquired = False
    Dim hashCreated As Boolean: hashCreated = False
    On Error GoTo EH

    If CryptAcquireContext(hProv, vbNullString, vbNullString, PROV_RSA_AES, CRYPT_VERIFYCONTEXT) = 0 Then
        Err.Raise 5, , "CryptAcquireContext failed"
    End If
    contextAcquired = True
    
    If CryptCreateHash(hProv, CALG_SHA_256, 0, 0, hHash) = 0 Then
        Err.Raise 5, , "CryptCreateHash failed"
    End If
    hashCreated = True

    Set st = CreateObject("ADODB.Stream")
    st.Type = 1: st.Open
    st.LoadFromFile path

    Do While st.Position < st.size
        Dim chunkVar As Variant: chunkVar = st.Read(65536)
        If IsEmpty(chunkVar) Then Exit Do
        Dim buf() As Byte: buf = chunkVar
        Dim cb As Long: cb = UBound(buf) - LBound(buf) + 1
        If cb > 0 Then
            If CryptHashData(hHash, buf(LBound(buf)), cb, 0) = 0 Then Err.Raise 5, , "CryptHashData failed"
        End If
    Loop

    st.Close
    Set st = Nothing
    SHA256_File = ReadHashHexPtr(hHash)
    CryptDestroyHash hHash
    CryptReleaseContext hProv
    Exit Function
EH:
    On Error Resume Next
    If Not st Is Nothing Then
        st.Close
        Set st = Nothing
    End If
    If hashCreated Then CryptDestroyHash hHash
    If contextAcquired Then CryptReleaseContext hProv
    SHA256_File = ""
End Function

Private Function SHA256_Bytes(ByRef bytes() As Byte) As String
#If VBA7 Then
    Dim hProv As LongPtr, hHash As LongPtr
#Else
    Dim hProv As Long, hHash As Long
#End If
    Dim contextAcquired As Boolean: contextAcquired = False
    Dim hashCreated As Boolean: hashCreated = False
    On Error GoTo EH

    If CryptAcquireContext(hProv, vbNullString, vbNullString, PROV_RSA_AES, CRYPT_VERIFYCONTEXT) = 0 Then
        Err.Raise 5, , "CryptAcquireContext failed"
    End If
    contextAcquired = True
    
    If CryptCreateHash(hProv, CALG_SHA_256, 0, 0, hHash) = 0 Then
        Err.Raise 5, , "CryptCreateHash failed"
    End If
    hashCreated = True
    
    If (UBound(bytes) - LBound(bytes) + 1) > 0 Then
        If CryptHashData(hHash, bytes(LBound(bytes)), UBound(bytes) - LBound(bytes) + 1, 0) = 0 Then
            Err.Raise 5, , "CryptHashData failed"
        End If
    End If
    SHA256_Bytes = ReadHashHexPtr(hHash)
    CryptDestroyHash hHash
    CryptReleaseContext hProv
    Exit Function
EH:
    On Error Resume Next
    If hashCreated Then CryptDestroyHash hHash
    If contextAcquired Then CryptReleaseContext hProv
    SHA256_Bytes = ""
End Function

#If VBA7 Then
Private Function ReadHashHexPtr(ByVal hHash As LongPtr) As String
#Else
Private Function ReadHashHexPtr(ByVal hHash As Long) As String
#End If
    Dim cb As Long
    If CryptGetHashParam(hHash, HP_HASHSIZE, ByVal 0&, cb, 0) = 0 Then Exit Function
    Dim hb() As Byte: ReDim hb(0 To cb - 1)
    If CryptGetHashParam(hHash, HP_HASHVAL, hb(0), cb, 0) = 0 Then Exit Function
    Dim i As Long, s As String
    For i = 0 To cb - 1
        s = s & LCase$(Right$("0" & hex$(hb(i)), 2))
    Next i
    ReadHashHexPtr = s
End Function

Private Function Utf8Bytes(ByVal s As String, Optional ByVal noBom As Boolean = True) As Byte()
    On Error GoTo EH
    Dim t As Object: Set t = CreateObject("ADODB.Stream")
    t.Type = 2: t.Charset = "utf-8": t.Open
    t.WriteText s
    t.Position = 0: t.Type = 1
    Dim arr As Variant: arr = t.Read
    t.Close
    Dim b() As Byte: b = arr
    If noBom Then
        If UBound(b) >= 2 Then
            If b(0) = &HEF And b(1) = &HBB And b(2) = &HBF Then
                Dim out() As Byte: ReDim out(0 To UBound(b) - 3)
                Dim i As Long
                For i = 3 To UBound(b): out(i - 3) = b(i): Next i
                Utf8Bytes = out: Exit Function
            End If
        End If
    End If
    Utf8Bytes = b
    Exit Function
EH:
    On Error Resume Next
    If Not t Is Nothing Then t.Close
    Utf8Bytes = Array()
End Function

Private Function Base64OfBytes(ByRef bytes As Variant) As String
    On Error GoTo Fallback
    Dim dom As Object: Set dom = CreateObject("MSXML2.DOMDocument.6.0")
    Dim el As Object: Set el = dom.createElement("b64")
    el.DataType = "bin.base64"
    el.nodeTypedValue = bytes
    Base64OfBytes = Replace(el.text, vbLf, "")
    Exit Function
Fallback:
    On Error GoTo EH
    Dim dom2 As Object: Set dom2 = CreateObject("MSXML2.DOMDocument")
    Dim el2 As Object: Set el2 = dom2.createElement("b64")
    el2.DataType = "bin.base64"
    el2.nodeTypedValue = bytes
    Base64OfBytes = Replace(el2.text, vbLf, "")
    Exit Function
EH:
    Warn "Base64 encoding failed, using hex fallback"
    Base64OfBytes = BytesToHex(bytes)
End Function

Private Function BytesToHex(ByRef bytes As Variant) As String
    On Error Resume Next
    Dim b() As Byte: b = bytes
    Dim s As String, i As Long
    For i = LBound(b) To UBound(b)
        s = s & LCase$(Right$("0" & hex$(b(i)), 2))
        If i > 99 Then Exit For
    Next i
    BytesToHex = s
End Function

'--------------------- Sorting / collections -----------------------------------

Private Function SortedCopyByKey(ByVal c As Collection, ByVal key As String, ByVal asc As Boolean) As Collection
    If c Is Nothing Then Set SortedCopyByKey = New Collection: Exit Function
    Dim n As Long: n = c.count
    If n = 0 Then Set SortedCopyByKey = New Collection: Exit Function
    If n = 1 Then Set SortedCopyByKey = c: Exit Function
    Dim arr() As Variant: ReDim arr(1 To n)
    Dim i As Long
    For i = 1 To n: Set arr(i) = c(i): Next i
    QuickSortObjByKey arr, 1, n, key, asc
    Dim out As New Collection
    For i = 1 To n: out.Add arr(i): Next i
    Set SortedCopyByKey = out
End Function

Private Sub QuickSortObjByKey(ByRef a() As Variant, ByVal lo As Long, ByVal hi As Long, ByVal key As String, ByVal asc As Boolean)
    Static depth As Long
    Const MAX_DEPTH As Long = 50
    If depth > MAX_DEPTH Then Warn "QuickSort depth limit reached, using fallback": Exit Sub
    depth = depth + 1
    On Error GoTo CleanUp

    Dim i As Long, j As Long
    i = lo: j = hi
    Dim pivot As Variant: Set pivot = a((lo + hi) \ 2)
    Do While i <= j
        If asc Then
            Do While a(i)(key) < pivot(key): i = i + 1: Loop
            Do While a(j)(key) > pivot(key): j = j - 1: Loop
        Else
            Do While a(i)(key) > pivot(key): i = i + 1: Loop
            Do While a(j)(key) < pivot(key): j = j - 1: Loop
        End If
        If i <= j Then
            Dim tmp As Variant: Set tmp = a(i): Set a(i) = a(j): Set a(j) = tmp
            i = i + 1: j = j - 1
        End If
    Loop
    If lo < j Then QuickSortObjByKey a, lo, j, key, asc
    If i < hi Then QuickSortObjByKey a, i, hi, key, asc

CleanUp:
    depth = depth - 1
End Sub

Private Function JoinCollection(ByVal c As Collection, ByVal sep As String) As String
    If c Is Nothing Or c.count = 0 Then JoinCollection = "": Exit Function
    Dim i As Long, sb As String
    For i = 1 To c.count
        If i > 1 Then sb = sb & sep
        sb = sb & CStr(c(i))
    Next i
    JoinCollection = sb
End Function

Private Function CollectionToArray(ByVal c As Collection) As Variant
    If c Is Nothing Or c.count = 0 Then CollectionToArray = Array(): Exit Function
    Dim arr() As Variant: ReDim arr(0 To c.count - 1)
    Dim i As Long
    For i = 1 To c.count: arr(i - 1) = c(i): Next i
    CollectionToArray = arr
End Function

Private Function DictValues(ByVal d As Object) As Object
    Dim out As New Collection
    If Not d Is Nothing Then
        Dim k As Variant
        For Each k In d.keys: out.Add d(k): Next k
    End If
    Set DictValues = out
End Function

Private Function JoinEmails(ByVal recipients As Object) As String
    Dim k As Variant, out As New Collection
    If Not recipients Is Nothing Then
        For Each k In recipients.keys
            If recipients(k).Exists("smtp") Then out.Add recipients(k)("smtp")
        Next k
    End If
    JoinEmails = JoinCollection(out, "; ")
End Function

Private Function JoinEmailsNormalized(ByVal recipients As Object) As String
    Dim k As Variant, out As New Collection
    If Not recipients Is Nothing Then
        For Each k In recipients.keys
            If recipients(k).Exists("smtp") Then out.Add NormalizeEmail(NzStr(recipients(k)("smtp")))
        Next k
    End If
    JoinEmailsNormalized = JoinCollection(out, "; ")
End Function

Private Function CountRecipients(ByVal recipients As Object) As Long
    If recipients Is Nothing Then
        CountRecipients = 0
    Else
        CountRecipients = recipients.count
    End If
End Function

Private Function RecipsToLower(ByVal recipients As Object) As Variant
    Dim out As New Collection, k As Variant
    If Not recipients Is Nothing Then
        For Each k In recipients.keys
            If recipients(k).Exists("smtp") Then out.Add NormalizeEmail(NzStr(recipients(k)("smtp")))
        Next k
    End If
    RecipsToLower = CollectionToArray(out)
End Function

Private Function ReplaceMultiple(ByVal s As String, ByVal targets As Variant, ByVal repl As String) As String
    Dim i As Long
    For i = LBound(targets) To UBound(targets)
        Do While InStr(1, s, CStr(targets(i)), vbBinaryCompare) > 0
            s = Replace(s, CStr(targets(i)), repl, 1, 1, vbBinaryCompare)
        Loop
    Next i
    ReplaceMultiple = s
End Function

Private Function CreateRandomName() As String
    Randomize
    CreateRandomName = Replace(CStr(Timer * 1000#), ".", "") & "_" & CStr(Int(Rnd() * 1000000#))
End Function

Private Function SafeStr(ByVal obj As Object, ByVal prop As String) As String
    On Error Resume Next
    Dim v As Variant: v = CallByName(obj, prop, VbGet)
    If Err.Number <> 0 Then
        Err.Clear
        SafeStr = ""
    Else
        SafeStr = CStr(v)
    End If
End Function

Private Function SafeFolderPath(ByVal f As Object) As String
    On Error Resume Next
    SafeFolderPath = NzStr(f.FolderPath)
    If Err.Number <> 0 Then SafeFolderPath = "(unknown)": Err.Clear
End Function

Private Function SafeParentStoreID(ByVal mi As Object) As String
    On Error Resume Next
    Dim p As Object: Set p = mi.parent
    If Not p Is Nothing Then
        Dim sid As String: sid = NzStr(p.storeId)
        If Len(sid) > 0 Then SafeParentStoreID = sid: Exit Function
    End If
    SafeParentStoreID = ""
End Function

Private Sub Info(ByVal s As String)
    If Len(CFG_LogPath) > 0 Then AppendLog s
    Debug.Print s
End Sub

Private Sub Warn(ByVal s As String)
    If Len(CFG_LogPath) > 0 Then AppendLog ("WARN: " & s)
    Debug.Print "WARN: " & s
End Sub

Private Sub AppendLog(ByVal s As String)
    On Error Resume Next
    Dim f As Integer: f = FreeFile
    Open CFG_LogPath For Append As #f
    Print #f, Format$(Now, "yyyy-mm-dd hh:nn:ss") & " - " & s
    Close #f
End Sub

'---------------------- Export locking -----------------------------------------

Private Function AcquireExportLock(ByVal lockFile As String) As Boolean
    On Error Resume Next
    If Len(Dir$(lockFile)) > 0 Then
        Dim fso As Object: Set fso = CreateObject("Scripting.FileSystemObject")
        Dim f As Object: Set f = fso.GetFile(lockFile)
        If Not f Is Nothing Then
            If DateDiff("h", f.DateLastModified, Now) > 2 Then
                Warn "Removing stale lock file (older than 2 hours): " & lockFile
                Kill lockFile
            Else
                AcquireExportLock = False: Exit Function
            End If
        End If
    End If
    Dim fileNum As Integer: fileNum = FreeFile
    Open lockFile For Output As #fileNum
    Print #fileNum, "Export started: " & Format$(Now, "yyyy-mm-dd hh:nn:ss")
    Print #fileNum, "PID: " & Environ$("USERNAME") & "@" & Environ$("COMPUTERNAME")
    Close #fileNum
    AcquireExportLock = True
End Function

Private Sub ReleaseExportLock(ByVal lockFile As String)
    On Error Resume Next
    If Len(Dir$(lockFile)) > 0 Then Kill lockFile
End Sub

'---------------------- Disk space check ---------------------------------------

Private Function CheckDiskSpace(ByVal path As String, ByVal requiredBytes As Long) As Boolean
    On Error Resume Next
    Dim fso As Object: Set fso = CreateObject("Scripting.FileSystemObject")

    Dim drv As Object
    If Left$(path, 2) = "\\" Then
        ' UNC: try via folder's drive object (may still be unavailable)
        Dim fld As Object: Set fld = fso.GetFolder(path)
        If Not fld Is Nothing Then Set drv = fld.drive
    Else
        Set drv = fso.GetDrive(fso.GetDriveName(path))
    End If

    If Not drv Is Nothing Then
        If drv.AvailableSpace > requiredBytes Then
            CheckDiskSpace = True
        Else
            Warn "Insufficient disk space. Required: " & Format$(requiredBytes / 1048576, "0.0") & " MB, Available: " & Format$(drv.AvailableSpace / 1048576, "0.0") & " MB"
        End If
    Else
        Warn "Unable to check disk space for: " & path
        Err.Raise vbObjectError + 103, "CheckDiskSpace", "Cannot determine disk space for: " & path
    End If
End Function

'---------------------- Orphaned temp file cleanup -----------------------------

Private Sub CleanupOrphanedTempFiles(ByVal outRoot As String)
    On Error Resume Next
    Dim fso As Object: Set fso = CreateObject("Scripting.FileSystemObject")
    If Not fso.FolderExists(outRoot) Then Exit Sub

    Dim folder As Object: Set folder = fso.GetFolder(outRoot)
    Dim subf As Object, f As Object
    Dim cleanCount As Long: cleanCount = 0

    For Each f In folder.Files
        If f.name Like "_tmp_*" Or f.name Like "*.tmp_*" Then
            If DateDiff("h", f.DateLastModified, Now) > 1 Then
                fso.DeleteFile f.path, True: cleanCount = cleanCount + 1
            End If
        End If
    Next f

    For Each subf In folder.SubFolders
        Dim attFolder As Object
        If fso.FolderExists(subf.path & "\attachments") Then
            Set attFolder = fso.GetFolder(subf.path & "\attachments")
            For Each f In attFolder.Files
                If f.name Like "_tmp_*" Then
                    If DateDiff("h", f.DateLastModified, Now) > 1 Then
                        fso.DeleteFile f.path, True: cleanCount = cleanCount + 1
                    End If
                End If
            Next f
        End If
    Next subf

    If cleanCount > 0 Then Info "Cleaned up " & cleanCount & " orphaned temporary files"
End Sub

'---------------------- Manifest validation ------------------------------------

Private Function ValidateManifest(ByVal manifest As Object, ByVal attDir As String) As Boolean
    On Error Resume Next
    ValidateManifest = True

    If Not manifest.Exists("conversation_key") Or Len(NzStr(manifest("conversation_key"))) = 0 Then
        Warn "Manifest missing conversation_key": ValidateManifest = False
    End If

    If Not manifest.Exists("messages_count") Or Not IsNumeric(manifest("messages_count")) Then
        Warn "Manifest missing or invalid messages_count": ValidateManifest = False
    End If

    If manifest.Exists("attachments") And manifest("has_attachment") = True Then
        Dim attList As Object: Set attList = manifest("attachments")
        If TypeName(attList) = "Collection" Then
            Dim fso As Object: Set fso = CreateObject("Scripting.FileSystemObject")
            Dim i As Long
            For i = 1 To attList.count
                If TypeName(attList(i)) = "Dictionary" Then
                    Dim attItem As Object: Set attItem = attList(i)
                    If attItem.Exists("filename") Then
                        Dim attPath As String: attPath = attDir & "\" & attItem("filename")
                        If Not fso.FileExists(attPath) Then
                            Warn "Manifest references missing attachment file: " & attItem("filename")
                            ValidateManifest = False
                        Else
                            If attItem.Exists("sha256") And Not IsNull(attItem("sha256")) Then
                                Dim actualSha As String: actualSha = SHA256_File(attPath)
                                If Len(actualSha) > 0 And LCase$(actualSha) <> LCase$(CStr(attItem("sha256"))) Then
                                    Warn "Attachment SHA256 mismatch for: " & attItem("filename")
                                    ValidateManifest = False
                                End If
                            End If
                        End If
                    End If
                End If
            Next i
        End If
    End If

    If manifest.Exists("messages") Then
        Dim msgs As Object: Set msgs = manifest("messages")
        If TypeName(msgs) = "Collection" Then
            If manifest("messages_count") <> msgs.count Then
                Warn "Manifest messages_count (" & manifest("messages_count") & ") doesn't match messages array size (" & msgs.count & ")"
                ValidateManifest = False
            End If
        End If
    End If
End Function


