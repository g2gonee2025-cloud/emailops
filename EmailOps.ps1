
<#
EmailOps.ps1 - Production Version
==================================

Unified conversation exporter with best-in-class features:
- Fast Outlook/MAPI scan with delta state (_state.json)
- Robust conversation keys: ConversationID -> ThreadIndexRoot -> References/In-Reply-To -> SmartSubject+participants
- SHA-256 attachment dedupe, inline-skip, nested .msg recursion (depth-limited)
- Raw + cleaned Conversation text, optional chunks.jsonl
- Policy filters: include/exclude paths, sender/domain allow/deny, subject/body regex, marketing/auto-generated skip
- Long-path aware, collision-safe naming, human-friendly folder names
- Single superset manifest schema (compatible with both prior tools)
- Log rotation to prevent unbounded growth
- Trap error handler for clean COM cleanup

Requires: Windows + Outlook desktop (COM). PowerShell 5.1 or 7+.

USAGE (examples):
  # Pick folders interactively (delta since last run), default output under Desktop\Outlook
  pwsh -File .\EmailOps.ps1 -PickFolders

  # Full export to a specific directory
  pwsh -File .\EmailOps.ps1 -OutputRoot C:\Exports\Outlook -PickFolders -Full

  # Restrict to folders and apply filters, produce chunks
  pwsh -File .\EmailOps.ps1 `
       -OutputRoot C:\Exports\Outlook -Folders "\\Mailbox - Me\Inbox","\\Mailbox - Me\Sent Items" `
       -AllowSenders me@company.com -ExcludeMarketing -EmitChunks

Compatibility:
  -Alias -Output -> -OutputRoot
  -Alias -Pick / -PickFromOutlook -> -PickFolders
  -Alias -NoAttachments -> -IncludeAttachments:$false
  -Switch -MetadataOnly -> -IncludeBodies:$false
#>

[CmdletBinding(PositionalBinding=$false)]
param(
  # Source mode (future: support Files mode for .eml/.msg processing)
  [ValidateSet('Outlook','Files')]
  [string]$Source = 'Outlook',

  # IO / selection
  [Alias('Output','OutRoot')][string]$OutputRoot = (Join-Path ([Environment]::GetFolderPath('Desktop')) 'Outlook'),
  [object[]]$Folders,
  [Alias('Pick','PickFromOutlook')][switch]$PickFolders,
  [switch]$IncludeSubfolders,
  [switch]$Full,
  [string]$Since = "auto", # "auto" means use _state.json if present
  [switch]$NoState,
  [switch]$SaveState,       # default behavior is set below if not specified
  [bool]$OfflineStrict = $true,

  # Processing options
  [bool]$IncludeAttachments = $true,
  [Alias('NoAttachments')][switch]$NoAttachmentsSwitch, # maps to IncludeAttachments:$false when set
  [bool]$IncludeBodies = $true,
  [switch]$MetadataOnly,  # flips IncludeBodies to false
  [bool]$IncludeNestedAttachments = $true,
  [ValidateRange(0,20)][int]$NestedDepth = 3,
  [bool]$LeavesOnly = $true,

  # Long path / naming
  [bool]$EnableLongPaths = $true,
  [ValidateRange(100, 200)] [int]$MaxPathLength = 180,

  # Filters
  [string[]]$IncludePathPattern,
  [string[]]$ExcludePathPattern,
  [string[]]$AllowSenders,
  [string[]]$RejectSenders,
  [string[]]$AllowDomains,
  [string[]]$RejectDomains,
  [string[]]$RejectSubjectRegex,
  [string[]]$RejectBodyRegex,
  [bool]$ExcludeMarketing = $true,
  [bool]$ExcludeAutoGenerated = $true,

  # Bodies / cleaning
  [bool]$CleanBodies = $true,
  [ValidateRange(1,1000000)][int]$MinBodyChars = 20,
  [bool]$EmitChunks = $false,
  [ValidateRange(100,1000000)][int]$ChunkSizeChars = 3600,
  [ValidateRange(0,500000)][int]$ChunkOverlapChars = 400,
  [switch]$NoBomEncoding,
  [int]$InlineLogoMaxKB = 50,
  [bool]$SkipInlineLogos = $true,

  # Misc
  [string]$LogPath
)

begin {
  Set-StrictMode -Version Latest
  $ErrorActionPreference = 'Stop'

  # ---------- Compatibility flips ----------
  if ($PSBoundParameters.ContainsKey('NoAttachmentsSwitch') -or $NoAttachmentsSwitch) { $IncludeAttachments = $false }
  if ($PSBoundParameters.ContainsKey('MetadataOnly') -or $MetadataOnly) { $IncludeBodies = $false }
  if ($PSBoundParameters.ContainsKey('NoState') -or $NoState) { $SaveState = $false }

  # Default SaveState unless explicitly disabled via parameter
  if (-not $PSBoundParameters.ContainsKey('SaveState') -and -not $PSBoundParameters.ContainsKey('NoState')) {
    $SaveState = $true
  }

  # ---------- Globals & constants ----------
  $script:inv = [System.Globalization.CultureInfo]::InvariantCulture
  $script:STATE_FILE = "_state.json"
  $script:LOG_NAME = "emailops.log"

  # ---------- Long path capability ----------
  $script:LongPath = @{ Attempted = $EnableLongPaths; Enabled = $false; Error = $null }
  if ($EnableLongPaths) {
    try {
      $setSwitch = [System.AppContext].GetMethod('SetSwitch', [Type[]]@([string], [bool]))
      if ($setSwitch) {
        [System.AppContext]::SetSwitch('Switch.System.IO.UseLegacyPathHandling', $false)
        $script:LongPath.Enabled = $true
      }
    } catch {
      $script:LongPath.Error = $_.Exception.Message
    }
  }
  $script:MAX_PATH_SAFE     = 240
  $script:MAX_PATH_ABSOLUTE = 260

  # ---------- MAPI / Outlook constants and property tags ----------
  $script:OL_TO = 1; $script:OL_CC = 2; $script:OL_FORMAT_HTML = 2; $script:OL_FULLITEM = 1
  $script:PR_CONV_ID     = "http://schemas.microsoft.com/mapi/proptag/0x30130102"
  $script:PR_CONV_INDEX  = "http://schemas.microsoft.com/mapi/proptag/0x00710102"
  $script:PR_HDRS_W      = "http://schemas.microsoft.com/mapi/proptag/0x007D001F"
  $script:PR_HDRS_A      = "http://schemas.microsoft.com/mapi/proptag/0x007D001E"
  $script:PR_ATTACH_CIDW = "http://schemas.microsoft.com/mapi/proptag/0x3712001F"
  $script:PR_ATTACH_CIDA = "http://schemas.microsoft.com/mapi/proptag/0x3712001E"
  $script:PR_ATTACH_FLAGS= "http://schemas.microsoft.com/mapi/proptag/0x37140003"
  $script:PR_ATTACH_HIDDEN="http://schemas.microsoft.com/mapi/proptag/0x7FFE000B"
  $script:PR_ATTACH_MIME = "http://schemas.microsoft.com/mapi/proptag/0x370E001F"

  # ---------- Logging & rotation ----------
  $script:LogFile = if ($LogPath) { $LogPath } else { Join-Path $OutputRoot $script:LOG_NAME }

  function Initialize-LogRotation {
    param([int]$MaxFiles = 5, [int64]$MaxBytes = 5MB)
    try {
      $dir = Split-Path -Path $script:LogFile -Parent
      if (-not (Test-Path -LiteralPath $dir)) { New-Item -ItemType Directory -LiteralPath $dir -Force | Out-Null }
      if (Test-Path -LiteralPath $script:LogFile) {
        $len = (Get-Item -LiteralPath $script:LogFile).Length
        if ($len -ge $MaxBytes) {
          $name = [IO.Path]::GetFileNameWithoutExtension($script:LogFile)
          $ext  = [IO.Path]::GetExtension($script:LogFile)
          for ($i = $MaxFiles-1; $i -ge 1; $i--) {
            $old = Join-Path $dir "$name.$i$ext"
            $new = Join-Path $dir "$name.$($i+1)$ext"
            if (Test-Path -LiteralPath $old) { Move-Item -LiteralPath $old -Destination $new -Force }
          }
          $rotated = Join-Path $dir "$name.1$ext"
          Move-Item -LiteralPath $script:LogFile -Destination $rotated -Force
        }
      }
    } catch {
      Write-Warning "Log rotation failed: $_"
    }
  }

  function Log {
    param([string]$m)
    if ($script:LogFile) { Add-Content -LiteralPath $script:LogFile -Value "$(Get-Date -f 'yyyy-MM-dd HH:mm:ss') - $m" }
    Write-Verbose $m
  }

  trap {
    Log "ERROR: Unexpected termination - $_"
    Close-OutlookCom
    continue
  }

  # ---------- Safe naming ----------
  function ConvertTo-SafeName([string]$s){
    if (-not $s) { return 'unnamed' }
    $bad = '<>:"/\|?*'
    foreach($c in $bad.ToCharArray()){ $s = $s -replace [Regex]::Escape($c),'_' }
    $s = $s.Trim()
    while($s.EndsWith('.')){ $s = $s.Substring(0,[Math]::Max(0,$s.Length-1)) }
    while($s.EndsWith(' ')){ $s = $s.Substring(0,[Math]::Max(0,$s.Length-1)) }
    if(-not $s){ $s = 'unnamed' }
    $reserved = @('CON','PRN','AUX','NUL','COM1','COM2','COM3','COM4','COM5','COM6','COM7','COM8','COM9','LPT1','LPT2','LPT3','LPT4','LPT5','LPT6','LPT7','LPT8','LPT9')
    $upper = $s.ToUpperInvariant()
    foreach($r in $reserved){ if($upper -eq $r -or $upper -like ($r + '.*')){ $s = '_' + $s; break } }
    return $s
  }

  function Limit-PathLength([string]$name,[int]$max){ if($name.Length -le $max){$name}else{$name.Substring(0,$max)} }
  function Optimize-NameForBase([string]$base,[string]$name){
    $allow = [Math]::Max(1, $script:MAX_PATH_SAFE - $base.Length - 1)
    Limit-PathLength $name $allow
  }
  function Add-SuffixBeforeExtension([string]$name,[string]$suffix,[int]$max){
    $dot=$name.LastIndexOf('.'); if($dot -gt 0){ $b=$name.Substring(0,$dot); $e=$name.Substring($dot) } else { $b=$name; $e='' }
    if(($b.Length + $suffix.Length + $e.Length) -gt $max){ $b=$b.Substring(0,[Math]::Max(0,$max-$suffix.Length-$e.Length)) }
    "$b$suffix$e"
  }

  function Test-Dir([string]$p){
    if (-not (Test-Path -LiteralPath $p)) { New-Item -ItemType Directory -Path $p -Force | Out-Null }
    return $p
  }

  # ---------- Hashing ----------
  function HashString([string]$s){
    $sha = [System.Security.Cryptography.SHA256]::Create()
    $bytes = [System.Text.Encoding]::UTF8.GetBytes(($s ?? ""))
    ($sha.ComputeHash($bytes) | ForEach-Object { $_.ToString('x2') }) -join ''
  }
  function ShortKey([string]$hex){ if (-not $hex){ return '0000000' } else { $hex.Substring(0,7) } }
  function Sha256File([string]$path){
    $sha = [System.Security.Cryptography.SHA256]::Create()
    $fs = [System.IO.File]::Open($path, [IO.FileMode]::Open, [IO.FileAccess]::Read, [IO.FileShare]::Read)
    try {
      ($sha.ComputeHash($fs) | ForEach-Object { $_.ToString('x2') }) -join ''
    } finally { $fs.Dispose() }
  }

  # ---------- Email normalization ----------
  function NormalizeEmail([string]$s){
    if ([string]::IsNullOrWhiteSpace($s)) { return $null }
    $m = [regex]::Match($s, '<([^>]+)>')
    if ($m.Success) { return $m.Groups[1].Value.Trim().ToLowerInvariant() }
    return $s.Trim().ToLowerInvariant()
  }

  # ---------- State ----------
  function Read-State([string]$root){
    $path = Join-Path $root $script:STATE_FILE
    if (Test-Path -LiteralPath $path) {
      try { return (Get-Content -LiteralPath $path -Raw -Encoding UTF8 | ConvertFrom-Json) } catch { }
    }
    return @{ LastSyncUTC = $null; Folders = @() }
  }
  function Write-State([string]$root,[Nullable[datetime]]$LastSyncUTC,[string[]]$FoldersArr){
    if(-not $SaveState){ return }
    $path = Join-Path $root $script:STATE_FILE
    $stamp = if ($LastSyncUTC) { ([datetime]$LastSyncUTC).ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ssZ',$script:inv) } else { $null }
    $obj = [pscustomobject]@{ LastSyncUTC = $stamp; Folders = @($FoldersArr) }
    $json = $obj | ConvertTo-Json -Depth 4
    $utf8 = New-Object System.Text.UTF8Encoding($true)
    [IO.File]::WriteAllText($path, $json, $utf8)
  }

  # ---------- Cleaning & chunking (with overlap) ----------
  function Normalize-Whitespace([string]$s){
    if (-not $s){ return '' }
    $x = $s -replace "`r","" -replace "[`t ]+"," "
    $x -replace " *`n+","`r`n"
  }
  function Strip-QuotedSections([string]$s){
    if (-not $s){ return '' }
    ($s -split "`r?`n" | Where-Object { ($_ -notmatch '^\s*>') -and ($_ -notmatch '^\s*On .*wrote:$') -and ($_ -notmatch '^From: .*') }) -join "`r`n"
  }
  function Strip-Signature([string]$s){
    if (-not $s){ return '' }
    $lines = $s -split "`r?`n"
    $idx = [Array]::FindLastIndex($lines, [Predicate[string]]{ param($l) $l -match '^--\s*$' })
    if ($idx -gt 0) { return ($lines[0..($idx-1)] -join "`r`n") } else { return $s }
  }
  function Strip-Disclaimers([string]$s) { $s }
  function Clean-BodyForNLP([string]$body){
    $b = Normalize-Whitespace $body
    $b = Strip-QuotedSections $b
    $b = Strip-Signature $b
    $b = Strip-Disclaimers $b
    $b.Trim()
  }
  function Split-IntoChunks([string]$text,[int]$size,[int]$overlap){
    $out=@()
    if (-not $text) { return $out }
    $i=0
    while($i -lt $text.Length){
      $len = [Math]::Min($size, $text.Length - $i)
      $out += $text.Substring($i,$len)
      if ($len -eq 0) { break }
      $i = $i + $size - $overlap
      if ($i -lt 0) { break }
    }
    return $out
  }

  # ---------- Conversation helpers ----------
  $stripPrefixes = @('re: ','fw: ','fwd: ','sv: ','aw: ','wg: ','antw: ')
  function SmartSubject([string]$s){
    if (-not $s) { return '_' }
    try { $s = $s.Normalize([System.Text.NormalizationForm]::FormC) } catch { }
    $t = $s.Trim()
    $changed = $true
    while($changed){
      $changed = $false
      foreach($p in $stripPrefixes){
        if ($t.ToLowerInvariant().StartsWith($p)) {
          $t = $t.Substring($p.Length)
          $changed = $true; break
        }
      }
    }
    if (-not $t) { '_' } else { $t }
  }
  function ThreadIndexRoot([byte[]]$ti){
    if (-not $ti){ return $null }
    $b64 = [Convert]::ToBase64String($ti)
    if ($b64.Length -ge 22){ return $b64.Substring(0,22) } else { return $b64 }
  }

  # ---------- Outlook COM ----------
  $script:Outlook = $null
  $script:Session = $null
  try {
    if ($Source -eq 'Outlook') {
      $script:Outlook = New-Object -ComObject Outlook.Application
      $script:Session = $script:Outlook.Session
    }
  } catch {
    if ($Source -eq 'Outlook') {
      throw "Cannot open Outlook.Application COM: $_"
    }
  }

  function Close-OutlookCom{
    try { if ($script:Session) { [void][Runtime.InteropServices.Marshal]::ReleaseComObject($script:Session) } } catch {}
    try { if ($script:Outlook) { [void][Runtime.InteropServices.Marshal]::ReleaseComObject($script:Outlook) } } catch {}
    $script:Session = $null; $script:Outlook = $null
  }

  function Assert-Offline {
    if(-not $OfflineStrict){ return }
    $isOffline = $false
    try{
      if($script:Session.Offline){ $isOffline = $true } else {
        $mode = $script:Session.ExchangeConnectionMode # 400=olCachedOffline; 500=olDisconnected
        if(($mode -eq 400) -or ($mode -eq 500)){ $isOffline = $true }
      }
    }catch{}
    if(-not $isOffline){
      throw "Outlook is not offline. Switch to 'Work Offline' and run again (or use -OfflineStrict:`$false)."
    }
  }

  function Resolve-Folders([object[]]$Folders,[switch]$PickFolders){
    $list=@()
    if($PickFolders){
      while($true){
        $f = $script:Session.PickFolder()
        if(-not $f){ break }
        $list += $f
        $more = Read-Host "Added: $($f.FolderPath)`nPick another? (y/N)"
        if($more -notin @('y','Y','yes','YES')){ break }
      }
    } elseif(-not $Folders -or $Folders.Count -eq 0) {
      $f = $script:Session.PickFolder()
      if(-not $f){ throw "No folder selected." }
      $list += $f
    } else {
      foreach($spec in $Folders){
        $s = [string]$spec
        $found=$null
        $storeCount = 0
        $maxStores = 50
        foreach($store in $script:Session.Stores){
          $storeCount++
          if($storeCount -gt $maxStores){
            Log "Warning: Stopped after checking $maxStores stores to prevent infinite loop"
            break
          }
          try{
            $displayName = "Unknown"
            try { if($store.DisplayName) { $displayName = $store.DisplayName } } catch { }
            $root=$store.GetRootFolder()
            if($root){
              if ($root.FolderPath -eq $s) { $found=$root; break }
              foreach($sub in $root.Folders){
                if ($sub.FolderPath -eq $s){ $found=$sub; break }
              }
            }
            if($found){ break }
          }catch{
            Log "Warning: Error accessing store: $_"
          }
        }
        if($found){ $list += $found } else { Write-Warning "Folder not found: $s" }
      }
    }
    return $list
  }

  function ConvertTo-OutlookFilterDate([datetime]$utc){
    $local = $utc.ToLocalTime()
    $local.ToString("MM/dd/yyyy HH:mm",$script:inv)
  }

  function Get-TableItems($Folder,[string]$FilterString,[Nullable[datetime]]$FilterFromUtc){
    try {
      $tbl = $Folder.GetTable($FilterString)
      $cols = $tbl.Columns
      $cols.RemoveAll()
      foreach($c in @('EntryID','Subject','ConversationID','ConversationIndex','ConversationTopic','ReceivedTime','SenderEmailAddress','SenderName','SentOn')){ $cols.Add($c) }
      $items=@()
      while(-not $tbl.EndOfTable){
        $row=$tbl.GetNextRow()
        $items += ,$row
      }
      return $items
    } catch { @() }
  }

  function SafeRow($row,[string]$key){ try{ $v=$row[$key]; if($v){ [string]$v } else { "" } }catch{ "" } }
  function SafeRowDate($row,[string]$key){ try{ $v=$row[$key]; if($v){ [datetime]$v } else { $null } }catch{ $null } }

  # ---------- SMTP resolution ----------
  function Get-RecipientSmtp($r){
    try{
      $ae=$r.AddressEntry
      if($ae){
        if($ae.Type -eq 'EX'){
          $ex=$ae.GetExchangeUser(); if($ex){ return $ex.PrimarySmtpAddress }
          $dl=$ae.GetExchangeDistributionList(); if($dl){ return $dl.PrimarySmtpAddress }
        }
        if($ae.Address){ return $ae.Address }
      }
      ''
    }catch{ '' }
  }
  function Get-RecipientsArray($mi,[int]$typ){
    $arr=@()
    try{
      foreach($r in $mi.Recipients){
        if($r.Type -eq $typ){
          $arr += @{name=[string]$r.Name; smtp=(Get-RecipientSmtp $r)}
        }
      }
    }catch{}
    return $arr
  }
  function Get-SenderSmtp($mi){
    try{
      $ae=$mi.Sender
      if($ae){
        if($ae.AddressEntryUserType -eq 0){
          $ex=$ae.GetExchangeUser(); if($ex){ return $ex.PrimarySmtpAddress }
        }
      }
      $mi.SenderEmailAddress
    }catch{ '' }
  }

  # ---------- Header extraction ----------
  function Get-RawHeaders($mi){
    try{
      $pa = $mi.PropertyAccessor
      $h = $pa.GetProperty($script:PR_HDRS_W)
      if (-not $h) { $h = $pa.GetProperty($script:PR_HDRS_A) }
      if ($h) { return [string]$h } else { return $null }
    }catch{ $null }
  }
  function Parse-Headers([string]$raw){
    $map = @{}
    if (-not $raw) { return $map }
    foreach($line in ($raw -split "`r?`n")){
      if ($line -match '^\s') { continue }
      $i = $line.IndexOf(':')
      if ($i -gt 0) {
        $k = $line.Substring(0,$i).Trim()
        $v = $line.Substring($i+1).Trim()
        $map[$k] = $v
      }
    }
    return $map
  }
  function Get-HeaderVal($headers,[string]$k){
    foreach($key in $headers.Keys){ if($key -ieq $k){ return $headers[$key] } }
    return $null
  }

  # ---------- Policy filters (enhanced) ----------
  function MatchesAny([string]$s,[string[]]$patterns){
    if (-not $patterns -or -not $s) { return $false }
    foreach($p in $patterns){ if ($s -like $p) { return $true } }
    return $false
  }
  function AddressMatches([string]$addr,[string[]]$list){
    if (-not $list -or -not $addr) { return $false }
    $n = NormalizeEmail $addr
    foreach($x in $list){
      $y = NormalizeEmail $x
      if ($n -eq $y) { return $true }
      if ($y -like '@*' -and $n.EndsWith($y.Substring(1))) { return $true }
    }
    return $false
  }
  function Is-MarketingMessage($headers){
    $precedence = Get-HeaderVal $headers 'Precedence'
    $listId = Get-HeaderVal $headers 'List-Id'
    if ($precedence -and $precedence -match '(?i)(bulk|list|junk)') { return $true }
    if ($listId) { return $true }
    $xMailer = Get-HeaderVal $headers 'X-Mailer'
    if ($xMailer -and $xMailer -match '(?i)(mailchimp|constant contact|sendgrid|sendinblue|getresponse|hubspot|marketo|pardot|eloqua)') { return $true }
    return $false
  }
  function Is-AutoGeneratedMessage($headers){
    $auto = Get-HeaderVal $headers 'Auto-Submitted'
    $suppress = Get-HeaderVal $headers 'X-Auto-Response-Suppress'
    if ($auto -and $auto -match '(?i)(auto-replied|auto-generated|auto-notified|vacation)') { return $true }
    if ($suppress -and $suppress -match '(?i)(all|oof)') { return $true }
    $ctype = Get-HeaderVal $headers 'Content-Type'
    if ($ctype -and $ctype -match '(?i)multipart/report') { return $true }
    return $false
  }
  function ShouldExcludeByPolicy($meta,[string]$folderPath){
    if ($IncludePathPattern -and -not (MatchesAny $folderPath $IncludePathPattern)) { return $true }
    if ($ExcludePathPattern -and (MatchesAny $folderPath $ExcludePathPattern)) { return $true }
    if ($AllowSenders -and -not (AddressMatches $meta.From $AllowSenders)) { return $true }
    if ($RejectSenders -and (AddressMatches $meta.From $RejectSenders)) { return $true }
    if ($RejectDomains) {
      $addr = NormalizeEmail $meta.From
      foreach($d in $RejectDomains){ if ($addr -like "*@$d") { return $true } }
    }
    if ($AllowDomains) {
      $addr = NormalizeEmail $meta.From
      $dom = if ($addr -and $addr.Contains('@')) { $addr.Split('@')[-1] } else { $null }
      if ($dom -and $dom -notin ($AllowDomains | ForEach-Object { $_.ToLower() })) { return $true }
    }
    if ($RejectSubjectRegex) {
      foreach($r in $RejectSubjectRegex){ if ($meta.Subject -and ($meta.Subject -match $r)) { return $true } }
    }
    if ($RejectBodyRegex) {
      foreach($r in $RejectBodyRegex){ if ($meta.BodyPreview -and ($meta.BodyPreview -match $r)) { return $true } }
    }
    if ($ExcludeMarketing -and $meta.Headers -and (Is-MarketingMessage $meta.Headers)) { return $true }
    if ($ExcludeAutoGenerated -and $meta.Headers -and (Is-AutoGeneratedMessage $meta.Headers)) { return $true }
    return $false
  }

  # ---------- Inline detection ----------
  function IsInlineAttachment([string]$name,[int64]$len,[string]$contentId,[string]$disposition,[string]$html,[bool]$enableLogos,[int]$logoKB){
    if ($disposition -and $disposition.ToLowerInvariant() -eq 'inline') { return $true }
    if ($contentId -and $html -and ($html.ToLowerInvariant().Contains(("cid:" + $contentId.ToLowerInvariant())) -or
                                     $html.ToLowerInvariant().Contains(("cid:<" + $contentId.ToLowerInvariant() + ">")))) { return $true }
    if ($enableLogos) {
      $n = ($name ?? '').ToLowerInvariant()
      if ($n -match '\.(png|gif|jpg|jpeg|bmp|ico)$') {
        if ($n -match '(^|[^a-z])(logo|image\d+)$' -and $len -lt ($logoKB * 1KB)) { return $true }
        if ($n -match 'smime\.p7s') { return $true }
      }
    }
    return $false
  }

  # ---------- Conversation key ----------
  function Pick-ConvoKey($mi,$headers){
    $pa = $mi.PropertyAccessor
    try{ $v=$pa.GetProperty($script:PR_CONV_ID); if($v){ return "cid:$v" } }catch{}
    try{ $v2=$pa.GetProperty($script:PR_CONV_INDEX); if($v2){ $root=ThreadIndexRoot $v2; if($root){ return "ti:$root" } } }catch{}
    $h = $headers
    $refs = @()
    $irt = $null
    if ($h){ $v3 = Get-HeaderVal $h 'References'; if ($v3){ $refs = ($v3 -split '\s+') } ; $irt = Get-HeaderVal $h 'In-Reply-To' }
    $top = if ($refs.Count -gt 0) { $refs[0] } else { $irt }
    if ($top) { return "ref:$top" }
    # fallback
    $sub = SmartSubject ([string]$mi.Subject)
    $from = NormalizeEmail (Get-SenderSmtp $mi)
    $to = ((Get-RecipientsArray $mi $script:OL_TO) | ForEach-Object { NormalizeEmail $_.smtp }) -join ','
    return "sub:" + (HashString "$sub|$from|$to")
  }
  function Compute-ConvoDirName([string]$smart,[Nullable[datetime]]$lastUtc,[string]$key,[string]$base){
    $dt = if ($lastUtc) { $lastUtc.Value.ToUniversalTime().ToString('yyyyMMdd_HHmm',$script:inv) } else { (Get-Date).ToUniversalTime().ToString('yyyyMMdd_HHmm',$script:inv) }
    $name = "{0} [{1}] [{2}]" -f (ConvertTo-SafeName $smart), $dt, (ShortKey (HashString $key))
    Optimize-NameForBase $base $name
  }

  # Emit text file (BOM toggle)
  function Write-Text([string]$path,[string]$text){
    if ($NoBomEncoding) {
      $utf8 = New-Object System.Text.UTF8Encoding($false)
      [System.IO.File]::WriteAllText($path, $text, $utf8)
    } else {
      Set-Content -LiteralPath $path -Value $text -Encoding UTF8
    }
  }

  # Initialize log rotation
  Initialize-LogRotation
}

process {
  Assert-Offline

  $OutputRoot = Test-Dir $OutputRoot
  $state = if ($Since -eq 'auto') { Read-State $OutputRoot } else { @{ LastSyncUTC = $Since; Folders=@() } }

  $folders = Resolve-Folders -Folders $Folders -PickFolders:$PickFolders
  if (-not $folders -or $folders.Count -eq 0){ throw "No folders to process." }

  $folderPaths = @($folders | ForEach-Object { $_.FolderPath })
  $lastSyncUtc = $null
  if ($Full) { $lastSyncUtc = $null }
  else {
    if ($Since -eq 'auto') {
      try { if ($state.LastSyncUTC) { $lastSyncUtc = ([datetime]::Parse($state.LastSyncUTC)).ToUniversalTime() } } catch { }
    } else {
      try { $lastSyncUtc = ([datetime]::Parse($Since)).ToUniversalTime() } catch { }
    }
  }

  # Two-pass: touched conversation keys since last sync
  $filterString = $null
  if ($lastSyncUtc) { $filterString = "[ReceivedTime] >= '" + (ConvertTo-OutlookFilterDate $lastSyncUtc) + "'" }

  $touched = New-Object 'System.Collections.Generic.HashSet[string]'
  $convMap = @{}  # key -> ArrayList of [EntryID, StoreID, FolderPath]
  $UseTwoPass = [bool]$lastSyncUtc

  function Group-Folder($f,[bool]$OnlyTouched){
    foreach($row in (Get-TableItems -Folder $f -FilterString $filterString -FilterFromUtc $lastSyncUtc)){
      $eid = SafeRow $row 'EntryID'; if([string]::IsNullOrWhiteSpace($eid)){ continue }
      # materialize mi lazily later; compute provisional key from row/subject if needed (will be recomputed from headers later)
      $keySeed = "seed|" + (SafeRow $row 'ConversationID') + "|" + (SafeRow $row 'ConversationIndex') + "|" + (SafeRow $row 'Subject')
      $key = "seed:" + (HashString $keySeed) # provisional
      if ($OnlyTouched -and -not $touched.Contains($key)){ continue }
      if(-not $convMap.ContainsKey($key)){ $convMap[$key] = New-Object System.Collections.ArrayList }
      [void]$convMap[$key].Add(@($eid, $f.StoreID, $f.FolderPath))
    }
  }

  # First pass: mark touched
  if($UseTwoPass){
    foreach($f in $folders){
      foreach($row in (Get-TableItems -Folder $f -FilterString $filterString -FilterFromUtc $lastSyncUtc)){
        $recv = SafeRowDate $row 'ReceivedTime'
        if($recv -and $recv.ToUniversalTime() -gt $lastSyncUtc){
          $eid = SafeRow $row 'EntryID'
          [void]$touched.Add("seed:" + (HashString ($eid)))
        }
      }
    }
  }
  # Second pass: group all (will rekey once we open items)
  foreach($f in $folders){ Group-Folder $f $false }

  $exported = 0
  $processed = New-Object 'System.Collections.Generic.HashSet[string]'

  # Scan existing packs to enable incremental rename/skip
  $existing = @{} # convoKey -> @{ Path=..., LastUtc=... }
  Get-ChildItem -LiteralPath $OutputRoot -Directory -ErrorAction SilentlyContinue | ForEach-Object {
    $m = Join-Path $_.FullName 'manifest.json'
    if (Test-Path -LiteralPath $m) {
      try {
        $obj = Get-Content -LiteralPath $m -Raw -Encoding UTF8 | ConvertFrom-Json
        if ($obj.conversation_key) {
          $lu = $null; try { if ($obj.last_message_utc) { $lu = [datetime]::Parse($obj.last_message_utc).ToUniversalTime() } } catch {}
          $existing[$obj.conversation_key] = @{ Path = $_.FullName; LastUtc = $lu }
        }
      } catch { }
    }
  }

  foreach($seedKey in @($convMap.Keys)){
    $pairs = $convMap[$seedKey]
    if(-not $pairs){ continue }

    # materialize unique MailItems
    $seenE = New-Object 'System.Collections.Generic.HashSet[string]'
    $mails = @()
    foreach($p in $pairs){
      $eid = $p[0]; $storeId=$p[1]; $fpath=$p[2]
      if ($seenE.Contains($eid)) { continue }
      $store = $null
      foreach($s in $script:Session.Stores){ if($s.StoreID -eq $storeId){ $store=$s; break } }
      if(-not $store){ continue }
      $mi=$null
      try{
        $mi = $script:Session.GetItemFromID($eid, $storeId)
        if ($mi -and $mi.MessageClass -like 'IPM.Note*') {
          # build meta snapshot
          $headersRaw = Get-RawHeaders $mi
          $headers = Parse-Headers $headersRaw
          $from = Get-SenderSmtp $mi
          $bodyText = ""
          if($IncludeBodies -and $mi.DownloadState -eq $script:OL_FULLITEM){
            try{ $bodyText = [string]$mi.Body }catch{ $bodyText = "" }
          }
          $sentOnUtc = $null
          try { if ($mi.SentOn) { $sentOnUtc = ([datetime]$mi.SentOn).ToUniversalTime() } } catch {}

          $meta = [ordered]@{
            MailItem = $mi
            FolderPath = $fpath
            Subject = [string]$mi.Subject
            SmartSubject = SmartSubject ([string]$mi.Subject)
            From = $from
            To = (Get-RecipientsArray $mi $script:OL_TO)
            CC = (Get-RecipientsArray $mi $script:OL_CC)
            ReceivedUtc = ([datetime]$mi.ReceivedTime).ToUniversalTime()
            SentOnUtc = $sentOnUtc
            Headers = $headers
            BodyRaw = $bodyText
            BodyPreview = $bodyText.Substring(0, [Math]::Min(4000, $bodyText.Length))
            MessageId = if ($headers) { Get-HeaderVal $headers 'Message-ID' } else { $null }
            InReplyTo = if ($headers) { Get-HeaderVal $headers 'In-Reply-To' } else { $null }
            References = if ($headers -and (Get-HeaderVal $headers 'References')) { (Get-HeaderVal $headers 'References') -split '\s+' } else { @() }
          }
          if (ShouldExcludeByPolicy $meta $fpath) {
            continue
          }
          $meta | Add-Member -NotePropertyName ConvoKey -NotePropertyValue (Pick-ConvoKey $mi $headers)
          # Sort key (prefer Sent for your own outgoing)
          $my = $null; # future: bind -MyAddress if needed
          $fromNorm = NormalizeEmail $meta.From
          $meta | Add-Member -NotePropertyName SortUtc -NotePropertyValue (if ($my -and $fromNorm -eq (NormalizeEmail $my)) {
            if ($meta.SentOnUtc){ $meta.SentOnUtc } elseif ($meta.ReceivedUtc){ $meta.ReceivedUtc } else { $meta.ReceivedUtc }
          } else { if ($meta.ReceivedUtc){ $meta.ReceivedUtc } else { $meta.SentOnUtc } })
          $mails += $meta
          $seenE.Add($eid) | Out-Null
        }
      } catch {
        Log "Warn: failed to open item: $_"
      }
    }

    if($mails.Count -eq 0){ continue }

    # Repartition by final conversation keys (some seed groups will split)
    $byKey = $mails | Group-Object -Property ConvoKey
    foreach($grp in $byKey){
      $k = [string]$grp.Name
      if ($processed.Contains($k)) { continue }
      $msgs = @($grp.Group | Sort-Object SortUtc)
      if ($msgs.Count -eq 0) { continue }

      # LeavesOnly selection
      $emit = $msgs
      if ($LeavesOnly) {
        $refs = New-Object 'System.Collections.Generic.HashSet[string]'
        foreach($m in $msgs){
          foreach($rid in $m.References){ if ($rid) { $refs.Add($rid) | Out-Null } }
          if ($m.InReplyTo) { $refs.Add($m.InReplyTo) | Out-Null }
        }
        $emit = @($msgs | Where-Object { $_.MessageId -and -not $refs.Contains($_.MessageId) })
        if ($emit.Count -eq 0) { $emit = $msgs | Select-Object -Last 1 } # fallback: newest only
      }

      $newest = $msgs[-1]
      $smart  = $newest.SmartSubject
      $lastUtc  = ($msgs | Where-Object { $_.SortUtc } | Select-Object -Last 1).SortUtc
      $startUtc = ($msgs | Where-Object { $_.SortUtc } | Select-Object -First 1).SortUtc

      # Incremental skip if nothing newer than existing
      $existingPack = $existing[$k]
      if ($existingPack -and $existingPack.LastUtc -and $lastUtc -and $lastUtc -le $existingPack.LastUtc) {
        $processed.Add($k) | Out-Null
        continue
      }

      # Destination dir
      $desiredName = Compute-ConvoDirName -smart $smart -lastUtc $lastUtc -key $k -base $OutputRoot
      $desiredPath = Join-Path $OutputRoot $desiredName
      $convDir = if ($existingPack -and $existingPack.Path) { $existingPack.Path } else { Test-Dir $desiredPath }
      $attDir = Test-Dir (Join-Path $convDir 'attachments')

      # Copy attachments with SHA-256 dedupe
      $attMeta = @()
      if ($IncludeAttachments -and $IncludeBodies) {
        $shaToName = @{}
        # Prime from previous manifest (if any)
        $prevM = Join-Path $convDir 'manifest.json'
        if (Test-Path -LiteralPath $prevM) {
          try {
            $prev = Get-Content -LiteralPath $prevM -Raw -Encoding UTF8 | ConvertFrom-Json
            foreach($a in @($prev.attachments)){ if ($a.sha256 -and $a.filename) { $shaToName[$a.sha256] = $a.filename } }
          } catch {}
        }
        foreach($m in $msgs){
          $mi = $m.MailItem
          if ($mi -and $mi.DownloadState -eq $script:OL_FULLITEM -and $mi.Attachments -and $mi.Attachments.Count -gt 0) {
            $html = $null; if ($mi.BodyFormat -eq $script:OL_FORMAT_HTML) { try { $html = [string]$mi.HTMLBody } catch {} }
            foreach($a in $mi.Attachments){
              $cid = $null; $disp = $null
              try { $pa=$a.PropertyAccessor; $cid = ($pa.GetProperty($script:PR_ATTACH_CIDW) -as [string]); if(-not $cid){ $cid = ($pa.GetProperty($script:PR_ATTACH_CIDA) -as [string]) } } catch {}
              try { $disp = $pa.GetProperty("http://schemas.microsoft.com/mapi/proptag/0x3716001F") } catch {} # PR_ATTACH_CONTENT_DISPOSITION (best-effort)
              $name = ConvertTo-SafeName ($a.FileName -as [string]); if (-not $name) { $name = 'file' }
              $isInline = IsInlineAttachment $name $a.Size $cid $disp $html $SkipInlineLogos $InlineLogoMaxKB
              if ($isInline) { continue }

              # Save to temp, hash, dedupe
              $tmp = Join-Path $attDir ("_tmp_" + [IO.Path]::GetRandomFileName())
              try {
                $a.SaveAsFile($tmp)
                $sha = Sha256File $tmp
                $finalName = if ($shaToName.ContainsKey($sha)) { $shaToName[$sha] } else {
                  # choose destination filename (prefer current)
                  $base = ConvertTo-SafeName $name
                  $maxLocal = [Math]::Max(1, $script:MAX_PATH_SAFE - ($attDir.TrimEnd('\') + '\').Length - 1)
                  $base = Limit-PathLength $base $maxLocal
                  $dest = Join-Path $attDir $base
                  $n=1; while(Test-Path -LiteralPath $dest){
                    $stem=[IO.Path]::GetFileNameWithoutExtension($base)
                    $ext=[IO.Path]::GetExtension($base)
                    $dest = Join-Path $attDir ("{0}_{1}{2}" -f $stem,$n,$ext)
                    $n++; if($n -gt 100){ break }
                  }
                  Copy-Item -LiteralPath $tmp -Destination $dest -Force
                  $shaToName[$sha] = [IO.Path]::GetFileName($dest)
                  $shaToName[$sha]
                }
                $fi = Get-Item -LiteralPath (Join-Path $attDir $finalName)
                $attMeta += [ordered]@{
                  filename  = $finalName
                  extension = [IO.Path]::GetExtension($finalName)
                  filetype  = $null
                  size_bytes= [int64]$fi.Length
                  sha256    = $sha
                }
              } catch {
                Log "Warn: save/hash attachment failed: $name : $_"
              } finally { if (Test-Path -LiteralPath $tmp) { Remove-Item -LiteralPath $tmp -Force -ErrorAction SilentlyContinue } }
            }

            # Nested .msg
            if ($IncludeNestedAttachments) {
              foreach($a in $mi.Attachments){
                $low = ([string]$a.FileName).ToLowerInvariant()
                if ($low.EndsWith('.msg') -and $NestedDepth -gt 0) {
                  # Extract one level using Outlook
                  $tmpMsg = Join-Path $attDir ("_tmp_" + [IO.Path]::GetRandomFileName() + ".msg")
                  try {
                    $a.SaveAsFile($tmpMsg)
                    $app = $script:Outlook
                    $nested = $app.CreateItemFromTemplate($tmpMsg)
                    if ($nested -and $nested.Attachments){
                      foreach($na in $nested.Attachments){
                        $nlow = ([string]$na.FileName).ToLowerInvariant()
                        if ($nlow.EndsWith('.msg')) { continue } # don't go deeper here for brevity
                        $tmp2 = Join-Path $attDir ("_tmp_" + [IO.Path]::GetRandomFileName())
                        try {
                          $na.SaveAsFile($tmp2)
                          $sha = Sha256File $tmp2
                          if (-not $shaToName.ContainsKey($sha)) {
                            $base = ConvertTo-SafeName $na.FileName
                            $dest = Join-Path $attDir $base
                            $n=1; while(Test-Path -LiteralPath $dest){
                              $stem=[IO.Path]::GetFileNameWithoutExtension($base)
                              $ext=[IO.Path]::GetExtension($base)
                              $dest = Join-Path $attDir ("{0}_{1}{2}" -f $stem,$n,$ext)
                              $n++; if($n -gt 100){ break }
                            }
                            Copy-Item -LiteralPath $tmp2 -Destination $dest -Force
                            $shaToName[$sha] = [IO.Path]::GetFileName($dest)
                          }
                        } finally { if (Test-Path -LiteralPath $tmp2) { Remove-Item -LiteralPath $tmp2 -Force -ErrorAction SilentlyContinue } }
                      }
                    }
                  } catch { Log "Warn: nested .msg extract failed: $_" }
                  finally { if (Test-Path -LiteralPath $tmpMsg) { Remove-Item -LiteralPath $tmpMsg -Force -ErrorAction SilentlyContinue } }
                }
              }
            }
          }
        }
      }
      # Build Conversation.txt & cleaned/chunks
      $emitList = if ($LeavesOnly) { @($emit | Sort-Object SortUtc -Descending) } else { @($msgs | Sort-Object SortUtc) }
      $rawTxt = New-Object System.Text.StringBuilder
      $cleanTxt = New-Object System.Text.StringBuilder
      $chunks = @()
      foreach($m in $emitList){
        [void]$rawTxt.AppendLine(('-'*80))
        [void]$rawTxt.AppendLine(("{0:u} | From: {1} | To: {2}" -f $m.SortUtc, $m.From, ((@($m.To) | ForEach-Object { $_.smtp }) -join '; ')))
        if ($m.CC -and @($m.CC).Count){ [void]$rawTxt.AppendLine(("Cc: {0}" -f ((@($m.CC) | ForEach-Object { $_.smtp }) -join '; '))) }
        [void]$rawTxt.AppendLine(("Subject: {0}" -f $m.Subject))
        [void]$rawTxt.AppendLine("")
        $b = $m.BodyRaw; if (-not $b) { $b = "(no body extracted)" }
        [void]$rawTxt.AppendLine($b)
        [void]$rawTxt.AppendLine("")
        if ($CleanBodies) {
          $clean = Clean-BodyForNLP $b
          if ($clean -and $clean.Length -ge $MinBodyChars) {
            [void]$cleanTxt.AppendLine(('-'*80))
            [void]$cleanTxt.AppendLine(("{0:u} | From: {1} | To: {2}" -f $m.SortUtc, (NormalizeEmail $m.From), ((@($m.To) | ForEach-Object { NormalizeEmail $_.smtp }) -join '; ')))
            [void]$cleanTxt.AppendLine("")
            [void]$cleanTxt.AppendLine($clean)
            [void]$cleanTxt.AppendLine("")
            if ($EmitChunks) {
              $pos=0
              foreach($p in (Split-IntoChunks $clean $ChunkSizeChars $ChunkOverlapChars)){
                $pos++
                $chunks += [ordered]@{
                  conversation_key = $k
                  message_id       = $m.MessageId
                  sort_utc         = if ($m.SortUtc) { $m.SortUtc.ToString('o') } else { $null }
                  subject          = $m.SmartSubject
                  from             = (NormalizeEmail $m.From)
                  to               = (@($m.To) | ForEach-Object { NormalizeEmail $_.smtp })
                  position         = $pos
                  text             = $p
                }
              }
            }
          }
        }
      }
      Write-Text -path (Join-Path $convDir 'Conversation.txt') -text $rawTxt.ToString()
      if ($CleanBodies) { Write-Text -path (Join-Path $convDir 'Conversation.clean.txt') -text $cleanTxt.ToString() }
      if ($EmitChunks -and $chunks.Count -gt 0) {
        $path = Join-Path $convDir 'chunks.jsonl'
        $sb = New-Object System.Text.StringBuilder
        foreach($c in $chunks){ [void]$sb.AppendLine(($c | ConvertTo-Json -Depth 4)) }
        Write-Text -path $path -text $sb.ToString()
      }

      # Manifest (superset schema + EmailOps messages array for compatibility)
      $participants = @()
      $allEmails = @()
      $allEmails += ($msgs | ForEach-Object { NormalizeEmail $_.From })
      $allEmails += ($msgs | ForEach-Object { @($_.To) + @($_.CC) } | ForEach-Object { NormalizeEmail $_.smtp })
      $allEmails = $allEmails | Where-Object { $_ } | Select-Object -Unique
      foreach ($e in $allEmails) { $participants += [ordered]@{ given_name=$null; surname=$null; smtp=$e; job_title=$null } }
      $messagesArr = @()
      foreach($m in $msgs){
        $messagesArr += [ordered]@{
          id = ($m.MessageId ?? (HashString ($m.Subject + '|' + $m.SortUtc)))
          from = @{ name = ''; smtp = (NormalizeEmail $m.From) }
          to = $m.To
          cc = $m.CC
          date = if ($m.SortUtc) { $m.SortUtc.ToString('yyyy-MM-ddTHH:mm:ssZ',$script:inv) } else { $null }
          subject = $m.Subject
          text = $m.BodyRaw
        }
      }
      $manifest = [ordered]@{
        conversation_key       = $k
        smart_subject          = $smart
        conversation_start_utc = if ($startUtc){ $startUtc.ToString('o') } else { $null }
        last_message_utc       = if ($lastUtc){ $lastUtc.ToString('o') } else { $null }
        from                   = (NormalizeEmail $newest.From)
        to                     = (@($newest.To) | ForEach-Object { NormalizeEmail $_.smtp })
        cc                     = (@($newest.CC) | ForEach-Object { NormalizeEmail $_.smtp })
        participants           = $participants
        messages_count         = $msgs.Count
        has_attachment         = (@($attMeta).Count -gt 0)
        attachments            = $attMeta
        message_ids            = ($msgs | ForEach-Object { $_.MessageId })
        nlp                    = [ordered]@{
          cleaned_bodies      = [bool]$CleanBodies
          emit_chunks         = [bool]$EmitChunks
          chunk_size_chars    = $ChunkSizeChars
          chunk_overlap_chars = $ChunkOverlapChars
          min_body_chars      = $MinBodyChars
          leaves_only         = [bool]$LeavesOnly
        }
        messages               = $messagesArr
      }
      $json = ($manifest | ConvertTo-Json -Depth 8)
      Write-Text -path (Join-Path $convDir 'manifest.json') -text $json

      # Try rename folder if desired name differs and we reused an existing path
      if ($existingPack -and $existingPack.Path -and $existingPack.Path -ne $desiredPath) {
        try {
          if (-not (Test-Path -LiteralPath $desiredPath)) {
            Move-Item -LiteralPath $existingPack.Path -Destination $desiredPath
          }
        } catch { Log "Info: rename skipped: $_" }
      }

      $exported++
      $processed.Add($k) | Out-Null

      # Release COM mailitems for this group
      foreach($m in $msgs){
        try { if ($m.MailItem) { [void][Runtime.InteropServices.Marshal]::ReleaseComObject($m.MailItem) } } catch {}
      }
    }
  }

  if($SaveState){
    $stamp = [DateTime]::UtcNow
    Write-State -root $OutputRoot -LastSyncUTC $stamp -FoldersArr $folderPaths
  }
  Write-Host ("Done. Conversations written or updated: {0}" -f $exported) -ForegroundColor Cyan
}

end {
  try { if($script:Session){ [void][Runtime.InteropServices.Marshal]::ReleaseComObject($script:Session) } } catch {}
  try { if($script:Outlook){ [void][Runtime.InteropServices.Marshal]::ReleaseComObject($script:Outlook) } } catch {}
}
