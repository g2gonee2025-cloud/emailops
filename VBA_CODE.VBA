''Attribute VB_Name = "UCX_Exporter_LeavesOnly"
Option Explicit
'===============================================================================
' Unified Conversation Exporter for Outlook (VBA) — Leaves-Only, Hardened Build
' Final Edition (2025-11-02)  —  THIS FILE IS THE FINAL MERGED VERSION
'
' What this module does:
'   • Scans Outlook folders via Items enumeration (GetTable optional, guarded)
'   • Builds conversation buckets
'   • Exports **LEAVES ONLY** (one file: Conversation.clean.txt)
'   • Cleans text (quotes/signatures/disclaimers stripped; whitespace normalized)
'   • Saves **only** unique, non-inline attachments into a global blob store:
'       OutRoot\_blobs\<sha256><ext>
'     The conversation manifest references canonical blob paths; reindex-safe.
'   • Optimized, low-memory scan (no body caching during scan; streaming writes)
'
' Important changes (2025-11-02):
'   • Removed Items.SetColumns: unsupported for EntryID/DownloadState and makes
'     other properties come back empty after caching. See MS docs.
'   • Restrict() date filter uses Format(..., "ddddd h:nn AMPM") per docs.
'   • AttachmentIsInline hardened (PR_RENDERING_POSITION, PR_ATTACH_FLAGS,
'     PR_ATTACHMENT_HIDDEN, CID in HTML, TNEF).
'   • Sender SMTP resolution uses PR_SMTP_ADDRESS fallback via PropertyAccessor.
'===============================================================================

'============================== USER CONFIG ====================================
Private Const CFG_OutRoot_Default As String = ""   ' "" -> auto Desktop\Outlook
Private Const CFG_PickFolders As Boolean = True    ' True -> picker; False -> use CFG_Folders
Private CFG_Folders As Variant                     ' e.g. Array("\\Mailbox - Me\Inbox", "\\Mailbox - Me\Sent Items")
Private Const CFG_Full As Boolean = False          ' True -> ignore state/Since; export all
Private Const CFG_Since As String = "auto"         ' "auto" -> _state.json; else ISO or local date/time
Private Const CFG_NoState As Boolean = False       ' True -> never read/write _state.json
Private Const CFG_SaveState As Boolean = True      ' True -> write state (unless NoState True)

' Start with offline strict disabled to avoid profile quirks; flip True once clean.
Private Const CFG_OfflineStrict As Boolean = True

' Scanning selector (failsafe default)
Private Const CFG_ForceItemsLoop As Boolean = True ' True = Items loop only; False = allow GetTable (with guards)

' Processing
Private Const CFG_IncludeAttachments As Boolean = True
Private Const CFG_IncludeBodies As Boolean = True
Private Const CFG_IncludeNestedAttachments As Boolean = True
Private Const CFG_NestedDepth As Long = 2
Private Const CFG_LeavesOnly As Boolean = True     ' **must be True for this build**

' Path / naming
Private Const CFG_EnableLongPaths As Boolean = False
Private Const CFG_MaxPathLength As Long = 180

' Filters (leave Empty to disable)
Private CFG_IncludePathPattern As Variant
Private CFG_ExcludePathPattern As Variant
Private CFG_AllowSenders As Variant
Private CFG_RejectSenders As Variant
Private CFG_RejectDomains As Variant
Private CFG_RejectSubjectRegex As Variant

Private Const CFG_ExcludeMarketing As Boolean = True
Private Const CFG_ExcludeAutoGenerated As Boolean = True

' Bodies / cleaning
Private Const CFG_CleanBodies As Boolean = True
Private Const CFG_MinBodyChars As Long = 20
Private Const CFG_EmitChunks As Boolean = False
Private Const CFG_ChunkSizeChars As Long = 3600
Private Const CFG_ChunkOverlapChars As Long = 400
Private Const CFG_NoBomEncoding As Boolean = True

' Inline logos
Private Const CFG_InlineLogoMaxKB As Long = 50
Private Const CFG_SkipInlineLogos As Boolean = True

' Attachments behavior
Private Const CFG_AttFallbackAllIfNone As Boolean = True   ' if no leaf has a file, scan all messages for files

' Logging (optional)
Private Const CFG_LogPath As String = "C:\\Users\\ASUS\\Desktop\\Outlook\\ucx_export.log"          ' e.g. "C:\Temp\ucx_log.txt" or "" to disable

' Diagnostics
Private g_errorCount As Long

'============================== TYPES ==========================================
Public Type UCX_Config
    outRoot As String
    folders As Variant
    PickFolders As Boolean
    Full As Boolean
    Since As String
    NoState As Boolean
    SaveState As Boolean
    OfflineStrict As Boolean

    IncludeAttachments As Boolean
    includeBodies As Boolean
    IncludeNestedAttachments As Boolean
    NestedDepth As Long
    LeavesOnly As Boolean

    EnableLongPaths As Boolean
    MaxPathLength As Long

    IncludePathPattern As Variant
    ExcludePathPattern As Variant
    AllowSenders As Variant
    RejectSenders As Variant
    RejectDomains As Variant
    RejectSubjectRegex As Variant
    ExcludeMarketing As Boolean
    ExcludeAutoGenerated As Boolean

    CleanBodies As Boolean
    MinBodyChars As Long
    EmitChunks As Boolean
    ChunkSizeChars As Long
    ChunkOverlapChars As Long
    NoBomEncoding As Boolean

    InlineLogoMaxKB As Long
    SkipInlineLogos As Boolean

    LogPath As String
End Type

'============================= CONSTANTS =======================================
' Outlook-ish constants (numeric)
Private Const OL_TO As Long = 1
Private Const OL_CC As Long = 2
Private Const OL_FORMAT_HTML As Long = 2
Private Const OL_DOWNLOADSTATE_COMPLETE As Long = 1
Private Const OLCM_CachedOffline As Long = 400
Private Const OLCM_Disconnected As Long = 500

' MAPI named property tags
Private Const PR_CONV_ID As String = "http://schemas.microsoft.com/mapi/proptag/0x30130102"
Private Const PR_CONV_INDEX As String = "http://schemas.microsoft.com/mapi/proptag/0x00710102"
Private Const PR_HDRS_W As String = "http://schemas.microsoft.com/mapi/proptag/0x007D001F"
Private Const PR_HDRS_A As String = "http://schemas.microsoft.com/mapi/proptag/0x007D001E"
Private Const PR_ATTACH_CIDW As String = "http://schemas.microsoft.com/mapi/proptag/0x3712001F"
Private Const PR_ATTACH_CIDA As String = "http://schemas.microsoft.com/mapi/proptag/0x3712001E"
Private Const PR_ATTACH_CONTENT_DISP As String = "http://schemas.microsoft.com/mapi/proptag/0x3716001F"
Private Const PR_RENDERING_POSITION As String = "http://schemas.microsoft.com/mapi/proptag/0x370B0003"
Private Const PR_ATTACHMENT_HIDDEN As String = "http://schemas.microsoft.com/mapi/proptag/0x7FFE000B"
Private Const PR_ATTACH_FLAGS As String = "http://schemas.microsoft.com/mapi/proptag/0x37140003"
Private Const PR_SMTP_ADDRESS As String = "http://schemas.microsoft.com/mapi/proptag/0x39FE001E"
Private Const PR_MESSAGE_DELIVERY_TIME As String = "http://schemas.microsoft.com/mapi/proptag/0x0E060040"
Private Const PR_CLIENT_SUBMIT_TIME As String = "http://schemas.microsoft.com/mapi/proptag/0x00390040"

Private Const STATE_FILE As String = "_state.json"
Private Const LOCK_FILE As String = "_export.lock"
Private Const BLOB_CACHE_FILE As String = "_blobs\_cache.json"

' Path budgets
Private Const MAX_PATH_SAFE As Long = 240   ' legacy fallback

' Performance & Magic Numbers
Private Const MIN_DISK_SPACE_MB As Long = 100
Private Const BYTES_PER_MB As Long = 1048576
Private Const LOOP_DOEVENTS_STEP As Long = 500
Private Const BODY_PREVIEW_LENGTH As Long = 4000

'========================== Win32 / Crypto declarations ========================
#If VBA7 Then
Private Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
#Else
Private Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
#End If

' CryptoAPI (SHA-256)
#If VBA7 Then
Private Declare PtrSafe Function CryptAcquireContext Lib "advapi32.dll" Alias "CryptAcquireContextA" (ByRef phProv As LongPtr, ByVal pszContainer As String, ByVal pszProvider As String, ByVal dwProvType As Long, ByVal dwFlags As Long) As Long
Private Declare PtrSafe Function CryptReleaseContext Lib "advapi32.dll" (ByVal hProv As LongPtr, ByVal dwFlags As Long) As Long
Private Declare PtrSafe Function CryptCreateHash Lib "advapi32.dll" (ByVal hProv As LongPtr, ByVal Algid As Long, ByVal hKey As LongPtr, ByVal dwFlags As Long, ByRef phHash As LongPtr) As Long
Private Declare PtrSafe Function CryptHashData Lib "advapi32.dll" (ByVal hHash As LongPtr, ByRef pbData As Any, ByVal dwDataLen As Long, ByVal dwFlags As Long) As Long
Private Declare PtrSafe Function CryptGetHashParam Lib "advapi32.dll" (ByVal hHash As LongPtr, ByVal dwParam As Long, ByRef pbData As Any, ByRef pdwDataLen As Long, ByVal dwFlags As Long) As Long
Private Declare PtrSafe Function CryptDestroyHash Lib "advapi32.dll" (ByVal hHash As LongPtr) As Long
#Else
Private Declare Function CryptAcquireContext Lib "advapi32.dll" Alias "CryptAcquireContextA" (ByRef phProv As Long, ByVal pszContainer As String, ByVal pszProvider As String, ByVal dwProvType As Long, ByVal dwFlags As Long) As Long
Private Declare Function CryptReleaseContext Lib "advapi32.dll" (ByVal hProv As Long, ByVal dwFlags As Long) As Long
Private Declare Function CryptCreateHash Lib "advapi32.dll" (ByVal hProv As Long, ByVal Algid As Long, ByVal hKey As Long, ByVal dwFlags As Long, ByRef phHash As Long) As Long
Private Declare Function CryptHashData Lib "advapi32.dll" (ByVal hHash As Long, ByRef pbData As Any, ByVal dwDataLen As Long, ByVal dwFlags As Long) As Long
Private Declare Function CryptGetHashParam Lib "advapi32.dll" (ByVal hHash As Long, ByVal dwParam As Long, ByRef pbData As Any, ByRef pdwDataLen As Long, ByVal dwFlags As Long) As Long
Private Declare Function CryptDestroyHash Lib "advapi32.dll" (ByVal hHash As Long) As Long
#End If

Private Const PROV_RSA_AES As Long = &HF&
Private Const CRYPT_VERIFYCONTEXT As Long = &HF0000000
Private Const CALG_SHA_256 As Long = &H800C&
Private Const HP_HASHVAL As Long = 2
Private Const HP_HASHSIZE As Long = 4

' Timezone APIs (DST-correct conversion)
#If VBA7 Then
Private Declare PtrSafe Function GetTimeZoneInformation Lib "kernel32" (lpTimeZoneInformation As TIME_ZONE_INFORMATION) As Long
Private Declare PtrSafe Function SystemTimeToTzSpecificLocalTime Lib "kernel32" (lpTimeZoneInformation As TIME_ZONE_INFORMATION, lpUniversalTime As SYSTEMTIME, lpLocalTime As SYSTEMTIME) As Long
Private Declare PtrSafe Function TzSpecificLocalTimeToSystemTime Lib "kernel32" (lpTimeZoneInformation As TIME_ZONE_INFORMATION, lpLocalTime As SYSTEMTIME, lpUniversalTime As SYSTEMTIME) As Long
#Else
Private Declare Function GetTimeZoneInformation Lib "kernel32" (lpTimeZoneInformation As TIME_ZONE_INFORMATION) As Long
Private Declare Function SystemTimeToTzSpecificLocalTime Lib "kernel32" (lpTimeZoneInformation As TIME_ZONE_INFORMATION, lpUniversalTime As SYSTEMTIME, lpLocalTime As SYSTEMTIME) As Long
Private Declare Function TzSpecificLocalTimeToSystemTime Lib "kernel32" (lpTimeZoneInformation As TIME_ZONE_INFORMATION, lpLocalTime As SYSTEMTIME, lpUniversalTime As SYSTEMTIME) As Long
#End If

Public Type SYSTEMTIME
    wYear As Integer
    wMonth As Integer
    wDayOfWeek As Integer
    wDay As Integer
    wHour As Integer
    wMinute As Integer
    wSecond As Integer
    wMilliseconds As Integer
End Type

Public Type TIME_ZONE_INFORMATION
    Bias As Long
    StandardName(0 To 63) As Integer
    StandardDate As SYSTEMTIME
    StandardBias As Long
    DaylightName(0 To 63) As Integer
    DaylightDate As SYSTEMTIME
    DaylightBias As Long
End Type

Private Sub Nap(ByVal ms As Long)
    If ms <= 0 Then Exit Sub
    Sleep ms
    DoEvents
End Sub

'============================ ENTRY POINTS =====================================

Public Sub UCX_Run_Default()
    Dim cfg As UCX_Config: cfg = UCX_DefaultConfig()
    cfg.PickFolders = True
    If Len(CFG_OutRoot_Default) > 0 Then
        cfg.outRoot = CFG_OutRoot_Default
    Else
        cfg.outRoot = DesktopOutRoot()
    End If
    UCX_Export cfg
End Sub

Public Sub UCX_Run_FullExample()
    Dim cfg As UCX_Config: cfg = UCX_DefaultConfig()
    cfg.outRoot = DesktopOutRoot() & "\FullExport"
    cfg.Full = True
    cfg.PickFolders = True
    UCX_Export cfg
End Sub

'============================= CONFIG BUILD ====================================

Private Function UCX_DefaultConfig() As UCX_Config
    Dim c As UCX_Config
    If Len(CFG_OutRoot_Default) > 0 Then
        c.outRoot = CFG_OutRoot_Default
    Else
        c.outRoot = DesktopOutRoot()
    End If
    If IsEmpty(CFG_Folders) Then c.folders = Array() Else c.folders = CFG_Folders
    c.PickFolders = CFG_PickFolders
    c.Full = CFG_Full
    c.Since = CFG_Since
    c.NoState = CFG_NoState
    c.SaveState = CFG_SaveState
    c.OfflineStrict = CFG_OfflineStrict

    c.IncludeAttachments = CFG_IncludeAttachments
    c.includeBodies = CFG_IncludeBodies
    c.IncludeNestedAttachments = CFG_IncludeNestedAttachments
    c.NestedDepth = CFG_NestedDepth
    c.LeavesOnly = CFG_LeavesOnly

    c.EnableLongPaths = CFG_EnableLongPaths
    c.MaxPathLength = CFG_MaxPathLength

    c.IncludePathPattern = CFG_IncludePathPattern
    c.ExcludePathPattern = CFG_ExcludePathPattern
    c.AllowSenders = CFG_AllowSenders
    c.RejectSenders = CFG_RejectSenders
    c.RejectDomains = CFG_RejectDomains
    c.RejectSubjectRegex = CFG_RejectSubjectRegex
    c.ExcludeMarketing = CFG_ExcludeMarketing
    c.ExcludeAutoGenerated = CFG_ExcludeAutoGenerated

    c.CleanBodies = CFG_CleanBodies
    c.MinBodyChars = CFG_MinBodyChars
    c.EmitChunks = CFG_EmitChunks
    c.ChunkSizeChars = CFG_ChunkSizeChars
    c.ChunkOverlapChars = CFG_ChunkOverlapChars
    c.NoBomEncoding = CFG_NoBomEncoding

    c.InlineLogoMaxKB = CFG_InlineLogoMaxKB
    c.SkipInlineLogos = CFG_SkipInlineLogos
    c.LogPath = CFG_LogPath

    ValidateConfig c
    UCX_DefaultConfig = c
End Function

Private Sub ValidateConfig(ByRef cfg As UCX_Config)
    If cfg.NestedDepth < 0 Then cfg.NestedDepth = 0
    If cfg.NestedDepth > 5 Then cfg.NestedDepth = 5
    If cfg.MaxPathLength < 50 Then cfg.MaxPathLength = 50
    If cfg.MaxPathLength > 32000 Then cfg.MaxPathLength = 32000
    If cfg.MinBodyChars < 0 Then cfg.MinBodyChars = 0
    If cfg.ChunkSizeChars <= 0 Then cfg.ChunkSizeChars = 1000
    If cfg.ChunkOverlapChars < 0 Then cfg.ChunkOverlapChars = 0
    If cfg.ChunkOverlapChars >= cfg.ChunkSizeChars Then cfg.ChunkOverlapChars = cfg.ChunkSizeChars - 1
    If cfg.InlineLogoMaxKB < 0 Then cfg.InlineLogoMaxKB = 0
    If cfg.InlineLogoMaxKB > 10000 Then cfg.InlineLogoMaxKB = 10000
    ValidateRegexPatterns cfg.RejectSubjectRegex
End Sub

Private Sub ValidateRegexPatterns(ByRef patterns As Variant)
    If IsEmpty(patterns) Or IsNull(patterns) Then Exit Sub
    If Not IsArray(patterns) Then Exit Sub
    On Error Resume Next
    Dim re As Object: Set re = CreateObject("VBScript.RegExp")
    Dim i As Long
    For i = LBound(patterns) To UBound(patterns)
        If Len(CStr(patterns(i))) > 0 Then
            re.pattern = CStr(patterns(i))
            If Err.Number <> 0 Then
                Warn "Invalid regex pattern will be skipped: " & CStr(patterns(i))
                Err.Clear
            End If
        End If
    Next i
    On Error GoTo 0
End Sub

'=========================== CORE EXPORT =======================================

Private Sub UCX_Export(ByRef cfg As UCX_Config)
    Dim outRoot As String, blobDir As String, lockFile As String
    Dim globalSha As Object, folders As Collection, existing As Object, conv As Object
    Dim stateLastUTC As Date, filter As String
    Dim totalRows As Long, exported As Long

    g_errorCount = 0 ' Reset diagnostics counter for this run
    On Error GoTo ErrHandler

    Debug.Print "=== UCX_Export STARTED ==="
    MsgBox "Export started. Check View > Immediate Window (Ctrl+G) for progress.", vbInformation, "UCX Export"

    If Not cfg.LeavesOnly Then Err.Raise vbObjectError + 103, , "This version of the exporter only supports Leaves-Only mode. Please set CFG_LeavesOnly to True."

    ' Setup
    SetupExport cfg, outRoot, blobDir, lockFile, globalSha, stateLastUTC, filter

    ' Folders
    Set folders = ResolveFolders(cfg.folders, cfg.PickFolders)
    If folders Is Nothing Or folders.Count = 0 Then Err.Raise vbObjectError + 1, , "No folders selected."
    PrintSelectedFolders folders

    ' Scan
    Set existing = CreateObject("Scripting.Dictionary")
    ScanExistingPacks outRoot, existing
    Dim idBuckets As Object: Set idBuckets = CreateObject("Scripting.Dictionary")
    ScanFolders folders, filter, cfg, idBuckets, totalRows

    ' Export
    exported = ExportConversations(idBuckets, existing, cfg, outRoot, blobDir, globalSha)

    ' Teardown
    TeardownExport cfg, outRoot, lockFile, folders, exported, totalRows, g_errorCount, blobDir, globalSha

    Debug.Print "=== UCX_Export COMPLETED ==="
    Exit Sub

ErrHandler:
    Dim eNumber As Long, eDesc As String, eSrc As String
    eNumber = Err.Number: eDesc = Err.Description: eSrc = Err.source
    If Len(outRoot) > 0 Then Call ReleaseExportLock(outRoot & "\" & LOCK_FILE)
    Dim errMsg As String
    errMsg = "Error during export:" & vbCrLf & _
             "Number: " & CStr(eNumber) & vbCrLf & _
             "Description: " & eDesc & vbCrLf & _
             "Source: " & eSrc
    MsgBox errMsg, vbCritical, "UCX Export Error"
    Warn "Error: " & eNumber & " - " & eDesc & " (source: " & eSrc & ")"
    Debug.Print "=== UCX_Export FAILED ==="
End Sub

Private Sub SetupExport(ByRef cfg As UCX_Config, ByRef outRoot As String, ByRef blobDir As String, ByRef lockFile As String, _
                        ByRef globalSha As Object, ByRef stateLastUTC As Date, ByRef filter As String)
    If cfg.OfflineStrict Then
        Debug.Print "Checking offline status..."
        AssertOffline
        Debug.Print "Offline check passed"
    Else
        Debug.Print "Offline check skipped (CFG_OfflineStrict=False)"
    End If

    outRoot = EnsureFolderDeep(ChooseRoot(cfg.outRoot))
    Debug.Print "Output root: " & outRoot

    blobDir = BlobStoreRoot(outRoot)
    Set globalSha = CreateObject("Scripting.Dictionary")
    SeedBlobMap blobDir, globalSha
    Debug.Print "Blob store: " & blobDir & " (seeded " & CStr(globalSha.Count) & " entries)"

    lockFile = outRoot & "\" & LOCK_FILE
    If AcquireExportLock(lockFile) = False Then
        Err.Raise vbObjectError + 101, , "Another export is already running. Lock file exists: " & lockFile & vbCrLf & _
            "If no other export is running, manually delete this file and retry."
    End If
    Debug.Print "Lock acquired"

    If Not CheckDiskSpace(outRoot, MIN_DISK_SPACE_MB * BYTES_PER_MB) Then
        Err.Raise vbObjectError + 102, , "Insufficient disk space. At least 100MB required in: " & outRoot
    End If
    Debug.Print "Disk space OK"

    CleanupOrphanedTempFiles outRoot

    If cfg.Full Then
        stateLastUTC = 0
        Debug.Print "Mode: FULL export (ignoring state)"
    ElseIf LCase$(Trim$(cfg.Since)) = "auto" And Not cfg.NoState Then
        stateLastUTC = ReadStateLastUTC(outRoot)
        Dim syncMsg As String
        If stateLastUTC = 0 Then
            syncMsg = "(never)"
        Else
            syncMsg = Format$(stateLastUTC, "yyyy-mm-dd hh:nn:ss")
        End If
        Debug.Print "Mode: DELTA from state file. Last sync: " & syncMsg
    ElseIf Len(Trim$(cfg.Since)) > 0 And LCase$(Trim$(cfg.Since)) <> "auto" Then
        stateLastUTC = SafeParseDate(cfg.Since)
        Debug.Print "Mode: DELTA from config. Since: " & Format$(stateLastUTC, "yyyy-mm-dd hh:nn:ss")
    End If

    If cfg.Full Or stateLastUTC = 0 Then
        filter = vbNullString
        Debug.Print "Filter: NONE (full export)"
    Else
        filter = "[ReceivedTime] >= '" & Format$(LocalFromUTC(stateLastUTC), "yyyy-mm-dd hh:nn:ss") & "'"
        Debug.Print "Filter: " & filter
    End If
End Sub

Private Sub PrintSelectedFolders(ByVal folders As Collection)
    Debug.Print "Folders selected: " & folders.Count
    Dim f As Object, fidx As Long
    For Each f In folders
        fidx = fidx + 1
        Debug.Print "  " & fidx & ". " & f.FolderPath & " (" & f.Items.Count & " items)"
    Next f
End Sub

Private Sub ScanFolders(ByVal folders As Collection, ByVal filter As String, ByRef cfg As UCX_Config, ByRef idBuckets As Object, ByRef totalItems As Long)
    Debug.Print "Pass 1: Scanning folders for item IDs..."
    Dim f As Object, item As Object, view As Object, itms As Object
    totalItems = 0
    For Each f In folders
        If IsSearchFolder(f) And cfg.Full Then
            Warn "Running a full export on a search folder ('" & f.FolderPath & "'). The export will be scoped to the search folder's criteria, not all items in the store."
        End If
        If HasAnyPattern(cfg.IncludePathPattern) And Not LikeAny(f.FolderPath, cfg.IncludePathPattern) Then GoTo NextFolder
        If HasAnyPattern(cfg.ExcludePathPattern) And LikeAny(f.FolderPath, cfg.ExcludePathPattern) Then GoTo NextFolder
        
        Set itms = f.Items
        itms.Sort "[ReceivedTime]", True
        If Len(filter) > 0 And Not IsSearchFolder(f) Then Set view = itms.Restrict(filter) Else Set view = itms
        
        On Error GoTo ScanItemError
        For Each item In view
            If TypeName(item) = "MailItem" Then
                Dim convoIdRaw As Variant, entryId As String, storeId As String
                Dim convoKey As String
                entryId = "": storeId = "": convoKey = ""

                On Error Resume Next
                convoIdRaw = item.ConversationID
                entryId = NzStr(item.EntryID)
                storeId = NzStr(item.Parent.StoreID)
                If Err.Number <> 0 Then
                    Warn "Conversation metadata read failed in " & f.FolderPath & " (Type=" & TypeName(item) & ") - " & Err.Description
                    Err.Clear
                    On Error GoTo ScanItemError
                    GoTo NextItem
                End If

                convoKey = SafeConversationKey(convoIdRaw, entryId)
                On Error GoTo ScanItemError

                If Len(convoKey) > 0 Then
                    If Not idBuckets.Exists(convoKey) Then Set idBuckets(convoKey) = New Collection
                    Dim idPair As Object: Set idPair = CreateObject("Scripting.Dictionary")
                    idPair("EntryID") = entryId
                    idPair("StoreID") = storeId
                    idBuckets(convoKey).Add idPair
                    totalItems = totalItems + 1
                Else
                    Warn "Could not determine conversation key for an item in " & f.FolderPath & " (EntryID=" & Left$(entryId, 48) & ")"
                End If
            End If
NextItem:
            If totalItems Mod 500 = 0 Then DoEvents
        Next item
        On Error GoTo 0
        Debug.Print "  Scanned " & f.FolderPath & ", total items so far: " & totalItems
NextFolder:
    Next f
    Debug.Print "Pass 1 complete. Total items found: " & totalItems & " in " & idBuckets.Count & " conversations."
    ScanItemError:
        Warn "ScanFolders item error in " & f.FolderPath & " (Type=" & TypeName(item) & ", EntryID=" & Left$(NzStr(item.EntryID), 48) & ") - " & Err.Number & ": " & Err.Description
        Err.Clear
        Resume NextItem
End Sub

Private Function ExportConversations(ByVal idBuckets As Object, ByVal existing As Object, ByRef cfg As UCX_Config, _
                                    ByVal outRoot As String, ByVal blobDir As String, ByRef globalSha As Object) As Long
    Debug.Print "Pass 2: Exporting conversations one by one..."
    Dim key As Variant, exported As Long, processed As Long
    For Each key In idBuckets.Keys
        Dim itemIds As Collection: Set itemIds = idBuckets(key)
        Dim currentConvoMsgs As New Collection
        Dim idPair As Object
        For Each idPair In itemIds
            Dim mi As Object: Set mi = GetItemWithRetry(idPair("EntryID"), idPair("StoreID"), 3)
            If Not mi Is Nothing Then
                Dim meta As Object: Set meta = BuildFullMetadataFromItem(mi)
                If Not meta Is Nothing Then
                    If Not ShouldExcludeByPolicy(meta, mi.Parent.FolderPath, cfg) Then
                        currentConvoMsgs.Add meta
                    End If
                End If
            End If
        Next idPair
        
        If currentConvoMsgs.Count > 0 Then
            Dim convoKey As String: convoKey = currentConvoMsgs(1)("ConvoKey")
            exported = exported + ExportConversationGroup_LeavesOnly(convoKey, currentConvoMsgs, existing, cfg, outRoot, blobDir, globalSha)
        End If
        
        processed = processed + 1
        If processed Mod 10 = 0 Then Debug.Print "  Processed " & processed & "/" & idBuckets.Count & " conversations..."
        If processed Mod 50 = 0 Then DoEvents
    Next key
    Debug.Print "Pass 2 complete. Total conversations written: " & exported
    ExportConversations = exported
End Function

Private Sub TeardownExport(ByRef cfg As UCX_Config, ByVal outRoot As String, ByVal lockFile As String, ByVal folders As Collection, _
                        ByVal exported As Long, ByVal totalRows As Long, ByVal errorCount As Long, _
                        ByVal blobDir As String, ByRef globalSha As Object)
    If cfg.SaveState And Not cfg.NoState Then
        If errorCount = 0 And exported > 0 Then
            WriteState outRoot, NowUTC(), FoldersToPaths(folders)
            Debug.Print "State saved"
        ElseIf errorCount > 0 Then
            Warn "State not saved because errors occurred during the export. The next run will resume from the previous state."
        Else
            Debug.Print "State not saved because no new conversations were exported."
        End If
    End If
    
    If globalSha.Count > 0 Then
        Dim cachePath As String: cachePath = blobDir & "\" & BLOB_CACHE_FILE
        WriteTextFile cachePath, JsonSerializeDict(globalSha), True
        Debug.Print "Blob cache saved"
    End If

    Call ReleaseExportLock(lockFile)
    Debug.Print "Lock released"

    Dim summaryMsg As String, errorMsg As String
    If errorCount > 0 Then
        errorMsg = vbCrLf & "WARNING: " & errorCount & " items failed to process. Check Immediate Window (Ctrl+G) for details."
    End If

    If exported = 0 Then
        summaryMsg = "Done. No conversations written (already current or filtered)." & vbCrLf & _
               "Scanned " & totalRows & " messages from " & folders.Count & " folder(s)." & errorMsg
        Info "Done. No conversations written (already current or filtered)."
    Else
        summaryMsg = "Done. Conversations written or updated: " & exported & vbCrLf & _
               "Scanned " & totalRows & " messages from " & folders.Count & " folder(s)." & errorMsg
        Info "Done. Conversations written or updated: " & exported
    End If
    
    MsgBox summaryMsg & vbCrLf & "Output: " & outRoot, vbInformation, "UCX Export Complete"
End Sub

'========================= SCAN / BUCKETING ====================================

Private Function RowVal(ByVal r As Object, ByVal name As String) As String
    On Error Resume Next
    RowVal = CStr(r(name))
    If Err.Number <> 0 Then RowVal = "": Err.Clear
End Function

Private Function IsSearchFolder(ByVal f As Object) As Boolean
    On Error Resume Next
    IsSearchFolder = (LCase$(TypeName(f)) = "searchfolder")
    If Err.Number <> 0 Or IsSearchFolder = False Then
        IsSearchFolder = (InStr(1, LCase$(f.FolderPath), "\search", vbTextCompare) > 0)
        Err.Clear
    End If
End Function

' Optional GetTable path (kept for completeness)

' Process a single MailItem - leaves-friendly (no body cache)
Private Function BuildFullMetadataFromItem(ByVal mi As Object) As Object
    On Error Resume Next
    If mi Is Nothing Then Exit Function

    Dim meta As Object: Set meta = CreateObject("Scripting.Dictionary")
    Dim headersRaw As String: headersRaw = GetRawHeaders(mi)
    Dim headers As Object: Set headers = ParseHeaders(headersRaw)

    meta("EntryID") = SafeStr(mi, "EntryID")
    meta("StoreID") = SafeParentStoreID(mi)
    meta("FolderPath") = SafeFolderPath(mi.Parent)
    meta("Subject") = NzStr(mi.Subject)
    meta("SmartSubject") = SmartSubject(NzStr(mi.Subject))
    meta("From") = GetSenderSmtp(mi)
    meta("To") = GetRecipientsArray(mi, OL_TO)
    meta("CC") = GetRecipientsArray(mi, OL_CC)

    Dim pa As Object: Set pa = mi.PropertyAccessor
    Dim receivedDate As Date, sentDate As Date, rawDate As Date

    ' Outlook exposes ReceivedTime/SentOn in local time; normalize them to UTC for manifests
    receivedDate = ToUTC(NzDate(mi.ReceivedTime))
    If receivedDate = 0 And Not pa Is Nothing Then
        Err.Clear
        rawDate = NzDate(pa.GetProperty(PR_MESSAGE_DELIVERY_TIME))
        If Err.Number = 0 Then
            receivedDate = ToUTC(rawDate)
        Else
            Err.Clear
        End If
    End If

    sentDate = ToUTC(NzDate(mi.SentOn))
    If sentDate = 0 And Not pa Is Nothing Then
        Err.Clear
        rawDate = NzDate(pa.GetProperty(PR_CLIENT_SUBMIT_TIME))
        If Err.Number = 0 Then
            sentDate = ToUTC(rawDate)
        Else
            Err.Clear
        End If
    End If
    
    meta("ReceivedUtc") = receivedDate
    meta("SentOnUtc") = sentDate
    If receivedDate <> 0 Then meta("SortUtc") = receivedDate Else meta("SortUtc") = sentDate

    meta("MessageId") = HeaderVal(headers, "Message-ID")
    meta("InReplyTo") = HeaderVal(headers, "In-Reply-To")
    meta("References") = SplitRefs(HeaderVal(headers, "References"))
    
    meta("ConvoKey") = PickConvoKey(mi, headers, meta)

    Set BuildFullMetadataFromItem = meta
End Function


'======================= CONVERSATION EXPORT (LEAVES ONLY) =====================

Private Function ExportConversationGroup_LeavesOnly(ByVal convoKey As String, ByVal msgs As Collection, _
    ByRef existing As Object, ByRef cfg As UCX_Config, ByVal outRoot As String, _
    ByVal blobDir As String, ByRef globalShaToName As Object) As Long

    Dim sorted As Collection, leaves As Collection, newest As Object, existingPack As Object
    Dim smart As String, desiredName As String, convDir As String, cleanPath As String
    Dim startUtc As Date, lastUtc As Date
    Dim s As Object, attMeta As Object, participants As Object, manifest As Object, attList As Object, blobRefs As Collection, leafMsgs As Collection
    Dim e As Long, attCount As Long
    Dim fallbackScanErrors As Boolean: fallbackScanErrors = False
    Dim stage As String: stage = "init"

    On Error GoTo EH

    If msgs Is Nothing Or msgs.Count = 0 Then GoTo CleanExit

    stage = "sort"
    Set sorted = SortedCopyByKey(msgs, "SortUtc", True)
    If sorted Is Nothing Or sorted.Count = 0 Then
        Warn "ExportConversationGroup_LeavesOnly: no messages to export for conversation " & convoKey
        GoTo CleanExit
    End If
    stage = "compute_leaves"
    Set leaves = ComputeLeaves(sorted)
    If leaves.Count = 0 Then
        Warn "No leaves found for conversation (key: " & convoKey & "). Skipping export. This might indicate a circular reference."
        GoTo CleanExit
    End If

    stage = "select_newest"
    Set newest = sorted(sorted.Count)
    smart = newest("SmartSubject")
    startUtc = NzDate(sorted(1)("SortUtc"))
    lastUtc = NzDate(newest("SortUtc"))

    stage = "compute_dir"
    desiredName = ComputeConvoDirName(smart, lastUtc, convoKey, outRoot, cfg)
    If existing.Exists(convoKey) Then
        Set existingPack = existing(convoKey)
    End If

    stage = "ensure_conv_dir"
    If Not existingPack Is Nothing Then
        convDir = existingPack("Path")
        ' --- DELTA MODE: Merge historical messages from manifest ---
        Dim manifestPath As String: manifestPath = convDir & "\manifest.json"
        Dim fso As Object: Set fso = CreateObject("Scripting.FileSystemObject")
        If fso.FileExists(manifestPath) Then
            Dim manifestContent As String: manifestContent = ReadAllText(manifestPath)
            Dim historicalMsgs As Collection: Set historicalMsgs = JsonFindArrayOfObjects(manifestContent, "all_messages")
            Dim histMsg As Object, mergedIds As Object: Set mergedIds = CreateObject("Scripting.Dictionary")
            ' Add new messages to a dictionary for quick lookup
            For Each s In sorted
                mergedIds(s("EntryID")) = True
            Next s
            ' Add historical messages if they are not already in the new set
            For Each histMsg In historicalMsgs
                If Not mergedIds.Exists(histMsg("entry_id")) Then
                    Dim restoredMeta As Object: Set restoredMeta = CreateObject("Scripting.Dictionary")
                    restoredMeta("EntryID") = histMsg("entry_id")
                    restoredMeta("MessageId") = histMsg("id")
                    restoredMeta("InReplyTo") = histMsg("in_reply_to")
                    restoredMeta("References") = Split(histMsg("references"), " ")
                    restoredMeta("SortUtc") = SafeParseDate(histMsg("date"))
                    sorted.Add restoredMeta
                End If
            Next histMsg
            ' Re-sort the collection with the merged historical messages
            Set sorted = SortedCopyByKey(sorted, "SortUtc", True)
        End If
    Else
        convDir = EnsureFolderDeep(outRoot & "\" & desiredName)
    End If

    ' STREAM cleaned leaves only (memory-flat)
    cleanPath = convDir & "\Conversation.clean.txt"
    stage = "open_stream"
    Set s = CreateObject("ADODB.Stream")
    s.Type = 2
    s.Charset = "utf-8"
    s.Open

    Set attMeta = CreateObject("Scripting.Dictionary")
    attCount = 0

    stage = "process_leaves"
    For e = 1 To leaves.Count
        ProcessLeaf e, leaves, cfg, s, blobDir, globalShaToName, attMeta, attCount
    Next e

    s.SaveToFile cleanPath, 2
    s.Close

    ' --- Fallback: if no attachments were found on leaves, scan all messages ---
    stage = "fallback_scan"
    If attCount = 0 And CFG_AttFallbackAllIfNone And cfg.IncludeAttachments Then
        fallbackScanErrors = ScanAllMessagesForAttachments(sorted, blobDir, globalShaToName, cfg, attMeta, attCount)
    End If

    ' Minimal manifest focused on leaves
    stage = "manifest_build"
    Set participants = UniqueParticipants(sorted)
    Set manifest = CreateObject("Scripting.Dictionary")
    manifest("conversation_key") = convoKey
    manifest("smart_subject") = smart
    If startUtc <> 0 Then manifest("conversation_start_utc") = Format$(startUtc, "yyyy-mm-dd\Thh:nn:ss\Z") Else manifest("conversation_start_utc") = Null
    If lastUtc <> 0 Then manifest("last_message_utc") = Format$(lastUtc, "yyyy-mm-dd\Thh:nn:ss\Z") Else manifest("last_message_utc") = Null
    Set manifest("participants") = participants
    manifest("messages_count") = sorted.Count
    manifest("leaf_count") = leaves.Count
    manifest("leaves_only") = True

    stage = "manifest_attachments"
    Set attList = DictValues(attMeta)
    manifest("has_attachment") = (attCount > 0) Or fallbackScanErrors
    If fallbackScanErrors Then manifest("attachment_scan_incomplete") = True
    Set manifest("attachments") = attList

    ' Canonical blob paths (reindex-safe)
    stage = "manifest_blob_paths"
    Set blobRefs = New Collection
    Dim i As Long
    For i = 1 To attList.Count
        Dim attItem As Variant
        Set attItem = attList(i)
        If TypeName(attItem) = "Dictionary" Then
            If attItem.Exists("path_rel") Then
                blobRefs.Add attItem("path_rel")
            End If
        End If
    Next i
    Set manifest("blob_paths") = blobRefs

    ' Store metadata for ALL messages to support correct delta-mode leaf computation
    stage = "manifest_all_messages"
    Dim allMsgs As New Collection, msgData As Object, fullMsg As Object
    For Each fullMsg In sorted
        Set msgData = CreateObject("Scripting.Dictionary")
        msgData("entry_id") = fullMsg("EntryID")
        msgData("id") = fullMsg("MessageId")
        msgData("in_reply_to") = fullMsg("InReplyTo")
        If IsArray(fullMsg("References")) Then msgData("references") = Join(fullMsg("References"), " ") Else msgData("references") = ""
        msgData("date") = Format$(NzDate(fullMsg("SortUtc")), "yyyy-mm-dd\Thh:nn:ss\Z")
        allMsgs.Add msgData
    Next
    Set manifest("all_messages") = allMsgs

    stage = "write_manifest"
    WriteTextFile convDir & "\manifest.json", JsonSerializeDict(manifest), cfg.NoBomEncoding
    Info "Manifest written: " & convDir & "\manifest.json"
    ExportConversationGroup_LeavesOnly = 1

CleanExit:
    If Not s Is Nothing Then
        If s.State = 1 Then s.Close
        Set s = Nothing
    End If
    Set sorted = Nothing
    Set leaves = Nothing
    Set newest = Nothing
    Set existingPack = Nothing
    Set attMeta = Nothing
    Set participants = Nothing
    Set manifest = Nothing
    Set attList = Nothing
    Set blobRefs = Nothing
    Set leafMsgs = Nothing
    Exit Function

EH:
   g_errorCount = g_errorCount + 1
   Dim errMsg As String
   errMsg = "CRITICAL: Failed to export conversation group '" & convoKey & "' at stage '" & stage & "'." & vbCrLf & _
            "Error: " & Err.Number & " - " & Err.Description & vbCrLf & _
            "The empty directory may need to be manually deleted."
   Warn errMsg
   Resume CleanExit
End Function

Private Sub ProcessLeaf(ByVal e As Long, ByVal leaves As Collection, ByRef cfg As UCX_Config, ByVal s As Object, _
                        ByVal blobDir As String, ByRef globalShaToName As Object, ByRef attMeta As Object, ByRef attCount As Long)
    Dim mm As Object, leafText As String, clean As String, mi As Object, htmlBody As String, a As Object, md As Object

    On Error GoTo EH

    Set mm = leaves(e)

    leafText = ""
    If cfg.includeBodies Then
        If mm.Exists("EntryID") And mm.Exists("StoreID") Then
            leafText = NzStr(SafeGetBody(mm("EntryID"), mm("StoreID")))
        End If
        If Len(leafText) = 0 Then leafText = "(no body extracted)"
    End If

    If cfg.CleanBodies Then
        clean = CleanBodyForNLP(leafText)
    Else
        clean = leafText
    End If

    If Len(clean) < cfg.MinBodyChars Then GoTo CleanExit

    s.WriteText String$(80, "-") & vbCrLf
    If mm.Exists("SortUtc") Then
        s.WriteText Format$(NzDate(mm("SortUtc")), "yyyy-mm-dd\Thh:nn:ss\Z")
    End If
    If mm.Exists("From") Then
        s.WriteText " | From: " & LCase$(NzStr(mm("From")))
    End If
    If mm.Exists("To") Then
        s.WriteText " | To: " & JoinEmailsNormalized(mm("To")) & vbCrLf & vbCrLf
    End If
    s.WriteText clean & vbCrLf & vbCrLf

    ' Attachments for this leaf only (deduped via global blob store)
    If cfg.IncludeAttachments Then
        If mm.Exists("EntryID") And mm.Exists("StoreID") Then
            Set mi = GetItemWithRetry(CStr(mm("EntryID")), CStr(mm("StoreID")), 2)
        End If
        If Not mi Is Nothing Then
            If mi.Attachments.Count > 0 Then
                If mi.BodyFormat = OL_FORMAT_HTML Then htmlBody = mi.HTMLBody
                For Each a In mi.Attachments
                    Set md = SaveAttachmentToBlobStore(a, htmlBody, blobDir, globalShaToName, cfg, mm)
                    If Not md Is Nothing Then
                        attCount = attCount + 1
                        Set attMeta(attCount) = md
                    End If
                Next a
            End If
        End If
    End If

CleanExit:
    Set mm = Nothing
    Set mi = Nothing
    Set a = Nothing
    Set md = Nothing
    Exit Sub

EH:
    g_errorCount = g_errorCount + 1
    Warn "ProcessLeaf error: " & Err.Number & " - " & Err.Description
    Resume CleanExit
End Sub

Private Function ScanAllMessagesForAttachments(ByVal sorted As Collection, ByVal blobDir As String, ByRef globalShaToName As Object, _
                                            ByRef cfg As UCX_Config, ByRef attMeta As Object, ByRef attCount As Long) As Boolean
    Dim mmAll As Object, miAll As Object, md2 As Object, a2 As Object
    Dim scanCount As Long, scanFound As Long, attProcessed As Long
    Dim htmlAll As String
    Dim retrievalErrors As Boolean: retrievalErrors = False
    ScanAllMessagesForAttachments = False ' Default to success

    On Error GoTo EH

    Info "No non-inline, by-value attachments on leaves; scanning all " & sorted.Count & " messages in conversation..."

    For Each mmAll In sorted
        scanCount = scanCount + 1
        Set miAll = Nothing
        If mmAll.Exists("EntryID") And mmAll.Exists("StoreID") Then
            Set miAll = GetItemWithRetry(CStr(mmAll("EntryID")), CStr(mmAll("StoreID")), 2)
        End If

        If miAll Is Nothing Then
            retrievalErrors = True
        Else
            If miAll.Attachments.Count > 0 Then
                htmlAll = ""
                If miAll.BodyFormat = OL_FORMAT_HTML Then htmlAll = miAll.HTMLBody
                attProcessed = 0
                For Each a2 In miAll.Attachments
                    Set md2 = SaveAttachmentToBlobStore(a2, htmlAll, blobDir, globalShaToName, cfg, mmAll)
                    If Not md2 Is Nothing Then
                        attCount = attCount + 1
                        Set attMeta(attCount) = md2
                        scanFound = scanFound + 1
                        attProcessed = attProcessed + 1
                    End If
                Next a2
                If attProcessed > 0 Then
                    Info "Found " & attProcessed & " attachment(s) in message " & scanCount & " of " & sorted.Count
                End If
            End If
        End If
        Set miAll = Nothing

        ' Progress tracking and prevent UI freeze
        If scanCount Mod 10 = 0 Then
            DoEvents
            Info "Fallback scan progress: " & scanCount & "/" & sorted.Count & " messages scanned, " & scanFound & " attachments found"
        End If
    Next mmAll

    If retrievalErrors Then
        Warn "Fallback attachment scan was incomplete due to item retrieval errors."
        ScanAllMessagesForAttachments = True
    End If

    Info "Fallback scan complete: scanned " & scanCount & " messages, found " & scanFound & " attachments"

CleanExit:
    Set mmAll = Nothing
    Set miAll = Nothing
    Set md2 = Nothing
    Set a2 = Nothing
    Exit Function

EH:
    Warn "ScanAllMessagesForAttachments error: " & Err.Number & " - " & Err.Description
    ScanAllMessagesForAttachments = True ' Indicate failure
    Resume CleanExit
End Function

'============================= ATTACHMENTS / BLOBS =============================

Private Function BlobStoreRoot(ByVal outRoot As String) As String
    BlobStoreRoot = EnsureFolderDeep(outRoot & "\_blobs")
End Function

Private Sub SeedBlobMap(ByVal blobDir As String, ByRef shaToName As Object)
    On Error Resume Next
    Dim fso As Object: Set fso = CreateObject("Scripting.FileSystemObject")
    If Not fso.FolderExists(blobDir) Then Exit Sub

    ' Try to load from cache first
    Dim cachePath As String: cachePath = blobDir & "\" & BLOB_CACHE_FILE
    If fso.FileExists(cachePath) Then
        Dim jsonText As String: jsonText = ReadAllText(cachePath)
        Dim re As Object: Set re = CreateObject("VBScript.RegExp")
        re.Global = True: re.IgnoreCase = True
        re.pattern = """([^""]+)"":""([^""]+)"""
        Dim matches As Object: Set matches = re.Execute(jsonText)
        Dim m As Object
        For Each m In matches
            shaToName(m.SubMatches(0)) = m.SubMatches(1)
        Next m
        If shaToName.Count > 0 Then
            Debug.Print "Blob map seeded from cache: " & shaToName.Count & " entries"
            Exit Sub
        End If
    End If

    ' Fallback to scanning directory if cache is missing or empty
    Dim fi As Object, fo As Object: Set fo = fso.GetFolder(blobDir)
    For Each fi In fo.Files
        Dim nm As String: nm = fso.GetFileName(fi.Path)
        If LCase$(nm) = LCase$(BLOB_CACHE_FILE) Then GoTo NextFile
        Dim p As Long: p = InStrRev(nm, ".")
        Dim hexOnly As String
        If p > 0 Then hexOnly = Left$(nm, p - 1) Else hexOnly = nm
        If Len(hexOnly) = 64 Then shaToName(LCase$(hexOnly)) = nm
NextFile:
    Next fi
End Sub

Private Function SaveAttachmentToBlobStore(ByVal a As Object, ByVal htmlBody As String, _
                                           ByVal blobDir As String, ByRef shaToName As Object, _
                                           ByRef cfg As UCX_Config, _
                                           Optional ByVal msgMeta As Object = Nothing) As Object
    Dim pa As Object, md As Object, fi As Object
    Dim tmp As String, sha As String, original As String, ext As String, canonical As String, finalPath As String
    Dim tmpCreated As Boolean
    Dim method As Long
    Dim fso As Object: Set fso = CreateObject("Scripting.FileSystemObject")

    On Error GoTo EH

    If a Is Nothing Then
        Warn "SaveAttachmentToBlobStore: Attachment object is Nothing"
        GoTo CleanExit
    End If

    original = NzStr(a.FileName)

    ' Skip inline/hidden/etc. (uses AttachmentIsInline)
    If AttachmentIsInline(a, htmlBody, cfg) Then
        Info "Attachment skipped (inline): " & original
        GoTo CleanExit
    End If

    ' Only save "by value" attachments (cloud/by-reference cannot be saved via SaveAsFile)
    Set pa = a.PropertyAccessor
    If pa Is Nothing Then
        Warn "Failed to get PropertyAccessor for: " & original
        GoTo CleanExit
    End If

    On Error Resume Next ' PR_ATTACH_METHOD can fail
    method = -1
    method = pa.GetProperty("http://schemas.microsoft.com/mapi/proptag/0x37050003") ' PR_ATTACH_METHOD
    If Err.Number <> 0 Then
        Warn "Failed to read PR_ATTACH_METHOD for: " & original & " — " & Err.Description
        ' Assume by-value if property read fails (safest default)
        method = &H1&
        Err.Clear
    End If
    On Error GoTo EH

    If method <> &H1& Then   ' afByValue = 0x00000001
        Warn "Attachment skipped. It is not a standard file attachment (method=" & Hex$(method) & "). This may be a link to a cloud file (e.g., OneDrive) which is not supported for download: " & original
        GoTo CleanExit
    End If

    ' Save to a temporary file in the system temp folder
    Dim tempDir As String: tempDir = fso.GetSpecialFolder(2) ' 2 = TemporaryFolder
    tmp = fso.BuildPath(tempDir, "ucx_" & CreateRandomName() & ".tmp")
    a.SaveAsFile tmp
    tmpCreated = True

    ' Verify temp file was created and has content
    If Not fso.FileExists(tmp) Or fso.GetFile(tmp).Size = 0 Then
        Warn "SaveAsFile failed to create a valid temp file for: " & original
        GoTo CleanExit
    End If

    ' Calculate SHA-256 hash of the file
    sha = SHA256_File(tmp)
    ext = GetExtension(SanitizeName(original))

    If Len(sha) > 0 Then
        ' HASH SUCCEEDED: Use content-addressable name
        canonical = LCase$(sha) & ext
        finalPath = fso.BuildPath(blobDir, canonical)

        If Not shaToName.Exists(LCase$(sha)) Then
            If fso.FileExists(finalPath) Then
                KillSafe tmp ' Already exists, so delete temp file
                tmpCreated = False
            Else
                fso.MoveFile tmp, finalPath
                tmpCreated = False
            End If
            shaToName(LCase$(sha)) = canonical
            Info "Blob saved: " & finalPath & " (" & original & ")"
        Else
            Info "Blob deduplicated: " & original & " (SHA256: " & Left$(sha, 12) & "...)"
            KillSafe tmp ' Deduplicated, so delete temp file
            tmpCreated = False
        End If
    Else
        ' HASH FAILED: Skip saving the attachment as it cannot be reliably deduplicated.
        Warn "SHA256 calculation failed for: " & original & ". The attachment will be skipped."
        GoTo CleanExit
    End If

    ' Build metadata with validation
    Set fi = fso.GetFile(finalPath)
    If fi Is Nothing Then
        Warn "Failed to stat blob file: " & finalPath
        GoTo CleanExit
    End If

    Set md = CreateObject("Scripting.Dictionary")
    md("filename") = canonical
    md("original_name") = original
    md("extension") = ext
    md("filetype") = Null
    md("size_bytes") = CLng(fi.Size)
    md("sha256") = LCase$(sha)
    md("path_rel") = "_blobs\" & canonical
    If Not msgMeta Is Nothing Then
        If msgMeta.Exists("MessageId") Then md("source_message_id") = msgMeta("MessageId")
    End If

    Set SaveAttachmentToBlobStore = md

CleanExit:
    Set pa = Nothing
    Set md = Nothing
    Set fi = Nothing
    Set fso = Nothing
    If tmpCreated Then
        If Len(tmp) > 0 Then KillSafe tmp
    End If
    Exit Function

EH:
    g_errorCount = g_errorCount + 1
    Warn "SaveAttachmentToBlobStore failed for: " & original & " (Error " & Err.Number & ": " & Err.Description & ")"
    Resume CleanExit
End Function

'----------------------------- Inline detection --------------------------------

Private Function AttachmentIsInline(ByVal a As Object, ByVal html As String, ByRef cfg As UCX_Config) As Boolean
    On Error Resume Next
    Dim pa As Object: Set pa = a.PropertyAccessor
    Dim propArray As Variant, results As Variant
    propArray = Array(PR_ATTACH_CIDW, PR_ATTACH_CIDA, PR_ATTACHMENT_HIDDEN, PR_RENDERING_POSITION, PR_ATTACH_CONTENT_DISP, PR_ATTACH_FLAGS, "http://schemas.microsoft.com/mapi/proptag/0x370E001E")
    results = pa.GetProperties(propArray)
    
    Dim cid As String: cid = NzStr(results(0))
    If Len(cid) = 0 Then cid = NzStr(results(1))

    If Not IsError(results(2)) And CBool(results(2)) = True Then AttachmentIsInline = True: Exit Function

    If Not IsError(results(3)) And CLng(results(3)) <> -1 Then AttachmentIsInline = True: Exit Function

    If Not IsError(results(4)) And LCase$(NzStr(results(4))) = "inline" Then AttachmentIsInline = True: Exit Function

    If Not IsError(results(5)) Then
        Dim flags As Long: flags = CLng(results(5))
        If (flags And &H1) <> 0 Or (flags And &H2) <> 0 Then AttachmentIsInline = True: Exit Function
    End If

    Dim n As String: n = LCase$(NzStr(a.FileName))
    If n = "winmail.dat" Or n = "win.dat" Or n Like "*.tnef" Then AttachmentIsInline = True: Exit Function

    If Not IsError(results(6)) And (LCase$(NzStr(results(6))) = "application/ms-tnef" Or LCase$(NzStr(results(6))) = "application/vnd.ms-tnef") Then AttachmentIsInline = True: Exit Function

    If Len(cid) > 0 And Len(html) > 0 Then
        Dim lc As String: lc = LCase$(cid)
        Dim h As String: h = LCase$(html)
        If InStr(1, h, "cid:" & lc, vbBinaryCompare) > 0 Or InStr(1, h, "cid:<" & lc & ">", vbBinaryCompare) > 0 Then
            AttachmentIsInline = True: Exit Function
        End If
    End If

    If cfg.SkipInlineLogos Then
        If n Like "*.p7s" Then AttachmentIsInline = True: Exit Function
        If (n Like "*.png" Or n Like "*.gif" Or n Like "*.jpg" Or n Like "*.jpeg" Or n Like "*.bmp" Or n Like "*.ico") Then
            If (n Like "*logo*" Or n Like "image#*" Or n Like "image*") And (a.Size < (cfg.InlineLogoMaxKB * 1024)) Then
                AttachmentIsInline = True: Exit Function
            End If
        End If
    End If
End Function

'============================= UTILITIES =======================================

Private Function FoldersToPaths(ByVal coll As Collection) As Variant
    Dim arr() As String
    ReDim arr(0 To coll.Count - 1)
    Dim i As Long
    For i = 1 To coll.Count
        arr(i - 1) = coll(i).FolderPath
    Next i
    FoldersToPaths = arr
End Function

Private Function NowUTC() As Date: NowUTC = ToUTC(Now): End Function

Private Function ToUTC(ByVal d As Date) As Date
    If d = 0 Then ToUTC = 0: Exit Function
    Dim tz As TIME_ZONE_INFORMATION, stLocal As SYSTEMTIME, stUtc As SYSTEMTIME
    GetTimeZoneInformation tz
    DateToSystemTime d, stLocal
    If TzSpecificLocalTimeToSystemTime(tz, stLocal, stUtc) <> 0 Then
        ToUTC = SystemTimeToDate(stUtc)
    Else
        ToUTC = d
    End If
End Function

Private Function LocalFromUTC(ByVal d As Date) As Date
    If d = 0 Then LocalFromUTC = 0: Exit Function
    Dim tz As TIME_ZONE_INFORMATION, stLocal As SYSTEMTIME, stUtc As SYSTEMTIME
    GetTimeZoneInformation tz
    DateToSystemTime d, stUtc
    If SystemTimeToTzSpecificLocalTime(tz, stUtc, stLocal) <> 0 Then
        LocalFromUTC = SystemTimeToDate(stLocal)
    Else
        LocalFromUTC = d
    End If
End Function

Private Sub DateToSystemTime(ByVal dt As Date, ByRef st As SYSTEMTIME)
    st.wYear = Year(dt)
    st.wMonth = Month(dt)
    st.wDay = Day(dt)
    st.wHour = Hour(dt)
    st.wMinute = Minute(dt)
    st.wSecond = Second(dt)
    st.wMilliseconds = 0
End Sub

Private Function SystemTimeToDate(ByRef st As SYSTEMTIME) As Date
    SystemTimeToDate = DateSerial(st.wYear, st.wMonth, st.wDay) + _
                       TimeSerial(st.wHour, st.wMinute, st.wSecond)
End Function

' ---- ISO-8601 parsing ----
Private Function ParseIso8601Utc(ByVal s As String) As Date
    Dim re As Object: Set re = CreateObject("VBScript.RegExp")
    re.Global = False: re.IgnoreCase = True
    re.pattern = "^\s*(\d{4})-(\d{2})-(\d{2})[T\s](\d{2}):(\d{2}):(\d{2})Z\s*$"
    Dim m As Object: Set m = re.Execute(s)
    If m.Count > 0 Then
        ParseIso8601Utc = DateSerial(CInt(m(0).SubMatches(0)), CInt(m(0).SubMatches(1)), CInt(m(0).SubMatches(2))) + _
                          TimeSerial(CInt(m(0).SubMatches(3)), CInt(m(0).SubMatches(4)), CInt(m(0).SubMatches(5)))
    Else
        On Error Resume Next
        ParseIso8601Utc = CDate(s)
        On Error GoTo 0
    End If
End Function

Private Function SafeParseDate(ByVal s As String) As Date
    SafeParseDate = ParseIso8601Utc(s)
End Function

Private Function NzDate(ByVal d As Date) As Date
    If d = 0 Then
        NzDate = 0
    Else
        NzDate = d
    End If
End Function

Private Function NzStr(ByVal s As Variant) As String
    If IsNull(s) Or IsEmpty(s) Then
        NzStr = ""
    Else
        NzStr = CStr(s)
    End If
End Function

Private Sub AssertOffline()
    On Error Resume Next
    Dim s As Object: Set s = Application.Session
    Dim isOffline As Boolean
    If s Is Nothing Then Exit Sub
    If s.Offline Then
        isOffline = True
    Else
        Dim mode As Long: mode = s.ExchangeConnectionMode
        If mode = OLCM_CachedOffline Or mode = OLCM_Disconnected Then isOffline = True
    End If
    On Error GoTo 0
    If Not isOffline Then
        Err.Raise vbObjectError + 100, , "Outlook is not offline. Switch to 'Work Offline' (or set CFG_OfflineStrict=False)."
    End If
End Sub

Private Function DesktopOutRoot() As String
    Dim ws As Object: Set ws = CreateObject("WScript.Shell")
    DesktopOutRoot = EnsureFolderDeep(ws.SpecialFolders("Desktop") & "\Outlook")
End Function

Private Function ChooseRoot(ByVal s As String) As String
    If Len(Trim$(s)) > 0 Then
        ChooseRoot = s
    Else
        ChooseRoot = DesktopOutRoot()
    End If
End Function

' ---- UNC-aware deep folder creation ----
Private Function EnsureFolderDeep(ByVal path As String) As String
    Dim fso As Object: Set fso = CreateObject("Scripting.FileSystemObject")
    If fso.FolderExists(path) Then EnsureFolderDeep = path: Exit Function

    Dim parts As Variant: parts = Split(path, "\")
    Dim cur As String, i As Long

    If Left$(path, 2) = "\\" Then
        If UBound(parts) < 3 Then Err.Raise vbObjectError + 701, , "UNC path missing share: " & path
        cur = "\\" & parts(2) & "\" & parts(3)  ' \\server\share
        i = 4
    Else
        cur = parts(0)
        i = 1
    End If

    For i = i To UBound(parts)
        If Len(parts(i)) > 0 Then
            cur = cur & "\" & parts(i)
            If Not fso.FolderExists(cur) Then fso.CreateFolder cur
        End If
    Next i

    EnsureFolderDeep = path
End Function

'--------------------- Folder resolution ---------------------------------------

Private Function ResolveFolders(ByVal spec As Variant, ByVal pick As Boolean) As Collection
    Dim result As New Collection
    If Application.Session Is Nothing Then
        Err.Raise vbObjectError + 999, "ResolveFolders", "Application.Session is Nothing"
    End If

    If pick Or IsEmpty(spec) Or IsNull(spec) Then
        Do
            Dim f As Object
            Set f = Application.Session.PickFolder
            If f Is Nothing Then Exit Do
            result.Add f
        Loop While MsgBox("Pick another folder?", vbQuestion + vbYesNo) = vbYes
    Else
        Dim i As Long
        For i = LBound(spec) To UBound(spec)
            Dim one As String: one = CStr(spec(i))
            Dim mf As Object: Set mf = FindFolderByPath(one)
            If Not mf Is Nothing Then result.Add mf Else Warn "Folder not found: " & one
        Next i
        If result.Count = 0 Then
            Dim f2 As Object: Set f2 = Application.Session.PickFolder
            If Not f2 Is Nothing Then result.Add f2
        End If
    End If
    Set ResolveFolders = result
End Function

Private Function FindFolderByPath(ByVal path As String) As Object
    On Error Resume Next
    If Application.Session Is Nothing Then Exit Function
    If Left$(path, 2) = "\\" Then path = Mid$(path, 3)
    Dim parts As Variant: parts = Split(path, "\")
    Dim st As Object
    For Each st In Application.Session.Stores
        If LCase$(st.DisplayName) = LCase$(parts(0)) Then
            Dim f As Object: Set f = st.GetRootFolder
            Dim i As Long
            For i = 1 To UBound(parts)
                Set f = f.Folders(parts(i))
                If f Is Nothing Then Exit For
            Next i
            If Not f Is Nothing Then Set FindFolderByPath = f: Exit Function
        End If
    Next st
    Set FindFolderByPath = Nothing
End Function

'---------------------- Headers / keys -----------------------------------------

Private Function GetRawHeaders(ByVal mi As Object) As String
    On Error Resume Next
    If mi Is Nothing Then Exit Function
    Dim pa As Object: Set pa = mi.PropertyAccessor
    If pa Is Nothing Then Exit Function
    Dim raw As String: raw = NzStr(pa.GetProperty(PR_HDRS_W))
    If Len(raw) = 0 Then raw = NzStr(pa.GetProperty(PR_HDRS_A))
    GetRawHeaders = raw
End Function

Private Function ParseHeaders(ByVal raw As String) As Object
    Dim dict As Object: Set dict = CreateObject("Scripting.Dictionary")
    If Len(raw) = 0 Then Set ParseHeaders = dict: Exit Function

    Dim lines As Variant: lines = Split(Replace(raw, vbCrLf, vbLf), vbLf)
    Dim i As Long, lastKey As String
    For i = LBound(lines) To UBound(lines)
        Dim ln As String: ln = lines(i)
        If Len(ln) = 0 Then GoTo cont
        If (Left$(ln, 1) = " " Or Left$(ln, 1) = vbTab) And Len(lastKey) > 0 Then
            dict(lastKey) = dict(lastKey) & " " & Trim$(ln): GoTo cont
        End If
        Dim p As Long: p = InStr(1, ln, ":", vbBinaryCompare)
        If p > 0 Then
            Dim k As String, v As String
            k = Trim$(Left$(ln, p - 1)): v = Trim$(Mid$(ln, p + 1))
            lastKey = k
            dict(k) = v
        End If
cont:
    Next i

    Set ParseHeaders = dict
End Function

Private Function HeaderVal(ByVal headers As Object, ByVal key As String) As String
    Dim k As Variant
    For Each k In headers.Keys
        If LCase$(CStr(k)) = LCase$(key) Then HeaderVal = headers(k): Exit Function
    Next k
    HeaderVal = vbNullString
End Function

Private Function SafeConversationKey(ByVal convoVariant As Variant, ByVal entryId As String) As String
    On Error GoTo Fallback
    If IsNull(convoVariant) Or IsEmpty(convoVariant) Then GoTo Fallback

    If VarType(convoVariant) = vbString Then
        SafeConversationKey = Trim$(CStr(convoVariant))
    ElseIf IsArray(convoVariant) Then
        SafeConversationKey = "cidbytes:" & BytesToHex(convoVariant)
    Else
        SafeConversationKey = CStr(convoVariant)
    End If

    If Len(SafeConversationKey) = 0 Then GoTo Fallback
    Exit Function

Fallback:
    If Len(entryId) > 0 Then
        SafeConversationKey = "entry:" & entryId
    Else
        SafeConversationKey = ""
    End If
End Function

Private Function SplitRefs(ByVal refs As String) As Variant
    If Len(Trim$(refs)) = 0 Then SplitRefs = Array(): Exit Function
    SplitRefs = Split(Trim$(refs), " ")
End Function

Private Function SmartSubject(ByVal s As String) As String
    Dim t As String: t = Trim$(s)
    Dim prefixes As Variant: prefixes = Array("re: ", "fw: ", "fwd: ", "sv: ", "aw: ", "wg: ", "antw: ")
    Dim changed As Boolean
    Do
        changed = False
        Dim i As Long
        For i = LBound(prefixes) To UBound(prefixes)
            If LCase$(Left$(t, Len(prefixes(i)))) = prefixes(i) Then
                t = Mid$(t, Len(prefixes(i)) + 1)
                changed = True
                Exit For
            End If
        Next i
    Loop While changed
    If Len(t) = 0 Then SmartSubject = "_" Else SmartSubject = t
End Function

Private Function NormalizeEmail(ByVal s As String) As String
    Dim m1 As Long, m2 As Long
    s = Trim$(s)
    m1 = InStr(1, s, "<", vbTextCompare)
    m2 = InStr(1, s, ">", vbTextCompare)
    If m1 > 0 And m2 > m1 Then
        NormalizeEmail = LCase$(Trim$(Mid$(s, m1 + 1, m2 - m1 - 1)))
    Else
        NormalizeEmail = LCase$(s)
    End If
End Function

Private Function GetSenderSmtp(ByVal mi As Object) As String
    On Error Resume Next

    ' If already SMTP, return directly
    Dim typ As String: typ = NzStr(CallByName(mi, "SenderEmailType", VbGet))
    If LCase$(typ) = "smtp" Then
        GetSenderSmtp = NzStr(mi.SenderEmailAddress)
        If Len(GetSenderSmtp) > 0 Then Exit Function
    End If

    ' Try Exchange user / DL
    Dim ae As Object: Set ae = mi.Sender
    If Not ae Is Nothing Then
        If ae.Type = "EX" Then
            Dim ex As Object: Set ex = ae.GetExchangeUser
            If Not ex Is Nothing Then
                If Len(NzStr(ex.PrimarySmtpAddress)) > 0 Then GetSenderSmtp = ex.PrimarySmtpAddress: Exit Function
            End If
            Dim dl As Object: Set dl = ae.GetExchangeDistributionList
            If Not dl Is Nothing Then
                If Len(NzStr(dl.PrimarySmtpAddress)) > 0 Then GetSenderSmtp = dl.PrimarySmtpAddress: Exit Function
            End If
            ' Fallback to PR_SMTP_ADDRESS on AddressEntry
            Dim pa As Object: Set pa = ae.PropertyAccessor
            Dim smtp As String: smtp = NzStr(pa.GetProperty(PR_SMTP_ADDRESS))
            If Len(smtp) > 0 Then GetSenderSmtp = smtp: Exit Function
        End If
        If Len(NzStr(ae.Address)) > 0 Then GetSenderSmtp = ae.Address: Exit Function
    End If

    ' Final fallback
    GetSenderSmtp = NzStr(mi.SenderEmailAddress)
End Function

Private Function GetRecipientSmtp(ByVal r As Object) As String
    On Error Resume Next
    Dim ae As Object: Set ae = r.AddressEntry
    If Not ae Is Nothing Then
        If ae.Type = "EX" Then
            Dim ex As Object: Set ex = ae.GetExchangeUser
            If Not ex Is Nothing Then GetRecipientSmtp = ex.PrimarySmtpAddress: Exit Function
            Dim dl As Object: Set dl = ae.GetExchangeDistributionList
            If Not dl Is Nothing Then GetRecipientSmtp = dl.PrimarySmtpAddress: Exit Function
            ' Fallback via PR_SMTP_ADDRESS on AddressEntry
            Dim pa As Object: Set pa = ae.PropertyAccessor
            Dim smtp As String: smtp = NzStr(pa.GetProperty(PR_SMTP_ADDRESS))
            If Len(smtp) > 0 Then GetRecipientSmtp = smtp: Exit Function
        End If
        If Len(NzStr(ae.Address)) > 0 Then GetRecipientSmtp = ae.Address: Exit Function
    End If
    GetRecipientSmtp = ""
End Function

Private Function GetRecipientsArray(ByVal mi As Object, ByVal typ As Long) As Object
    Dim arr As Object: Set arr = CreateObject("Scripting.Dictionary")
    If mi Is Nothing Then Set GetRecipientsArray = arr: Exit Function
    On Error Resume Next
    Dim r As Object
    For Each r In mi.Recipients
        If Not r Is Nothing Then
            If r.Type = typ Then
                Dim o As Object: Set o = CreateObject("Scripting.Dictionary")
                o("name") = NzStr(r.Name)
                o("smtp") = GetRecipientSmtp(r)
                If Len(o("smtp")) = 0 Then o("smtp") = NormalizeEmail(NzStr(r.Address))
                If Len(o("smtp")) > 0 Then
                    arr(arr.Count + 1) = o
                End If
            End If
        End If
    Next r
    On Error GoTo 0
    Set GetRecipientsArray = arr
End Function

Private Function PickConvoKey(ByVal mi As Object, ByVal headers As Object, ByVal meta As Object) As String
    On Error Resume Next
    Dim pa As Object: Set pa = mi.PropertyAccessor
    Dim v As Variant: v = pa.GetProperty(PR_CONV_ID)
    If Not IsEmpty(v) Then
        Dim b64 As String: b64 = Base64OfBytes(v)
        If Len(b64) > 0 Then PickConvoKey = "cid:" & b64: Exit Function
    End If
    Dim v2 As Variant: v2 = pa.GetProperty(PR_CONV_INDEX)
    If Not IsEmpty(v2) Then
        Dim b64_2 As String: b64_2 = Base64OfBytes(v2)
        If Len(b64_2) >= 22 Then PickConvoKey = "ti:" & Left$(b64_2, 22): Exit Function
    End If
    Dim refs As Variant: refs = SplitRefs(HeaderVal(headers, "References"))
    Dim irt As String: irt = HeaderVal(headers, "In-Reply-To")
    Dim top As String
    If UBoundSafe(refs) >= 0 Then
        top = refs(0)
    Else
        top = irt
    End If
    If Len(top) > 0 Then PickConvoKey = "ref:" & top: Exit Function
    Dim subu As String: subu = SmartSubject(NzStr(meta("Subject")))
    Dim fromE As String: fromE = NormalizeEmail(NzStr(meta("From")))
    Dim toS As String: toS = JoinEmailsNormalized(meta("To"))
    Dim datePart As String
    If meta("SortUtc") <> 0 Then datePart = Format(meta("SortUtc"), "yyyy-mm-dd")
    Dim entryIdPart As String: entryIdPart = meta("EntryID")
    PickConvoKey = "sub:" & SHA256_StringUTF8(subu & "|" & fromE & "|" & toS & "|" & datePart & "|" & entryIdPart)
End Function

Private Function UBoundSafe(ByVal arr As Variant) As Long
    On Error Resume Next: UBoundSafe = -1: If IsArray(arr) Then UBoundSafe = UBound(arr)
End Function

'------------------------- Policies / filters ----------------------------------

Private Function ShouldExcludeByPolicy(ByVal meta As Object, ByVal folderPath As String, ByRef cfg As UCX_Config) As Boolean
    If HasAnyPattern(cfg.IncludePathPattern) Then If Not LikeAny(folderPath, cfg.IncludePathPattern) Then ShouldExcludeByPolicy = True: Exit Function
    If HasAnyPattern(cfg.ExcludePathPattern) Then If LikeAny(folderPath, cfg.ExcludePathPattern) Then ShouldExcludeByPolicy = True: Exit Function

    Dim fromAddr As String: fromAddr = NormalizeEmail(NzStr(meta("From")))
    If HasAnyPattern(cfg.AllowSenders) Then If Not AddressMatches(fromAddr, cfg.AllowSenders) Then ShouldExcludeByPolicy = True: Exit Function
    If HasAnyPattern(cfg.RejectSenders) Then If AddressMatches(fromAddr, cfg.RejectSenders) Then ShouldExcludeByPolicy = True: Exit Function
    If HasAnyPattern(cfg.RejectDomains) Then
        Dim i As Long
        For i = LBound(cfg.RejectDomains) To UBound(cfg.RejectDomains)
            If Right$(fromAddr, Len(cfg.RejectDomains(i)) + 1) = "@" & LCase$(cfg.RejectDomains(i)) Then ShouldExcludeByPolicy = True: Exit Function
        Next i
    End If
    If HasAnyPattern(cfg.RejectSubjectRegex) Then If AnyRegexMatch(cfg.RejectSubjectRegex, NzStr(meta("Subject"))) Then ShouldExcludeByPolicy = True: Exit Function

    ' Keep compatibility signatures — actual detection is handled by sender/domain/regex
    If cfg.ExcludeMarketing And IsMarketingMessage(ParseHeaders("")) Then
        ' no-op
    End If
    If cfg.ExcludeAutoGenerated And IsAutoGeneratedMessage(ParseHeaders("")) Then
        ' no-op
    End If
End Function

Private Function HasAnyPattern(ByVal v As Variant) As Boolean
    On Error Resume Next
    HasAnyPattern = Not (IsEmpty(v) Or IsNull(v) Or (IsArray(v) And (UBound(v) < LBound(v))))
End Function

Private Function LikeAny(ByVal s As String, ByVal arr As Variant) As Boolean
    Dim i As Long
    For i = LBound(arr) To UBound(arr)
        If s Like CStr(arr(i)) Then LikeAny = True: Exit Function
    Next i
End Function

Private Function AddressMatches(ByVal addr As String, ByVal arr As Variant) As Boolean
    Dim i As Long, y As String
    For i = LBound(arr) To UBound(arr)
        y = NormalizeEmail(CStr(arr(i)))
        If addr = y Then AddressMatches = True: Exit Function
        If Left$(y, 1) = "@" Then
            If addr Like "*" & y Then
                AddressMatches = True: Exit Function
            End If
        End If
    Next i
End Function

Private Function AnyRegexMatch(ByVal patterns As Variant, ByVal text As String) As Boolean
    On Error Resume Next
    Dim re As Object: Set re = CreateObject("VBScript.RegExp")
    re.IgnoreCase = True: re.Global = False
    Dim i As Long
    For i = LBound(patterns) To UBound(patterns)
        Dim pat As String: pat = CStr(patterns(i))
        If Len(pat) = 0 Then GoTo NextPattern
        re.pattern = pat
        If Err.Number <> 0 Then
            Warn "Invalid regex pattern: " & pat
            Err.Clear
            GoTo NextPattern
        End If
        If re.Test(text) Then AnyRegexMatch = True: Exit Function
NextPattern:
    Next i
    On Error GoTo 0
End Function

' ---- Simplified marketing/auto-generated placeholders for signature compat ----
Private Function IsMarketingMessage(ByVal headers As Object) As Boolean
    IsMarketingMessage = False
End Function

Private Function IsAutoGeneratedMessage(ByVal headers As Object) As Boolean
    IsAutoGeneratedMessage = False
End Function

'---------------------- Cleaning pipeline --------------------------------------

Private Function NormalizeWhitespace(ByVal s As String) As String
    Dim x As String: x = Replace(s, vbCr, "")
    x = ReplaceMultiple(x, Array(vbTab, "  ", "   ", "    "), " ")
    NormalizeWhitespace = Trim$(Replace(x, " " & vbLf, vbLf))
End Function

Private Function StripQuotedSections(ByVal s As String) As String
    Dim lines As Variant: lines = Split(Replace(s, vbCrLf, vbLf), vbLf)
    Dim out As New Collection, i As Long
    For i = LBound(lines) To UBound(lines)
        Dim L As String: L = lines(i)
        If L Like ">*" Then GoTo nxt
        If L Like "On * wrote:*" Then GoTo nxt
        If L Like "From: *" Then GoTo nxt
        out.Add L
nxt:
    Next i
    StripQuotedSections = JoinCollection(out, vbLf)
End Function

Private Function StripSignature(ByVal s As String) As String
    Dim lines As Variant: lines = Split(Replace(s, vbCrLf, vbLf), vbLf)
    Dim i As Long
    For i = UBound(lines) To LBound(lines) Step -1
        If Trim$(lines(i)) = "--" Then
            If i > 0 Then
                Dim j As Long, out As New Collection
                For j = LBound(lines) To i - 1: out.Add lines(j): Next j
                StripSignature = JoinCollection(out, vbLf)
                Exit Function
            End If
        End If
    Next i
    StripSignature = s
End Function

Private Function StripDisclaimers(ByVal s As String) As String
    Dim patterns As Variant
    patterns = Array( _
        "This e-mail.*confidential", _
        "CONFIDENTIALITY NOTICE", _
        "This message.*intended recipient", _
        "If you.*not the intended recipient" _
    )

    Dim result As String: result = s
    Dim re As Object: Set re = CreateObject("VBScript.RegExp")
    re.Global = True
    re.IgnoreCase = True

    Dim i As Long
    For i = LBound(patterns) To UBound(patterns)
        re.pattern = patterns(i) & "[\s\S]*$"
        result = re.Replace(result, "")
    Next i

    StripDisclaimers = Trim$(result)
End Function

Private Function CleanBodyForNLP(ByVal body As String) As String
    Dim b As String: b = NormalizeWhitespace(body)
    b = StripQuotedSections(b)
    b = StripSignature(b)
    b = StripDisclaimers(b)
    CleanBodyForNLP = Trim$(b)
End Function

'---------------------- Naming / paths -----------------------------------------

Private Function SanitizeName(ByVal s As String) As String
    If Len(Trim$(s)) = 0 Then s = "unnamed"
    s = Replace(s, "..", "_")
    s = Replace(s, "~", "_")
    Dim bad As Variant: bad = Array("<", ">", ":", """", "/", "\", "|", "?", "*")
    Dim i As Long
    For i = LBound(bad) To UBound(bad)
        s = Replace(s, CStr(bad(i)), "_")
    Next i
    Do While Len(s) > 0 And (Right$(s, 1) = "." Or Right$(s, 1) = " "): s = Left$(s, Len(s) - 1): Loop
    If Len(s) = 0 Then s = "unnamed"
    Dim reserved As Variant: reserved = Array("CON", "PRN", "AUX", "NUL", "COM1", "COM2", "COM3", "COM4", "COM5", "COM6", "COM7", "COM8", "COM9", "LPT1", "LPT2", "LPT3", "LPT4", "LPT5", "LPT6", "LPT7", "LPT8", "LPT9")
    Dim upper As String: upper = UCase$(s)
    Dim r As Long
    For r = LBound(reserved) To UBound(reserved)
        If upper = reserved(r) Or upper Like reserved(r) & ".*" Then s = "_" & s: Exit For
    Next r
    SanitizeName = s
End Function

Private Function OptimizeNameForBase(ByVal basePath As String, ByVal nameOnly As String, ByRef cfg As UCX_Config) As String
    Dim budget As Long
    If cfg.EnableLongPaths Then
        budget = 32000
    Else
        budget = cfg.MaxPathLength
    End If
    Dim allow As Long: allow = budget - Len(basePath) - 1
    If allow < 1 Then allow = 1
    If Len(nameOnly) > allow Then
        OptimizeNameForBase = Left$(nameOnly, allow)
    Else
        OptimizeNameForBase = nameOnly
    End If
End Function

Private Function ShortKey(ByVal hex As String) As String
    If Len(hex) = 0 Then
        ShortKey = "0000000"
    Else
        ShortKey = Left$(hex, 7)
    End If
End Function

Private Function ComputeConvoDirName(ByVal smart As String, ByVal lastUtc As Date, ByVal key As String, ByVal outRoot As String, ByRef cfg As UCX_Config) As String
    Dim nameOnly As String
    Dim hashPart As String: hashPart = SHA256_StringUTF8(key)
    If Len(hashPart) = 0 Then
        Warn "SHA256 hash failed for key '" & key & "'. Using deterministic fallback for directory name."
        hashPart = "fallback_" & Replace(Timer, ".", "") & "_" & ShortKey(key)
    End If
    nameOnly = SanitizeName(smart) & " [" & ShortKey(hashPart) & "]"
    ComputeConvoDirName = OptimizeNameForBase(outRoot, nameOnly, cfg)
End Function

'---------------------- Leaves selection ---------------------------------------

Private Function ComputeLeaves(ByVal msgs As Collection) As Collection
    Dim refs As Object: Set refs = CreateObject("Scripting.Dictionary")
    Dim i As Long, m As Object, j As Long, arr As Variant
    For i = 1 To msgs.Count
        Set m = msgs(i)
        If m.Exists("References") Then
            arr = m("References")
            If IsArray(arr) Then
                For j = LBound(arr) To UBound(arr)
                    If Len(arr(j)) > 0 Then refs(LCase$(arr(j))) = True
                Next j
            End If
        End If
        If m.Exists("InReplyTo") Then
            If Len(NzStr(m("InReplyTo"))) > 0 Then refs(LCase$(m("InReplyTo"))) = True
        End If
    Next i
    Dim out As New Collection
    For i = 1 To msgs.Count
        Set m = msgs(i)
        Dim mid As String: mid = LCase$(NzStr(m("MessageId")))
        If Len(mid) = 0 Or Not refs.Exists(mid) Then out.Add m
    Next i
    Set ComputeLeaves = out
End Function

'---------------------- Existing manifest scan ---------------------------------

Private Sub ScanExistingPacks(ByVal outRoot As String, ByRef existing As Object)
    On Error Resume Next
    Dim fso As Object: Set fso = CreateObject("Scripting.FileSystemObject")
    If Not fso.FolderExists(outRoot) Then Exit Sub
    Dim folder As Object: Set folder = fso.GetFolder(outRoot)
    Dim subf As Object
    For Each subf In folder.SubFolders
        Dim m As String: m = subf.Path & "\manifest.json"
        If fso.FileExists(m) Then
            Dim txt As String: txt = ReadAllText(m)
            Dim key As String: key = JsonFindString(txt, "conversation_key")
            If Len(key) > 0 Then
                Dim lastUtc As String: lastUtc = JsonFindString(txt, "last_message_utc")
                Dim rec As Object: Set rec = CreateObject("Scripting.Dictionary")
                rec("Path") = subf.Path
                If Len(lastUtc) > 0 Then rec("LastUtc") = SafeParseDate(lastUtc) Else rec("LastUtc") = 0
                Set existing(key) = rec
            End If
        End If
    Next subf
End Sub

'------------------------ State file (_state.json) -----------------------------

Private Function ReadStateLastUTC(ByVal outRoot As String) As Date
    On Error Resume Next
    Dim p As String: p = outRoot & "\" & STATE_FILE
    If Len(Dir$(p)) = 0 Then Exit Function
    Dim txt As String: txt = ReadAllText(p)

    If Len(txt) < 10 Or InStr(1, txt, "LastSyncUTC", vbTextCompare) = 0 Then
        Warn "State file appears corrupted - will perform full export: " & p
        Exit Function
    End If

    Dim s As String: s = JsonFindString(txt, "LastSyncUTC")
    If Len(s) > 0 Then
        Dim d As Date: d = SafeParseDate(s)
        If d = 0 Then
            Warn "Invalid date in state file - will perform full export"
        Else
            ReadStateLastUTC = d
        End If
    End If
End Function

Private Sub WriteState(ByVal outRoot As String, ByVal lastUtc As Date, ByVal folders As Variant)
    On Error Resume Next
    Dim d As Object: Set d = CreateObject("Scripting.Dictionary")
    d("LastSyncUTC") = Format$(lastUtc, "yyyy-mm-dd\Thh:nn:ss\Z")
    d("Folders") = folders
    WriteTextFile outRoot & "\" & STATE_FILE, JsonSerializeDict(d), False
End Sub

'------------------------ JSON helpers (lightweight) ---------------------------

Private Function JsonEscape(ByVal s As String) As String
    Dim sb As Object: Set sb = CreateObject("System.Text.StringBuilder")
    sb.Append Replace(s, "\", "\\")
    sb.Replace """", "\""
    sb.Replace vbCr, "\r"
    sb.Replace vbLf, "\n"
    sb.Replace vbTab, "\t"
    sb.Replace Chr(8), "\b"
    sb.Replace Chr(12), "\f"
    
    Dim i As Long
    For i = 0 To 31
        If i <> 8 And i <> 9 And i <> 10 And i <> 12 And i <> 13 Then
             sb.Replace Chr(i), ""
        End If
    Next i

    Dim tempString As String: tempString = sb.ToString()
    Set sb = CreateObject("System.Text.StringBuilder")
    Dim charCode As Long
    For i = 1 To Len(tempString)
        charCode = AscW(Mid$(tempString, i, 1))
        If charCode < 32 Or charCode > 126 Then
            sb.Append "\u" & Right$("000" & Hex(charCode), 4)
        Else
            sb.Append Mid$(tempString, i, 1)
        End If
    Next i
    JsonEscape = sb.ToString()
End Function

Private Function JsonSerializeDict(ByVal d As Object) As String
    If d Is Nothing Or d.Count = 0 Then
        JsonSerializeDict = "{}": Exit Function
    End If
    
    Dim parts() As String: ReDim parts(0 To d.Count - 1)
    Dim k As Variant, i As Long: i = 0
    
    For Each k In d.Keys
        parts(i) = """" & JsonEscape(CStr(k)) & "\":" & JsonValue(d(k))
        i = i + 1
    Next k
    
    JsonSerializeDict = "{" & Join(parts, ",") & "}"
End Function

Private Function JsonValue(ByVal v As Variant) As String
    If IsNull(v) Then
        JsonValue = "null"
    ElseIf IsObject(v) Then
        Dim t As String: t = TypeName(v)
        If t = "Dictionary" Then
            JsonValue = JsonSerializeDict(v)
        ElseIf t = "Collection" Then
            JsonValue = JsonArrayFromCollection(v)
        Else
            JsonValue = """" & JsonEscape(CStr(v)) & """"
        End If
    ElseIf IsArray(v) Then
        JsonValue = JsonArrayFromVariant(v)
    ElseIf VarType(v) = vbBoolean Then
        If v Then
            JsonValue = "true"
        Else
            JsonValue = "false"
        End If
    ElseIf IsDate(v) Then
        JsonValue = """" & Format$(CDate(v), "yyyy-mm-dd\Thh:nn:ss\Z") & """"
    ElseIf IsNumeric(v) Then
        JsonValue = CStr(v)
    Else
        JsonValue = """" & JsonEscape(CStr(v)) & """"
    End If
End Function

Private Function JsonArrayFromCollection(ByVal c As Collection) As String
    If (c Is Nothing) Or c.Count = 0 Then
        JsonArrayFromCollection = "[]": Exit Function
    End If
    Dim parts() As String
    ReDim parts(0 To c.Count - 1)
    Dim i As Long
    For i = 1 To c.Count
        parts(i - 1) = JsonValue(c(i))
    Next i
    JsonArrayFromCollection = "[" & Join(parts, ",") & "]"
End Function

Private Function JsonArrayFromVariant(ByVal arr As Variant) As String
    On Error GoTo EmptyArr
    Dim lb As Long, ub As Long
    lb = LBound(arr): ub = UBound(arr)
    If ub < lb Then JsonArrayFromVariant = "[]": Exit Function
    Dim parts() As String
    ReDim parts(lb To ub)
    Dim i As Long
    For i = lb To ub
        parts(i) = JsonValue(arr(i))
    Next i
    JsonArrayFromVariant = "[" & Join(parts, ",") & "]"
    Exit Function
EmptyArr:
    JsonArrayFromVariant = "[]"
End Function

Private Function JsonFindString(ByVal json As String, ByVal key As String) As String
    On Error Resume Next
    Dim re As Object: Set re = CreateObject("VBScript.RegExp")
    re.Global = False: re.IgnoreCase = True
    re.pattern = """" & key & """\s*:\s*""([^""]*)"""
    Dim m As Object: Set m = re.Execute(json)
    If m.Count > 0 Then JsonFindString = m(0).SubMatches(0)
End Function

Private Function JsonFindArrayOfObjects(ByVal jsonText As String, ByVal key As String) As Collection
    On Error Resume Next
    Set JsonFindArrayOfObjects = New Collection
    Dim re As Object, matches As Object, arrayContent As String, objMatch As Object, objContent As String, kvMatches As Object, kvMatch As Object, dict As Object
    Set re = CreateObject("VBScript.RegExp")
    re.Global = False: re.IgnoreCase = True: re.MultiLine = True
    re.pattern = """" & key & """\s*:\s*\[([\s\S]*?)\]"
    Set matches = re.Execute(jsonText)
    If matches.Count = 0 Then Exit Function
    arrayContent = matches(0).SubMatches(0)
    re.pattern = "\{([\s\S]*?)\}"
    re.Global = True
    Set matches = re.Execute(arrayContent)
    If matches.Count = 0 Then Exit Function
    
    For Each objMatch In matches
        objContent = objMatch.SubMatches(0)
        Set dict = CreateObject("Scripting.Dictionary")
        
        ' Regex for string values
        re.pattern = """([^""]+)""\s*:\s*""([^""]*)"""
        Set kvMatches = re.Execute(objContent)
        For Each kvMatch In kvMatches
            dict(kvMatch.SubMatches(0)) = kvMatch.SubMatches(1)
        Next
        
        ' Regex for non-string values (array, null, bool, number)
        re.pattern = """([^""]+)""\s*:\s*(\[.*?\]|null|true|false|-?\d+\.?\d*)"
        Set kvMatches = re.Execute(objContent)
        For Each kvMatch In kvMatches
            If Not dict.Exists(kvMatch.SubMatches(0)) Then
                dict(kvMatch.SubMatches(0)) = kvMatch.SubMatches(1) ' Store as string, parse later
            End If
        Next
        If dict.Count > 0 Then JsonFindArrayOfObjects.Add dict
    Next
End Function

'------------------------ Participants / messages ------------------------------

Private Function UniqueParticipants(ByVal msgs As Collection) As Object
    Dim setE As Object: Set setE = CreateObject("Scripting.Dictionary")
    If msgs Is Nothing Or msgs.Count = 0 Then Set UniqueParticipants = New Collection: Exit Function
    Dim i As Long, m As Object, k As Variant
    For i = 1 To msgs.Count
        Set m = msgs(i)
        If Not m Is Nothing Then
            If m.Exists("From") Then setE(NormalizeEmail(NzStr(m("From")))) = True
            If m.Exists("To") Then
                Dim t As Object: Set t = m("To")
                If Not t Is Nothing Then
                    For Each k In t.Keys
                        If t(k).Exists("smtp") Then setE(NormalizeEmail(NzStr(t(k)("smtp")))) = True
                    Next k
                End If
            End If
            If m.Exists("CC") Then
                Dim c As Object: Set c = m("CC")
                If Not c Is Nothing Then
                    For Each k In c.Keys
                        If c(k).Exists("smtp") Then setE(NormalizeEmail(NzStr(c(k)("smtp")))) = True
                    Next k
                End If
            End If
        End If
    Next i
    Dim out As Object: Set out = New Collection
    For Each k In setE.Keys
        Dim p As Object: Set p = CreateObject("Scripting.Dictionary")
        p("given_name") = Null: p("surname") = Null: p("smtp") = k: p("job_title") = Null
        out.Add p
    Next k
    Set UniqueParticipants = out
End Function

' ---- Safer body extraction with HTML fallback ----
Private Function SafeGetBody(ByVal entryId As String, ByVal storeId As String) As String
    On Error GoTo EH
    Dim mi As Object
    Set mi = GetItemWithRetry(entryId, storeId, 3)
    If Not mi Is Nothing Then
        If mi.DownloadState = OL_DOWNLOADSTATE_COMPLETE Then
            Dim html As String
            On Error Resume Next
            html = mi.HTMLBody
            On Error GoTo EH

            If Len(html) > 0 Then
                SafeGetBody = HtmlToText(html)
            Else
                SafeGetBody = NzStr(mi.Body)
            End If
        End If
    End If
    Set mi = Nothing
    Exit Function
EH:
    SafeGetBody = ""
End Function

Private Function HtmlToText(ByVal html As String) As String
    On Error Resume Next
    Dim re As Object: Set re = CreateObject("VBScript.RegExp")
    re.Global = True: re.IgnoreCase = True
    re.pattern = "<script[\s\S]*?</script>|<style[\s\S]*?</style>"
    html = re.Replace(html, "")
    re.pattern = "<[^>]+>"
    html = re.Replace(html, "")
    HtmlToText = Trim$(NormalizeWhitespace(html))
End Function

Private Function GetItemWithRetry(ByVal entryId As String, ByVal storeId As String, ByVal maxRetries As Long) As Object
    Dim attempt As Long, it As Object
    If Application.Session Is Nothing Then
        Warn "GetItemWithRetry: Application.Session is Nothing"
        Exit Function
    End If
    For attempt = 1 To maxRetries
        On Error Resume Next
        ' Per docs: pass StoreID when retrieving items by EntryID.
        Set it = Application.Session.GetItemFromID(entryId, storeId)
        On Error GoTo 0
        If Not it Is Nothing Then Set GetItemWithRetry = it: Exit Function
        If attempt < maxRetries Then
            Nap CLng(100 * (2 ^ (attempt - 1)))   ' 100ms, 200ms, 400ms...
        End If
    Next attempt
    g_errorCount = g_errorCount + 1
    Warn "GetItemWithRetry failed after " & maxRetries & " attempts for EntryID: " & Left$(entryId, 50)
End Function

'------------------------ Text / Files -----------------------------------------

Private Sub WriteTextFile(ByVal path As String, ByVal text As String, ByVal noBom As Boolean)
    On Error GoTo EH
    Dim tempPath As String: tempPath = path & ".tmp_" & CreateRandomName()  ' atomic write

    Dim s As Object: Set s = Nothing
    If noBom Then
        Dim b() As Byte: b = Utf8Bytes(text, True)
        WriteBinary tempPath, b
    Else
        Set s = CreateObject("ADODB.Stream")
        s.Type = 2: s.Charset = "utf-8"
        s.Open
        s.WriteText text
        s.SaveToFile tempPath, 2
        s.Close
        Set s = Nothing
    End If

    If Len(Dir$(path)) > 0 Then Kill path
    Name tempPath As path
    Exit Sub
EH:
    On Error Resume Next
    If Not s Is Nothing Then
        s.Close
        Set s = Nothing
    End If
    KillSafe tempPath
    Err.Raise Err.Number, "WriteTextFile", Err.Description
End Sub

Private Function ReadAllText(ByVal path As String) As String
    On Error GoTo EH
    Dim s As Object: Set s = CreateObject("ADODB.Stream")
    s.Type = 2: s.Charset = "utf-8"
    s.Open
    s.LoadFromFile path
    ReadAllText = s.ReadText
    s.Close
    Exit Function
EH:
    On Error Resume Next
    If Not s Is Nothing Then s.Close
    ReadAllText = ""
End Function

Private Sub WriteBinary(ByVal path As String, ByRef bytes() As Byte)
    On Error GoTo EH
    Dim s As Object: Set s = CreateObject("ADODB.Stream")
    s.Type = 1: s.Open
    s.Write bytes
    s.SaveToFile path, 2
    s.Close
    Exit Sub
EH:
    On Error Resume Next
    If Not s Is Nothing Then s.Close
    Err.Raise Err.Number, "WriteBinary", Err.Description
End Sub

Private Sub KillSafe(ByVal path As String)
    On Error Resume Next
    If Len(Dir$(path)) > 0 Then Kill path
End Sub

'------------------------ SHA-256 ----------------------------------------------

Private Function SHA256_StringUTF8(ByVal s As String) As String
    Dim bytes() As Byte: bytes = Utf8Bytes(s, True)
    SHA256_StringUTF8 = SHA256_Bytes(bytes)
End Function

Private Function SHA256_File(ByVal path As String) As String
#If VBA7 Then
    Dim hProv As LongPtr, hHash As LongPtr
#Else
    Dim hProv As Long, hHash As Long
#End If
    Dim st As Object: Set st = Nothing
    Dim contextAcquired As Boolean: contextAcquired = False
    Dim hashCreated As Boolean: hashCreated = False
    Dim fso As Object
    On Error GoTo EH
    Set fso = CreateObject("Scripting.FileSystemObject")

    If Len(Trim$(path)) = 0 Or Not fso.FileExists(path) Then
        Warn "SHA256_File: File not found or path is empty — " & path
        GoTo CleanExit
    End If

    If fso.GetFile(path).Size = 0 Then
        Debug.Print "SHA256_File: Hashing empty file, returning hash of empty string. Path: " & path
        SHA256_File = "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855" ' SHA-256 of empty string
        GoTo CleanExit
    End If

    If CryptAcquireContext(hProv, vbNullString, vbNullString, PROV_RSA_AES, CRYPT_VERIFYCONTEXT) = 0 Then Err.Raise 5, , "CryptAcquireContext failed"
    contextAcquired = True

    If CryptCreateHash(hProv, CALG_SHA_256, 0, 0, hHash) = 0 Then Err.Raise 5, , "CryptCreateHash failed"
    hashCreated = True

    Set st = CreateObject("ADODB.Stream")
    st.Type = 1: st.Open
    st.LoadFromFile path

    Dim chunkSize As Long
    If st.Size < 1048576 Then chunkSize = 32768 Else If st.Size < 10485760 Then chunkSize = 65536 Else chunkSize = 131072

    Do While st.Position < st.Size
        Dim chunkVar As Variant: chunkVar = st.Read(chunkSize)
        If IsEmpty(chunkVar) Then Exit Do
        Dim buf() As Byte: buf = chunkVar
        Dim cb As Long: cb = UBound(buf) - LBound(buf) + 1
        If cb > 0 Then
            If CryptHashData(hHash, buf(LBound(buf)), cb, 0) = 0 Then Err.Raise 5, , "CryptHashData failed"
        End If
    Loop
    
    SHA256_File = ReadHashHexPtr(hHash)

CleanExit:
    On Error Resume Next
    If Not st Is Nothing Then
        If st.State = 1 Then st.Close
        Set st = Nothing
    End If
    If hashCreated Then
        CryptDestroyHash hHash
        hashCreated = False
    End If
    If contextAcquired Then
        CryptReleaseContext hProv, 0
        contextAcquired = False
    End If
    Set fso = Nothing
    Exit Function

EH:
    g_errorCount = g_errorCount + 1
    Warn "SHA256_File error (" & Err.Number & "): " & Err.Description & " on file: " & path
    SHA256_File = ""
    Resume CleanExit
End Function

Private Function SHA256_Bytes(ByRef bytes() As Byte) As String
#If VBA7 Then
    Dim hProv As LongPtr, hHash As LongPtr
#Else
    Dim hProv As Long, hHash As Long
#End If
    Dim contextAcquired As Boolean: contextAcquired = False
    Dim hashCreated As Boolean: hashCreated = False
    On Error GoTo EH

    If CryptAcquireContext(hProv, vbNullString, vbNullString, PROV_RSA_AES, CRYPT_VERIFYCONTEXT) = 0 Then
        Err.Raise 5, , "CryptAcquireContext failed"
    End If
    contextAcquired = True

    If CryptCreateHash(hProv, CALG_SHA_256, 0, 0, hHash) = 0 Then
        Err.Raise 5, , "CryptCreateHash failed"
    End If
    hashCreated = True

    If (UBound(bytes) - LBound(bytes) + 1) > 0 Then
        If CryptHashData(hHash, bytes(LBound(bytes)), UBound(bytes) - LBound(bytes) + 1, 0) = 0 Then
            Err.Raise 5, , "CryptHashData failed"
        End If
    End If
    SHA256_Bytes = ReadHashHexPtr(hHash)
    CryptDestroyHash hHash
    CryptReleaseContext hProv, 0
    Exit Function
EH:
    On Error Resume Next
    If hashCreated Then CryptDestroyHash hHash
    If contextAcquired Then CryptReleaseContext hProv, 0
    SHA256_Bytes = ""
End Function

#If VBA7 Then
Private Function ReadHashHexPtr(ByVal hHash As LongPtr) As String
#Else
Private Function ReadHashHexPtr(ByVal hHash As Long) As String
#End If
    Dim cb As Long
    If CryptGetHashParam(hHash, HP_HASHSIZE, ByVal 0&, cb, 0) = 0 Then Exit Function
    Dim hb() As Byte: ReDim hb(0 To cb - 1)
    If CryptGetHashParam(hHash, HP_HASHVAL, hb(0), cb, 0) = 0 Then Exit Function
    Dim parts() As String: ReDim parts(0 To cb - 1)
    Dim i As Long
    For i = 0 To cb - 1
        parts(i) = LCase$(Right$("0" & Hex$(hb(i)), 2))
    Next i
    ReadHashHexPtr = Join(parts, "")
End Function

Private Function Utf8Bytes(ByVal s As String, Optional ByVal noBom As Boolean = True) As Byte()
    On Error GoTo EH
    Dim t As Object: Set t = CreateObject("ADODB.Stream")
    t.Type = 2: t.Charset = "utf-8": t.Open
    t.WriteText s
    t.Position = 0: t.Type = 1
    Dim arr As Variant: arr = t.Read
    t.Close
    Dim b() As Byte: b = arr
    If noBom Then
        If UBound(b) >= 2 Then
            If b(0) = &HEF And b(1) = &HBB And b(2) = &HBF Then
                Dim out() As Byte: ReDim out(0 To UBound(b) - 3)
                Dim i As Long
                For i = 3 To UBound(b): out(i - 3) = b(i): Next i
                Utf8Bytes = out: Exit Function
            End If
        End If
    End If
    Utf8Bytes = b
    Exit Function
EH:
    On Error Resume Next
    If Not t Is Nothing Then t.Close
    Utf8Bytes = Array()
End Function

Private Function Base64OfBytes(ByRef bytes As Variant) As String
    On Error GoTo Fallback
    Dim dom As Object: Set dom = CreateObject("MSXML2.DOMDocument.6.0")
    Dim el As Object: Set el = dom.createElement("b64")
    el.DataType = "bin.base64"
    el.nodeTypedValue = bytes
    Base64OfBytes = Replace(el.text, vbLf, "")
    Exit Function
Fallback:
    On Error GoTo EH
    Dim dom2 As Object: Set dom2 = CreateObject("MSXML2.DOMDocument")
    Dim el2 As Object: Set el2 = dom2.createElement("b64")
    el2.DataType = "bin.base64"
    el2.nodeTypedValue = bytes
    Base64OfBytes = Replace(el2.text, vbLf, "")
    Exit Function
EH:
    Warn "Base64 encoding failed, using hex fallback"
    Base64OfBytes = BytesToHex(bytes)
End Function

Private Function BytesToHex(ByRef bytes As Variant) As String
    On Error Resume Next
    Dim b() As Byte: b = bytes
    Dim s As String, i As Long
    For i = LBound(b) To UBound(b)
        s = s & LCase$(Right$("0" & Hex$(b(i)), 2))
        If i > 99 Then Exit For
    Next i
    BytesToHex = s
End Function

'--------------------- Sorting / collections -----------------------------------

Private Function SortedCopyByKey(ByVal c As Collection, ByVal key As String, ByVal asc As Boolean) As Collection
    If c Is Nothing Then Set SortedCopyByKey = New Collection: Exit Function
    Dim n As Long: n = c.Count
    If n = 0 Then Set SortedCopyByKey = New Collection: Exit Function
    If n = 1 Then Set SortedCopyByKey = c: Exit Function
    Dim arr() As Variant: ReDim arr(1 To n)
    Dim i As Long
    For i = 1 To n: Set arr(i) = c(i): Next i
    QuickSortObjByKey arr, 1, n, key, asc
    Dim out As New Collection
    For i = 1 To n: out.Add arr(i): Next i
    Set SortedCopyByKey = out
End Function

Private Sub QuickSortObjByKey(ByRef a() As Variant, ByVal lo As Long, ByVal hi As Long, ByVal key As String, ByVal asc As Boolean)
    Static depth As Long
    Const MAX_DEPTH As Long = 50
    If depth > MAX_DEPTH Then Warn "QuickSort depth limit reached, using fallback": Exit Sub
    depth = depth + 1
    On Error GoTo CleanUp

    Dim i As Long, j As Long
    i = lo: j = hi
    Dim pivot As Variant: Set pivot = a((lo + hi) \ 2)
    Do While i <= j
        If asc Then
            Do While a(i)(key) < pivot(key): i = i + 1: Loop
            Do While a(j)(key) > pivot(key): j = j - 1: Loop
        Else
            Do While a(i)(key) > pivot(key): i = i + 1: Loop
            Do While a(j)(key) < pivot(key): j = j - 1: Loop
        End If
        If i <= j Then
            Dim tmp As Variant: Set tmp = a(i): Set a(i) = a(j): Set a(j) = tmp
            i = i + 1: j = j - 1
        End If
    Loop
    If lo < j Then QuickSortObjByKey a, lo, j, key, asc
    If i < hi Then QuickSortObjByKey a, i, hi, key, asc

CleanUp:
    depth = depth - 1
End Sub

Private Function JoinCollection(ByVal c As Collection, ByVal sep As String) As String
    If c Is Nothing Or c.Count = 0 Then JoinCollection = "": Exit Function
    Dim arr() As String
    ReDim arr(0 To c.Count - 1)
    Dim i As Long
    For i = 1 To c.Count
        arr(i - 1) = CStr(c(i))
    Next i
    JoinCollection = Join(arr, sep)
End Function

Private Function CollectionToArray(ByVal c As Collection) As Variant
    If c Is Nothing Or c.Count = 0 Then CollectionToArray = Array(): Exit Function
    Dim arr() As Variant: ReDim arr(0 To c.Count - 1)
    Dim i As Long
    For i = 1 To c.Count: arr(i - 1) = c(i): Next i
    CollectionToArray = arr
End Function

Private Function DictValues(ByVal d As Object) As Object
    Dim out As New Collection
    If Not d Is Nothing Then
        Dim k As Variant
        For Each k In d.Keys: out.Add d(k): Next k
    End If
    Set DictValues = out
End Function

Private Function JoinEmails(ByVal recipients As Object) As String
    Dim k As Variant, out As New Collection
    If Not recipients Is Nothing Then
        For Each k In recipients.Keys
            If recipients(k).Exists("smtp") Then out.Add recipients(k)("smtp")
        Next k
    End If
    JoinEmails = JoinCollection(out, "; ")
End Function

Private Function JoinEmailsNormalized(ByVal recipients As Object) As String
    Dim k As Variant, out As New Collection
    If Not recipients Is Nothing Then
        For Each k In recipients.Keys
            If recipients(k).Exists("smtp") Then out.Add NormalizeEmail(NzStr(recipients(k)("smtp")))
        Next k
    End If
    JoinEmailsNormalized = JoinCollection(out, "; ")
End Function

Private Function CountRecipients(ByVal recipients As Object) As Long
    If recipients Is Nothing Then
        CountRecipients = 0
    Else
        CountRecipients = recipients.Count
    End If
End Function

Private Function RecipsToLower(ByVal recipients As Object) As Variant
    Dim out As New Collection, k As Variant
    If Not recipients Is Nothing Then
        For Each k In recipients.Keys
            If recipients(k).Exists("smtp") Then out.Add NormalizeEmail(NzStr(recipients(k)("smtp")))
        Next k
    End If
    RecipsToLower = CollectionToArray(out)
End Function

Private Function ReplaceMultiple(ByVal s As String, ByVal targets As Variant, ByVal repl As String) As String
    Dim i As Long
    For i = LBound(targets) To UBound(targets)
        s = Replace(s, CStr(targets(i)), repl)
    Next i
    ReplaceMultiple = s
End Function

Private Function CreateRandomName() As String
    Randomize
    CreateRandomName = Replace(CStr(Timer * 1000#), ".", "") & "_" & CStr(Int(Rnd() * 1000000#))
End Function

Private Function SafeStr(ByVal obj As Object, ByVal prop As String) As String
    On Error Resume Next
    Dim v As Variant: v = CallByName(obj, prop, VbGet)
    If Err.Number <> 0 Then
        Err.Clear
        SafeStr = ""
    Else
        SafeStr = CStr(v)
    End If
End Function

Private Function SafeFolderPath(ByVal f As Object) As String
    On Error Resume Next
    SafeFolderPath = NzStr(f.FolderPath)
    If Err.Number <> 0 Then SafeFolderPath = "(unknown)": Err.Clear
End Function

Private Function SafeParentStoreID(ByVal mi As Object) As String
    On Error Resume Next
    Dim p As Object: Set p = mi.Parent
    If Not p Is Nothing Then
        Dim sid As String: sid = NzStr(p.StoreID)
        If Len(sid) > 0 Then SafeParentStoreID = sid: Exit Function
    End If
    SafeParentStoreID = ""
End Function

Private Sub Info(ByVal s As String)
    If Len(CFG_LogPath) > 0 Then AppendLog s
    Debug.Print s
End Sub

Private Sub Warn(ByVal s As String)
    If Len(CFG_LogPath) > 0 Then AppendLog ("WARN: " & s)
    Debug.Print "WARN: " & s
End Sub

Private Sub AppendLog(ByVal s As String)
    On Error Resume Next
    Dim f As Integer: f = FreeFile
    Open CFG_LogPath For Append As #f
    Print #f, Format$(Now, "yyyy-mm-dd hh:nn:ss") & " - " & s
    Close #f
End Sub

'---------------------- Export locking -----------------------------------------

Private Function AcquireExportLock(ByVal lockFile As String) As Boolean
    Dim fso As Object: Set fso = CreateObject("Scripting.FileSystemObject")
    Dim ts As Object

Retry:
    On Error GoTo HandleError
    Set ts = fso.CreateTextFile(lockFile, False, False)
    ts.WriteLine "Export started: " & Format$(Now, "yyyy-mm-dd hh:nn:ss")
    ts.WriteLine "PID: " & Environ$("USERNAME") & "@" & Environ$("COMPUTERNAME")
    ts.Close
    Set ts = Nothing
    AcquireExportLock = True
    Set fso = Nothing
    Exit Function

HandleError:
    Dim errNum As Long: errNum = Err.Number
    Dim errDesc As String: errDesc = Err.Description
    On Error Resume Next
    If Not ts Is Nothing Then ts.Close
    Set ts = Nothing
    Select Case errNum
        Case 58, 70 ' File exists or permission denied
            If fso.FileExists(lockFile) Then
                Dim existingFile As Object: Set existingFile = fso.GetFile(lockFile)
                If Not existingFile Is Nothing Then
                    If DateDiff("h", existingFile.DateLastModified, Now) > 2 Then
                        Warn "Removing stale lock file (older than 2 hours): " & lockFile
                        fso.DeleteFile lockFile, True
                        Err.Clear
                        On Error GoTo HandleError
                        GoTo Retry
                    End If
                End If
            End If
            AcquireExportLock = False
        Case Else
            Warn "AcquireExportLock error (" & errNum & "): " & errDesc
            AcquireExportLock = False
    End Select
    Set fso = Nothing
End Function

Private Sub ReleaseExportLock(ByVal lockFile As String)
    On Error Resume Next
    If Len(Dir$(lockFile)) > 0 Then Kill lockFile
End Sub

'---------------------- Disk space check ---------------------------------------

Private Function CheckDiskSpace(ByVal path As String, ByVal requiredBytes As Long) As Boolean
    On Error Resume Next
    Dim fso As Object: Set fso = CreateObject("Scripting.FileSystemObject")

    Dim drv As Object
    If Left$(path, 2) = "\\" Then
        Dim fld As Object: Set fld = fso.GetFolder(path)
        If Not fld Is Nothing Then Set drv = fld.Drive
    Else
        Set drv = fso.GetDrive(fso.GetDriveName(path))
    End If

    If Not drv Is Nothing Then
        If drv.AvailableSpace > requiredBytes Then
            CheckDiskSpace = True
        Else
            Warn "Insufficient disk space. Required: " & Format$(requiredBytes / 1048576, "0.0") & " MB, Available: " & Format$(drv.AvailableSpace / 1048576, "0.0") & " MB"
        End If
    Else
        Warn "Unable to check disk space for: " & path
        Err.Raise vbObjectError + 103, "CheckDiskSpace", "Cannot determine disk space for: " & path
    End If
End Function

'---------------------- Orphaned temp file cleanup -----------------------------

Private Sub CleanupOrphanedTempFiles(ByVal outRoot As String)
    On Error Resume Next
    Dim fso As Object: Set fso = CreateObject("Scripting.FileSystemObject")
    If Not fso.FolderExists(outRoot) Then Exit Sub

    Dim folder As Object: Set folder = fso.GetFolder(outRoot)
    Dim subf As Object, f As Object
    Dim cleanCount As Long: cleanCount = 0

    For Each f In folder.Files
        If f.Name Like "_tmp_*" Or f.Name Like "*.tmp_*" Then
            If DateDiff("h", f.DateLastModified, Now) > 1 Then
                fso.DeleteFile f.Path, True: cleanCount = cleanCount + 1
            End If
        End If
    Next f

    For Each subf In folder.SubFolders
        Dim attFolder As Object
        If fso.FolderExists(subf.Path & "\attachments") Then
            Set attFolder = fso.GetFolder(subf.Path & "\attachments")
            For Each f In attFolder.Files
                If f.Name Like "_tmp_*" Then
                    If DateDiff("h", f.DateLastModified, Now) > 1 Then
                        fso.DeleteFile f.Path, True: cleanCount = cleanCount + 1
                    End If
                End If
            Next f
        End If
    Next subf

    If cleanCount > 0 Then Info "Cleaned up " & cleanCount & " orphaned temporary files"
End Sub

'---------------------- Manifest validation (compat) ---------------------------

Private Function ValidateManifest(ByVal manifest As Object, ByVal attDir As String) As Boolean
    On Error Resume Next
    ValidateManifest = True

    If Not manifest.Exists("conversation_key") Or Len(NzStr(manifest("conversation_key"))) = 0 Then
        Warn "Manifest missing conversation_key": ValidateManifest = False
    End If

    If Not manifest.Exists("messages_count") Or Not IsNumeric(manifest("messages_count")) Then
        Warn "Manifest missing or invalid messages_count": ValidateManifest = False
    End If

    If manifest.Exists("attachments") And manifest("has_attachment") = True Then
        Dim attList As Object: Set attList = manifest("attachments")
        If TypeName(attList) = "Collection" Then
            If attList.Count > 0 Then ValidateManifest = True
        End If
    End If
End Function

'---------------------- Small helpers added (2025-11-02) ----------------------

Private Function GetExtension(ByVal filename As String) As String
    Dim p As Long: p = InStrRev(filename, ".")
    If p > 0 Then
        GetExtension = Mid$(filename, p)
        If Len(GetExtension) > 10 Then GetExtension = ""
    Else
        GetExtension = ""
    End If
End Function
