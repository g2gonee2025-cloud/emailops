<#
Build-Conversations.ps1 (hardened, 5.1+ compatible)
Post-process exported .eml/.msg into conversation packs with incremental updates.

Key features:
- Cleaning pipeline for LLM/vectorization (Conversation.clean.txt + optional chunks.jsonl)
- Include/Exclude folder patterns; sender/domain allow/deny; subject/body regex filters
- Auto-generated noise filter (NDR/OOF/system) via headers: Auto-Submitted, X-Auto-Response-Suppress, Precedence, multipart/report
- Attachment dedupe (one file per SHA; newest name wins) and collision-safe renaming
- Nested .eml/.msg attachments: extract attachments recursively (depth-limited), NEVER include attached email body itself
- Incremental updates reuse and optionally rename existing conversation folder to prevent duplicates

Requires: Outlook desktop for reading .msg via COM (and for nested .msg extraction).
Tested on PowerShell 5.1 and 7+ (Windows).
#>

[CmdletBinding(SupportsShouldProcess=$false)]
param(
    # IO
    [string]$ExportsRoot = (Join-Path $env:LOCALAPPDATA 'Microsoft\Outlook'),
    [string]$OutRoot     = 'C:\Temp\OutlookExport',
    [string]$MyAddress   = '',  # Auto-detect from Outlook if not specified
    [bool]$LeavesOnly = $true,  # Only leaf messages (latest replies). Set -LeavesOnly:$false for all messages.
    [ValidateRange(100, 300)] [int]$MaxPathLength = 210,
    [bool]$SkipInlineLogos = $true,
    [ValidateRange(1, 1024)][int]$InlineLogoMaxKB = 15,
    [bool]$EnableLongPaths = $true,
    [string]$LogPath = $OutRoot,
    [string[]]$IncludePathPattern,
    [string[]]$ExcludePathPattern,
    [string[]]$AllowSenders,
    [string[]]$RejectSenders,
    [string[]]$RejectDomains,
    [string[]]$RejectSubjectRegex,
    [string[]]$RejectBodyRegex,
    [bool]$ExcludeMarketing = $true,
    [bool]$ExcludeAutoGenerated = $true,
    [bool]$CleanBodies = $true,
    [ValidateRange(1,1000000)][int]$MinBodyChars = 20,
    [bool]$EmitChunks = $false,
    [ValidateRange(100,1000000)][int]$ChunkSizeChars = 3600,
    [ValidateRange(0,500000)][int]$ChunkOverlapChars = 400,
    [switch]$NoBomEncoding,  # emit UTF-8 without BOM when desired
    [bool]$IncludeNestedAttachments = $true,
    [ValidateRange(0,8)][int]$NestedDepth = 2,
    [bool]$PreferNewestAttachmentName = $true,
    [bool]$PickFromOutlook = $true,
    [bool]$IncludeSubfolders = $false,
    [ValidateSet('MSG','MSGUnicode','EML')][string]$OutlookExportFormat = 'EML',
    [switch]$NoHostLog = $false
)

# --- Script-scope initialization ---
$script:OutlookApp = $null
$script:LogFile    = $null
$InformationPreference = 'Continue'

Set-StrictMode -Version Latest
$ErrorActionPreference = 'Stop'

# Cleanup trap for unexpected termination
trap {
    Log "ERROR: Unexpected termination - $_"
    # Ensure COM cleanup
    Close-OutlookCom
    # Clear hash cache to free memory
    if (Get-Variable -Scope Script -Name FileHashCache -ErrorAction SilentlyContinue) {
        $script:FileHashCache.Clear()
    }
    # Try to cleanup temp directories
    if (Get-Variable -Scope Script -Name TempDirectories -ErrorAction SilentlyContinue) {
        foreach ($tempDir in $script:TempDirectories) {
            if (Test-Path -LiteralPath $tempDir) {
                try { Remove-Item -LiteralPath $tempDir -Recurse -Force -ErrorAction SilentlyContinue } catch {}
            }
        }
    }
    break
}

# Track temporary directories for cleanup
$script:TempDirectories = New-Object System.Collections.Generic.List[string]

# Initialize long path support tracking
$script:LongPathSupport = @{
    Enabled = $false
    Attempted = $false
    Error = $null
    MaxPathLength = $MaxPathLength
}

if ($EnableLongPaths) {

    $script:LongPathSupport.Attempted = $true
    $longPathError = $null

    try {
        # Verify SetSwitch method exists (.NET Framework 4.6.2+ requirement)
        $setSwitch = [System.AppContext].GetMethod('SetSwitch', [Type[]]@([string], [bool]))

        if ($null -eq $setSwitch) {
            $longPathError = ".NET Framework 4.6.2+ required for SetSwitch method (current framework may be older)"
            Write-Warning "Long path support unavailable: $longPathError"
            Write-Warning "Paths exceeding $MaxPathLength characters will be truncated"
            Write-Warning "Solutions: 1) Update to PowerShell 7+ 2) Install .NET Framework 4.6.2+ 3) Enable Windows long path policy"
        } else {
            # Attempt to set the switch
            [System.AppContext]::SetSwitch('Switch.System.IO.UseLegacyPathHandling', $false)
            $script:LongPathSupport.Enabled = $true
            Write-Information "Long path support enabled via AppContext.SetSwitch (paths >260 chars supported)" -InformationAction Continue
        }
    } catch {
        $longPathError = $_.Exception.Message
        $script:LongPathSupport.Error = $longPathError
        Write-Warning "Failed to enable long path support: $longPathError"
        Write-Warning "Paths exceeding $MaxPathLength characters will be truncated"
        Write-Warning "This may occur due to:"
        Write-Warning "  1. Insufficient .NET Framework version (requires 4.6.2+)"
        Write-Warning "  2. Windows Group Policy restrictions"
        Write-Warning "  3. PowerShell execution environment limitations"
        Write-Warning "Consider upgrading to PowerShell 7+ for better long path support"
    }

    # Store error state for diagnostics
    if ($longPathError) {
        $script:LongPathSupport.Error = $longPathError
    }
}

# ----------------- Utilities -----------------
function New-Directory([Parameter(Mandatory)][string]$Path) {
    if (-not (Test-Path -LiteralPath $Path)) {
        # Use -LiteralPath for consistency and security
        New-Item -ItemType Directory -Force -LiteralPath $Path | Out-Null
    }
    (Resolve-Path -LiteralPath $Path -ErrorAction Stop).Path
}

# Validate directory is not a system/restricted location
function Test-SafeDirectory([string]$Path) {
    $systemDirs = @(
        $env:SystemRoot,
        $env:ProgramFiles,
        ${env:ProgramFiles(x86)},
        "$env:SystemRoot\System32",
        "$env:SystemRoot\SysWOW64"
    )

    $resolvedPath = (Resolve-Path -LiteralPath $Path -ErrorAction SilentlyContinue).Path
    if (-not $resolvedPath) { return $true }  # Path doesn't exist yet, likely safe

    foreach ($sysDir in $systemDirs) {
        if ($sysDir -and $resolvedPath.StartsWith($sysDir, [StringComparison]::OrdinalIgnoreCase)) {
            Log "ERROR: Cannot use system directory as output location: $Path"
            return $false
        }
    }
    return $true
}

# Log rotation configuration
$script:MaxLogSizeMB = 10
$script:MaxLogFiles = 5
$script:LogRotationChecked = $false

function Initialize-LogRotation() {
    if ($script:LogRotationChecked -or -not $script:LogFile) { return }
    $script:LogRotationChecked = $true

    try {
        $logInfo = Get-Item -LiteralPath $script:LogFile -ErrorAction SilentlyContinue
        if ($logInfo -and $logInfo.Length -gt ($script:MaxLogSizeMB * 1MB)) {
            # Rotate current log
            $logDir = Split-Path -Path $script:LogFile -Parent
            $logName = [System.IO.Path]::GetFileNameWithoutExtension($script:LogFile)
            $logExt = [System.IO.Path]::GetExtension($script:LogFile)

            # Shift existing rotated logs
            for ($i = $script:MaxLogFiles - 1; $i -ge 1; $i--) {
                $oldFile = Join-Path $logDir "$logName.$i$logExt"
                $newFile = Join-Path $logDir "$logName.$($i+1)$logExt"
                if (Test-Path -LiteralPath $oldFile) {
                    if ($i -eq ($script:MaxLogFiles - 1)) {
                        # Delete oldest log
                        Remove-Item -LiteralPath $oldFile -Force -ErrorAction SilentlyContinue
                    } else {
                        Move-Item -LiteralPath $oldFile -Destination $newFile -Force -ErrorAction SilentlyContinue
                    }
                }
            }

            # Rotate current log to .1
            $rotatedLog = Join-Path $logDir "$logName.1$logExt"
            Move-Item -LiteralPath $script:LogFile -Destination $rotatedLog -Force -ErrorAction SilentlyContinue

            # Log rotation event to new file
            $ts = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss.fff')
            Add-Content -LiteralPath $script:LogFile -Value "$ts`tINFO: Log rotated. Previous log saved as: $rotatedLog"
        }
    } catch {
        # Silent failure - log rotation should not break the script
    }
}

function Log([string]$msg) {
    $ts = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss.fff')
    $line = "$ts`t$msg"
    Write-Information $line -InformationAction Continue
    if (-not $NoHostLog) { Write-Host $line }
    if ($script:LogFile) {
        # Check for log rotation periodically (every 100 log calls)
        if (-not (Get-Variable -Scope Script -Name LogCallCount -ErrorAction SilentlyContinue)) {
            $script:LogCallCount = 0
        }
        $script:LogCallCount++
        if ($script:LogCallCount % 100 -eq 0) {
            Initialize-LogRotation
        }

        Add-Content -LiteralPath $script:LogFile -Value $line
    }
}

function ConvertTo-SafeName([string]$s, [switch]$AggressiveShorten) {
    if ([string]::IsNullOrWhiteSpace($s)) { return '_' }

    # Unicode normalization for international characters
    try {
        $s = $s.Normalize([System.Text.NormalizationForm]::FormC)
    } catch {
        Log "WARN: Unicode normalization failed for filename, using original"
    }

    # Security: Prevent directory traversal
    $s = $s -replace '\.\.[/\\]', ''
    $s = $s -replace '[/\\]\.\.', ''
    $s = $s -replace '\.\.', '_'

    # Remove control characters and illegal filesystem characters
    # ENHANCED: Also remove #, %, @, and other problematic chars for Outlook COM
    $s = $s -replace '[\x00-\x1F"*/:<>?\\|#%@&]', ' '

    # Security: Block reserved Windows device names
    $reserved = @('CON','PRN','AUX','NUL','COM1','COM2','COM3','COM4','COM5','COM6','COM7','COM8','COM9',
                  'LPT1','LPT2','LPT3','LPT4','LPT5','LPT6','LPT7','LPT8','LPT9','CLOCK$')
    $nameOnly = [System.IO.Path]::GetFileNameWithoutExtension($s)
    if ($reserved -contains $nameOnly.ToUpperInvariant()) {
        $s = "_$s"
    }

    # Security: Warn about potentially dangerous extensions
    $ext = [System.IO.Path]::GetExtension($s)
    if ($ext) {
        $dangerous = @('.exe','.scr','.bat','.cmd','.com','.pif','.vbs','.js','.jar','.msi','.dll','.app')
        if ($dangerous -contains $ext.ToLowerInvariant()) {
            Log "WARN: Potentially dangerous file extension detected: $ext in filename: $s"
        }
    }

    # Collapse multiple spaces and trim
    $s = $s -replace '\s+', ' '
    $s = $s.Trim()

    # Aggressive shortening for Outlook COM compatibility (limits to 80 chars for filename only)
    $maxLength = if ($AggressiveShorten) { 80 } else { 200 }

    if ($s.Length -gt $maxLength) {
        $s = $s.Substring(0, $maxLength)
        if ($AggressiveShorten) {
            Log "INFO: Filename aggressively shortened to $maxLength chars for Outlook compatibility"
        } else {
            Log "WARN: Filename truncated to $maxLength chars for safety"
        }
    }

    return $s
}

# --- Outlook picking & export (optional) ---
function Invoke-OutlookFolderExport {
    param(
        [string]$DestinationRoot,
        [switch]$IncludeSubfolders = $true,
        [ValidateSet('MSG','MSGUnicode','EML')][string]$Format = 'MSG'
    )
    # Start Outlook COM
    $ol = New-Object -ComObject Outlook.Application
    $ns = $ol.GetNamespace('MAPI')

    function Get-OlSaveFormat([string]$fmt) {
        switch ($fmt.ToUpperInvariant()) {
            'MSG'        { return 3 }  # olMSG
            'MSGUNICODE' { return 9 }  # olMSGUnicode (if available)
            'EML'        { return 5 }  # olRFC822
            default      { return 3 }
        }
    }

    function Export-OutlookFolder {
        param(
            $Folder,
            [string]$BaseDest,
            [int]$Depth = 0
        )
        $folderPathPart = ConvertTo-SafeName (($Folder.FolderPath.TrimStart('\')).Replace('\', ' - '))
        $folderDest = Join-Path $BaseDest $folderPathPart
        New-Item -ItemType Directory -Path $folderDest -Force | Out-Null

        # Export only Mail items
        $count = 0
        $skipped = 0
        $failed = 0
        foreach ($item in $Folder.Items) {
            try {
                if ($item -and $item.MessageClass -like 'IPM.Note*') {
                    # Get basic properties with fallback
                    $ts = 'UNKNOWN_DATE'
                    $subj = 'NO_SUBJECT'

                    try {
                        if ($item.ReceivedTime) {
                            $ts = $item.ReceivedTime.ToString('yyyyMMdd_HHmmss')
                        } else {
                            $ts = (Get-Date).ToString('yyyyMMdd_HHmmss')
                        }
                    } catch {
                        $ts = (Get-Date).ToString('yyyyMMdd_HHmmss')
                    }

                    try {
                        if ($item.Subject) {
                            # Use aggressive shortening for Outlook COM compatibility
                            $subj = ConvertTo-SafeName $item.Subject -AggressiveShorten
                        } else {
                            $subj = 'NO_SUBJECT'
                        }
                    } catch {
                        $subj = 'ERROR_SUBJECT'
                    }

                    # Pre-flight checks for restricted messages
                    $shouldSkip = $false
                    $skipReason = ''

                    # Check for rights-protected/encrypted messages
                    try {
                        $permissionService = $item.PropertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/proptag/0x7D010003")
                        if ($permissionService) {
                            $shouldSkip = $true
                            $skipReason = 'Rights-protected (IRM)'
                        }
                    } catch {}

                    # Check message flags for encryption
                    if (-not $shouldSkip) {
                        try {
                            $msgFlags = $item.PropertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/proptag/0x0E070003")
                            # MSGFLAG_HASATTACH = 0x10, but we check for encryption flags
                            if ($msgFlags -band 0x2000) {  # Encrypted flag
                                $shouldSkip = $true
                                $skipReason = 'Encrypted (S/MIME)'
                            }
                        } catch {}
                    }

                    # Check for undownloaded/stub messages
                    if (-not $shouldSkip) {
                        try {
                            # Check if body is accessible
                            $testBody = $item.Body
                            if ([string]::IsNullOrEmpty($testBody) -and $item.Size -gt 1024) {
                                $shouldSkip = $true
                                $skipReason = 'Undownloaded/stub message'
                            }
                        } catch {
                            $shouldSkip = $true
                            $skipReason = 'Body inaccessible'
                        }
                    }

                    if ($shouldSkip) {
                        Log "SKIP: $skipReason - Subject: $subj"
                        $skipped++
                        continue
                    }

                    $ext = if ($Format -eq 'EML') { 'eml' } else { 'msg' }
                    $fileName = "$ts - $subj.$ext"
                    $file = Join-Path $folderDest $fileName

                    # Path length check - use dynamic MaxPathLength parameter
                    # Note: After enabling Windows long paths and restarting, this can be much higher
                    $effectiveLimit = if ($script:LongPathSupport.Enabled) { 32767 } else { $MaxPathLength }
                    if ($file.Length -gt $effectiveLimit) {
                        Log "SKIP: Path too long ($($file.Length) chars, limit: $effectiveLimit) - $subj"
                        if ($script:LongPathSupport -and -not $script:LongPathSupport.Enabled) {
                            Log "      Long path support disabled: $($script:LongPathSupport.Error)"
                            Log "      Restart system after enabling registry key to use paths >260 chars"
                        }
                        $skipped++
                        continue
                    }

                    # Determine format code
                    $fmtCode = (Get-OlSaveFormat $Format)

                    # Attempt save with retry
                    $maxRetries = 2
                    $saveSucceeded = $false
                    for ($retry = 0; $retry -le $maxRetries; $retry++) {
                        try {
                            $item.SaveAs($file, $fmtCode)
                            $count++
                            $saveSucceeded = $true
                            break
                        } catch {
                            if ($retry -lt $maxRetries) {
                                Start-Sleep -Milliseconds 100
                            } else {
                                # Final failure - log details
                                $errMsg = $_.Exception.Message
                                $innerMsg = if ($_.Exception.InnerException) { $_.Exception.InnerException.Message } else { 'N/A' }
                                Log "FAIL: SaveAs failed after $($maxRetries+1) attempts"
                                Log "  Subject: $subj"
                                Log "  File: $fileName"
                                Log "  Error: $errMsg"
                                if ($innerMsg -ne 'N/A') { Log "  Inner: $innerMsg" }
                                $failed++
                            }
                        }
                    }

                    # Log if save failed despite retries
                    if (-not $saveSucceeded) {
                        Log "  Final status: Failed to save after all retry attempts"
                    }
                }
            } catch {
                Log "ERROR: Unexpected error processing item in $($Folder.FolderPath): $($_.Exception.Message)"
                $failed++
            }
        }

        if ($skipped -gt 0 -or $failed -gt 0) {
            Log "Folder $($Folder.FolderPath): Saved=$count Skipped=$skipped Failed=$failed"
        }

        if ($IncludeSubfolders) {
            foreach ($sf in $Folder.Folders) {
                $count += Export-OutlookFolder -Folder $sf -BaseDest $BaseDest -Depth ($Depth+1)
            }
        }
        return $count
    }

    # Let user pick multiple folders (Cancel to finish)
    $total = 0
    $picked = @{}
    while ($true) {
        $f = $ns.PickFolder()
        if (-not $f) { break } # Cancel
        if ($picked.ContainsKey($f.EntryID)) {
            Log "Already picked: $($f.FolderPath)"
            continue
        }
        $picked[$f.EntryID] = $true
        Log "Exporting from: $($f.FolderPath)"
        $total += Export-OutlookFolder -Folder $f -BaseDest $DestinationRoot
    }
    Log "Outlook export complete. Items saved: $total"
    return $total
}

function Coalesce { param([Parameter(ValueFromRemainingArguments=$true)][object[]]$Values)
  foreach ($v in $Values) { if ($null -ne $v -and $v -ne '') { return $v } }
  return $null
}

function Trunc-ForPath([string]$Dir,[string]$Base,[string]$Ext){
  $max = $MaxPathLength
  $base = $Base
  $ext = if ($Ext) { if ($Ext.StartsWith('.')){$Ext}else{'.'+$Ext} } else { '' }
  $full = Join-Path $Dir ($base + $ext)
  if ($full.Length -le $max) { return $full }

  # Path truncation required - log diagnostic information
  $originalLength = $full.Length
  $originalBase = $base

  # Calculate available room, reserve space for potential hash suffix
  $hashSuffixLength = 8  # "_XXXXXXX" (underscore + 7 chars of hash)
  $room = [Math]::Max(16, $max - ($Dir.Length + 1 + $ext.Length + $hashSuffixLength))

  if ($base.Length -gt $room) {
    # Preserve start and end of filename for better context
    if ($room -gt 20) {
      # Keep first 60% and last 30% of available room
      $keepStart = [Math]::Floor($room * 0.6)
      $keepEnd = [Math]::Floor($room * 0.3)
      $base = $base.Substring(0, $keepStart) + "~" + $base.Substring($base.Length - $keepEnd)
    } else {
      $base = $base.Substring(0, $room)
    }

    # Add hash suffix to prevent collisions on truncated names
    $hash = (HashString $originalBase).Substring(0, 7)
    $base = "${base}_$hash"
  }

  $truncated = Join-Path $Dir ($base + $ext)

  # Always log truncation as it indicates potential data loss
  Log "WARN: Path truncated from $originalLength to $($truncated.Length) chars (limit: $max)"
  Log "      Original name: $originalBase$ext"
  Log "      Truncated to: $base$ext"

  if ($script:LongPathSupport -and -not $script:LongPathSupport.Enabled) {
    Log "      Long path support disabled: $($script:LongPathSupport.Error)"
    Log "      Consider enabling long paths or shortening folder names"
  }

  return $truncated
}

function HashString([string]$s){
  $sha = $null
  try {
    $sha = [System.Security.Cryptography.SHA256]::Create()
    $bytes = [System.Text.Encoding]::UTF8.GetBytes($s)
    return ($sha.ComputeHash($bytes) | ForEach-Object { $_.ToString('x2') }) -join ''
  } finally {
    if ($sha) { $sha.Dispose() }
  }
}
function ShortKey([string]$hex){ if ($hex -and $hex.Length -ge 10){ return $hex.Substring(0,10) } else { return $hex } }

# Global hash cache to avoid redundant calculations
if (-not (Get-Variable -Scope Script -Name FileHashCache -ErrorAction SilentlyContinue)) {
    $script:FileHashCache = @{}
}

function Sha256File([string]$p){
  # Check cache first
  $fileInfo = Get-Item -LiteralPath $p -ErrorAction SilentlyContinue
  if (-not $fileInfo) {
    Log "WARN: Cannot hash non-existent file: $p"
    return $null
  }

  # Use file path + size + last write time as cache key
  $cacheKey = "$p|$($fileInfo.Length)|$($fileInfo.LastWriteTimeUtc.Ticks)"

  if ($script:FileHashCache.ContainsKey($cacheKey)) {
    return $script:FileHashCache[$cacheKey]
  }

  # For very small files, read all at once
  if ($fileInfo.Length -lt 1MB) {
    $sha = $null
    try {
      $bytes = [System.IO.File]::ReadAllBytes($p)
      $sha = [System.Security.Cryptography.SHA256]::Create()
      $hash = ($sha.ComputeHash($bytes) | ForEach-Object { $_.ToString('x2') }) -join ''
      $script:FileHashCache[$cacheKey] = $hash
      return $hash
    } catch {
      Log "WARN: Fast hash failed for $p - $_"
    } finally {
      if ($sha) { $sha.Dispose() }
    }
  }

  # For larger files, use buffered streaming
  $sha = [System.Security.Cryptography.SHA256]::Create()
  $fs = $null

  # Retry logic for concurrent file access
  $maxRetries = 3
  $retryDelay = 100  # milliseconds

  for ($retry = 0; $retry -lt $maxRetries; $retry++) {
    try {
      # Use larger buffer for better performance (64KB) and allow concurrent reads
      $fs = New-Object System.IO.FileStream($p,
                                             [System.IO.FileMode]::Open,
                                             [System.IO.FileAccess]::Read,
                                             [System.IO.FileShare]::ReadWrite,
                                             65536)
      break  # Success, exit retry loop
    } catch [System.IO.IOException] {
      if ($retry -eq $maxRetries - 1) {
        Log "ERROR: Cannot access file for hashing after $maxRetries attempts: $p - $_"
        return $null
      }
      Log "WARN: File locked for hashing, retrying ($($retry+1)/$maxRetries): $p"
      Start-Sleep -Milliseconds $retryDelay
      $retryDelay *= 2  # Exponential backoff
    }
  }

  try {
    $hash = ($sha.ComputeHash($fs) | ForEach-Object { $_.ToString('x2') }) -join ''
    $script:FileHashCache[$cacheKey] = $hash

    # Limit cache size to prevent memory bloat
    if ($script:FileHashCache.Count -gt 1000) {
      # Remove oldest entries (simple FIFO)
      $keysToRemove = $script:FileHashCache.Keys | Select-Object -First 100
      foreach ($key in $keysToRemove) {
        $script:FileHashCache.Remove($key)
      }
      Log "INFO: Pruned hash cache to prevent memory bloat"
    }

    return $hash
  } catch {
    Log "ERROR: Failed to hash file $p - $_"
    return $null
  } finally {
    if ($fs) { $fs.Dispose() }
    if ($sha) { $sha.Dispose() }
  }
}

# Optimized hash comparison that uses file size as quick filter
function FilesMatch([string]$file1, [string]$file2) {
  # Quick size check first
  $info1 = Get-Item -LiteralPath $file1 -ErrorAction SilentlyContinue
  $info2 = Get-Item -LiteralPath $file2 -ErrorAction SilentlyContinue

  if (-not $info1 -or -not $info2) { return $false }
  if ($info1.Length -ne $info2.Length) { return $false }

  # Only compute hashes if sizes match
  $hash1 = Sha256File $file1
  $hash2 = Sha256File $file2

  return ($hash1 -eq $hash2 -and $hash1 -ne $null)
}

function Get-RelativePath([string]$base,[string]$path){
  $base2 = (Resolve-Path -LiteralPath $base -ErrorAction Stop).Path.TrimEnd('\') + '\'
  $uBase = New-Object System.Uri($base2)
  $uPath = New-Object System.Uri((Resolve-Path -LiteralPath $path -ErrorAction Stop).Path)
  $relUri = $uBase.MakeRelativeUri($uPath).ToString().Replace('/','\')
  return [System.Uri]::UnescapeDataString($relUri)
}

function MatchesAny([string]$text,[string[]]$patterns){
  if (-not $patterns -or $patterns.Count -eq 0) { return $false }
  foreach($p in $patterns){
    if (-not $p) { continue }
    if ($p.StartsWith('regex:', [StringComparison]::OrdinalIgnoreCase)) {
      $rx = '(?i)' + $p.Substring(6)
      if ($text -match $rx) { return $true }
    } else {
      if ($text -ilike $p) { return $true }
    }
  }
  return $false
}

function NormalizeEmail([string]$s){
  if ([string]::IsNullOrWhiteSpace($s)) { return $null }

  # Unicode normalization for international email addresses
  try {
    $s = $s.Normalize([System.Text.NormalizationForm]::FormC)
  } catch {
    # Fallback if normalization fails
  }

  if ($s -match '<([^>]+)>') {
    $email = $Matches[1].Trim().ToLowerInvariant()
  } else {
    $email = $s.Trim().ToLowerInvariant()
  }

  # Basic email validation
  if ($email -notmatch '^[^@\s]+@[^@\s]+\.[^@\s]+$') {
    Log "WARN: Invalid email format detected: $email"
    return $email  # Return anyway but log warning
  }

  return $email
}
function AddressMatches([string]$address,[string[]]$patterns){
  if (-not $address) { return $false }
  $addr = (NormalizeEmail $address)
  foreach($p in @($patterns)){
    if (-not $p) { continue }
    $q = $p.Trim().ToLowerInvariant()
    if ($q.Contains('@')) {
      if ($q.Contains('*')) { if ($addr -like $q) { return $true } }
      else { if ($addr -eq $q) { return $true } }
    } else {
      # Treat as bare domain; match domain and subdomains
      if ($addr -match ("@(.+\.)?"+[regex]::Escape($q)+"$")) { return $true }
    }
  }
  return $false
}

function ParseAddresses([string]$s){
  if ([string]::IsNullOrWhiteSpace($s)) { return @() }
  return ($s -split ';|,') | ForEach-Object { $_.Trim() } | Where-Object { $_ }
}

function SmartSubject([string]$s){
  if (-not $s) { return '_' }

  # Unicode normalization for international characters in subjects
  try {
    $s = $s.Normalize([System.Text.NormalizationForm]::FormC)
  } catch {
    # Continue with original if normalization fails
  }

  # Support international reply/forward markers (includes Chinese/Japanese/Arabic)
  $t = [regex]::Replace($s,'^\s*((re|fw|fwd|aw|sv|回复|回覆|転送|رد|إعادة توجيه)\s*[:：]\s*)+', '', [Text.RegularExpressions.RegexOptions]::IgnoreCase)
  $t = $t -replace '\s+', ' '
  $t.Trim()
}

function ThreadIndexRoot([string]$ti){
  if ([string]::IsNullOrWhiteSpace($ti)) { return $null }
  if ($ti.Length -ge 22) { return $ti.Substring(0,22) } else { return $ti }
}

function PickConvoKey($meta){
  if ($meta.ConversationID) { return "cid:$($meta.ConversationID)" }
  if ($meta.ThreadIndexRoot) { return "ti:$($meta.ThreadIndexRoot)" }
  if ($meta.TopRefMsgId)     { return "ref:$($meta.TopRefMsgId)" }
  $seedParts = @(
    (Coalesce $meta.SmartSubject ''),
    (Coalesce $meta.From ''),
    ((@($meta.To) -join ','))
  )
  $seed = ($seedParts -join '|')
  return "sub:" + (HashString $seed)
}

function SortKeyUtc($meta, [string]$my){
  $from = (NormalizeEmail $meta.From)
  $myNorm = if ($my) { NormalizeEmail $my } else { $null }
  if ($myNorm -and $from -eq $myNorm) {
    if ($meta.SentOnUtc) { return $meta.SentOnUtc }
    elseif ($meta.ReceivedUtc) { return $meta.ReceivedUtc }
    else { return $meta.FileTimeUtc }
  } else {
    if ($meta.ReceivedUtc) { return $meta.ReceivedUtc }
    elseif ($meta.SentOnUtc) { return $meta.SentOnUtc }
    else { return $meta.FileTimeUtc }
  }
}

function IsInlineAttachment([string]$name,[int64]$len,[string]$contentId,[string]$disposition,[string]$body){
  if ($SkipInlineLogos) {
    if ($disposition -and $disposition.ToLowerInvariant() -eq 'inline') { return $true }
    if ($contentId -and $body -and ($body -match [regex]::Escape("cid:$contentId"))) { return $true }
    $n = ((Coalesce $name '')).ToLowerInvariant()
    if ($n -match '\.(png|gif|jpg|jpeg|bmp|ico)$') {
      if ($n -match '(^|[^a-z])(logo|image\d+)$' -and $len -lt ($InlineLogoMaxKB * 1KB)) { return $true }
      if ($n -match 'smime\.p7s') { return $true }
    }
  }
  return $false
}

# ----------------- EML / MSG parsing -----------------
function Read-Eml([string]$Path) {
  $enc = [System.Text.Encoding]::UTF8
  $fs = $null
  $sr = $null

  # Retry logic for concurrent file access
  $maxRetries = 3
  $retryDelay = 100  # milliseconds

  for ($retry = 0; $retry -lt $maxRetries; $retry++) {
    try {
      # Open with ReadWrite share to allow concurrent access
      $fs = New-Object System.IO.FileStream($Path,
                                             [System.IO.FileMode]::Open,
                                             [System.IO.FileAccess]::Read,
                                             [System.IO.FileShare]::ReadWrite)
      break  # Success, exit retry loop
    } catch [System.IO.IOException] {
      if ($retry -eq $maxRetries - 1) {
        Log "ERROR: Cannot access EML file after $maxRetries attempts: $Path - $_"
        throw
      }
      Log "WARN: File locked, retrying ($($retry+1)/$maxRetries): $Path"
      Start-Sleep -Milliseconds $retryDelay
      $retryDelay *= 2  # Exponential backoff
    }
  }

  try {
    $sr = New-Object System.IO.StreamReader($fs,$enc,$true,4096,$true)
    $headers = @{}
    $lastKey = $null
    while (-not $sr.EndOfStream) {
      $line = $sr.ReadLine()
      if ([string]::IsNullOrEmpty($line)) { break }
      if ($line.StartsWith(' ') -or $line.StartsWith("`t")) {
        if ($lastKey) { $headers[$lastKey] += ' ' + $line.Trim() }
        continue
      }
      $idx = $line.IndexOf(':')
      if ($idx -gt 0) {
        $k = $line.Substring(0,$idx).Trim()
        $v = $line.Substring($idx+1).Trim()
        $headers[$k] = $v
        $lastKey = $k
      }
    }
    $body = $sr.ReadToEnd()
    return @{ Headers = $headers; BodyRaw = $body }
  } finally {
    if ($sr) { $sr.Dispose() }
    $fs.Dispose()
  }
}

function Parse-RawHeaders([string]$raw){
  $d = @{}
  if (-not $raw) { return $d }
  $last = $null
  foreach($line in ($raw -split "`r?`n")){
    if ($line -match '^\s' -and $last) { $d[$last] += ' ' + $line.Trim() ; continue }
    $idx = $line.IndexOf(':')
    if ($idx -gt 0) {
      $k = $line.Substring(0,$idx).Trim()
      $v = $line.Substring($idx+1).Trim()
      $d[$k] = $v
      $last = $k
    }
  }
  return $d
}

function Open-OutlookCom() {
  if (-not (Get-Variable -Scope Script -Name OutlookApp -ErrorAction SilentlyContinue)) {
    $script:OutlookApp = $null
  }
  if ($script:OutlookApp -ne $null) { return $script:OutlookApp }
  try {
    $script:OutlookApp = New-Object -ComObject Outlook.Application
  } catch {
    $script:OutlookApp = $null
    Log "Warn: Outlook COM not available. .msg parsing and nested .msg extraction will be skipped."
  }
  return $script:OutlookApp
}

function Close-OutlookCom(){
  if (Get-Variable -Scope Script -Name OutlookApp -ErrorAction SilentlyContinue) {
    if ($script:OutlookApp -is [System.__ComObject]) {
      try { [System.Runtime.InteropServices.Marshal]::ReleaseComObject($script:OutlookApp) | Out-Null } catch {}
      [GC]::Collect(); [GC]::WaitForPendingFinalizers()
    } else {
      $script:OutlookApp = $null
    }
  }
}

function Read-Msg([string]$Path) {
  $app = Open-OutlookCom
  if (-not $app) { throw "Outlook COM not available to read .msg: $Path" }

  $item = $null
  $pa = $null
  $attachments = $null
  $exUser = $null

  try {
    # Create item from template with error handling
    try {
      $item = $app.CreateItemFromTemplate($Path)
    } catch {
      Log "ERROR: Failed to open MSG file: $Path - $($_.Exception.Message)"
      throw "Cannot read MSG file: $Path - $_"
    }

    if (-not $item) {
      throw "Failed to create item from template: $Path"
    }

    # Initialize metadata with safe defaults
    $meta = [ordered]@{
      Subject               = $null
      SenderEmailAddress    = $null
      SenderSmtp            = $null
      To                    = $null
      CC                    = $null
      SentOn                = $null
      ReceivedTime          = $null
      ConversationID        = $null
      InternetMessageID     = $null
      Body                  = $null
      AttachmentsCount      = 0
      Headers               = @{}
    }

    # Get basic properties with individual error handling
    try { $meta.Subject = $item.Subject } catch { Log "WARN: Cannot read Subject from $Path" }
    try { $meta.SenderEmailAddress = $item.SenderEmailAddress } catch { Log "WARN: Cannot read SenderEmailAddress from $Path" }
    try { $meta.To = $item.To } catch { Log "WARN: Cannot read To from $Path" }
    try { $meta.CC = $item.CC } catch { Log "WARN: Cannot read CC from $Path" }
    try { $meta.Body = $item.Body } catch { Log "WARN: Cannot read Body from $Path" }

    # Handle date fields with error checking
    try {
      if ($item.SentOn) {
        $meta.SentOn = $item.SentOn.ToUniversalTime()
      }
    } catch {
      Log "WARN: Cannot convert SentOn date from $Path"
    }

    try {
      if ($item.ReceivedTime) {
        $meta.ReceivedTime = $item.ReceivedTime.ToUniversalTime()
      }
    } catch {
      Log "WARN: Cannot convert ReceivedTime date from $Path"
    }

    # Get COM objects with error handling
    try {
      $pa = $item.PropertyAccessor
    } catch {
      Log "WARN: Cannot access PropertyAccessor for $Path - Extended properties will be missing"
    }

    try {
      $attachments = $item.Attachments
      if ($attachments) {
        $meta.AttachmentsCount = $attachments.Count
      }
    } catch {
      Log "WARN: Cannot access Attachments collection for $Path"
    }

    # Extended properties - these may fail on corrupt messages
    if ($pa) {
      try {
        $meta.ConversationID = $item.ConversationID
      } catch {
        Log "DEBUG: ConversationID not available for $Path"
      }

      try {
        $meta.InternetMessageID = $item.InternetMessageID
      } catch {
        Log "DEBUG: InternetMessageID not available for $Path"
      }

      # Get Sender SMTP (for Exchange)
      try {
        $smtp = $pa.GetProperty("http://schemas.microsoft.com/mapi/string/{00020328-0000-0000-C000-000000000046}/SMTPAddress")
        if ($smtp) {
          $meta.SenderSmtp = $smtp
        }
      } catch {
        # Try alternate method for Exchange addresses
        try {
          if ($item.SenderEmailType -eq 'EX' -and $item.Sender) {
            $exUser = $item.Sender.GetExchangeUser()
            if ($exUser -and $exUser.PrimarySmtpAddress) {
              $meta.SenderSmtp = $exUser.PrimarySmtpAddress
            }
          }
        } catch {
          Log "DEBUG: Cannot resolve Exchange SMTP address for $Path"
        }
      }

      # Get full headers
      try {
        $hdr = $pa.GetProperty("http://schemas.microsoft.com/mapi/proptag/0x007D001E")
        if ($hdr) {
          $meta.Headers = Parse-RawHeaders $hdr
        }
      } catch {
        Log "DEBUG: Cannot retrieve full headers for $Path"
      }
    }

    return $meta
  } catch {
    # Re-throw critical errors after logging
    Log "ERROR: Critical failure reading MSG: $Path - $_"
    throw
  } finally {
    # Robust COM cleanup with error handling
    if ($exUser -is [System.__ComObject]) {
      try { [System.Runtime.InteropServices.Marshal]::ReleaseComObject($exUser) | Out-Null } catch {}
    }
    if ($attachments -is [System.__ComObject]) {
      try { [System.Runtime.InteropServices.Marshal]::ReleaseComObject($attachments) | Out-Null } catch {}
    }
    if ($pa -is [System.__ComObject]) {
      try { [System.Runtime.InteropServices.Marshal]::ReleaseComObject($pa) | Out-Null } catch {}
    }
    if ($item -is [System.__ComObject]) {
      try { [System.Runtime.InteropServices.Marshal]::ReleaseComObject($item) | Out-Null } catch {}
    }
  }
}

# ----------------- Noise detection & policy filters -----------------
function Get-HeaderVal($headers,[string]$name){
  if (-not $headers) { return $null }
  foreach($k in $headers.Keys){ if ($k -ieq $name) { return $headers[$k] } }
  return $null
}
function Is-MarketingMessage($headers){
  # Check standard list headers
  $lu  = Get-HeaderVal $headers 'List-Unsubscribe'
  if (-not $lu) { $lu = Get-HeaderVal $headers 'X-List-Unsubscribe' }
  $lid = Get-HeaderVal $headers 'List-Id'
  $prec = (Get-HeaderVal $headers 'Precedence')

  if ($lu -or $lid) {
    Log "DEBUG: Marketing detected via List headers"
    return $true
  }

  if ($prec -and $prec -match '(?i)\b(bulk|list|junk)\b') {
    Log "DEBUG: Marketing detected via Precedence: $prec"
    return $true
  }

  # Additional marketing indicators
  $xMailer = Get-HeaderVal $headers 'X-Mailer'
  if ($xMailer -and $xMailer -match '(?i)(mailchimp|constant contact|campaign monitor|sendgrid|mailjet|sendinblue|getresponse|hubspot|marketo|salesforce|pardot|eloqua)') {
    Log "DEBUG: Marketing detected via X-Mailer: $xMailer"
    return $true
  }

  # Check for marketing/campaign tracking headers
  $xCampaign = Get-HeaderVal $headers 'X-Campaign'
  $xCampaignId = Get-HeaderVal $headers 'X-Campaign-Id'
  $xMailgunTag = Get-HeaderVal $headers 'X-Mailgun-Tag'
  $xMCTrack = Get-HeaderVal $headers 'X-MC-Track'

  if ($xCampaign -or $xCampaignId -or $xMailgunTag -or $xMCTrack) {
    Log "DEBUG: Marketing detected via campaign tracking headers"
    return $true
  }

  # Check for bulk sender headers
  $feedback = Get-HeaderVal $headers 'Feedback-ID'
  if ($feedback) {
    Log "DEBUG: Marketing detected via Feedback-ID header"
    return $true
  }

  return $false
}

function Is-AutoGeneratedMessage($headers,$subject,$from){
  # Standard auto-generated headers
  $autoSub = Get-HeaderVal $headers 'Auto-Submitted'
  if ($autoSub -and $autoSub -match '(?i)auto-(generated|replied|notified|forwarded)') {
    Log "DEBUG: Auto-generated detected via Auto-Submitted: $autoSub"
    return $true
  }

  # Response suppression headers
  $xar = Get-HeaderVal $headers 'X-Auto-Response-Suppress'
  if ($xar -and $xar -match '(?i)\b(all|oof|dr|rn|nrn|autoreply)\b') {
    Log "DEBUG: Auto-generated detected via X-Auto-Response-Suppress: $xar"
    return $true
  }

  # Precedence headers
  $prec = Get-HeaderVal $headers 'Precedence'
  if ($prec -and $prec -match '(?i)\b(bulk|list|junk|auto_reply)\b') {
    Log "DEBUG: Auto-generated detected via Precedence: $prec"
    return $true
  }

  # Content type for delivery reports
  $ctype = Get-HeaderVal $headers 'Content-Type'
  if ($ctype -and $ctype -match '(?i)multipart/report|message/(delivery|disposition-notification|feedback-report)|report-type=(delivery-status|disposition-notification)') {
    Log "DEBUG: Auto-generated detected via Content-Type: $ctype"
    return $true
  }

  # Enhanced subject patterns
  if ($subject) {
    $autoPatterns = @(
      '^(?i)(undeliverable|non[- ]?delivery|delivery (status|failure|problem)|failed (delivery|message))',
      '^(?i)(out of (office|facility)|automatic reply|auto[- ]?reply|autoreply)',
      '^(?i)(vacation|away|absence|abwesenheit)',
      '^(?i)(read receipt|delivery receipt|return receipt)',
      '^(?i)(mail delivery (failed|subsystem|error))',
      '^(?i)(returned mail|mail system error|postmaster notify)',
      '^(?i)(email delivery failure|message delivery failure)',
      '^(?i)(failure notice|delivery incomplete)',
      '(?i)\[auto[- ]?reply\]|\[out of office\]|\[vacation\]'
    )

    foreach ($pattern in $autoPatterns) {
      if ($subject -match $pattern) {
        Log "DEBUG: Auto-generated detected via subject pattern: $pattern"
        return $true
      }
    }
  }

  # Enhanced sender patterns
  if ($from) {
    $senderPatterns = @(
      '(?i)mailer[- ]?daemon',
      '(?i)post[- ]?master',
      '(?i)no[- ]?reply',
      '(?i)do[- ]?not[- ]?reply',
      '(?i)auto[- ]?reply',
      '(?i)bounce[s]?@',
      '(?i)notification[s]?@',
      '(?i)system@',
      '(?i)admin@',
      '(?i)mail[- ]?delivery[- ]?subsystem'
    )

    foreach ($pattern in $senderPatterns) {
      if ($from -match $pattern) {
        Log "DEBUG: Auto-generated detected via sender pattern: $pattern"
        return $true
      }
    }
  }

  # Check for specific auto-reply headers
  $xAutoReply = Get-HeaderVal $headers 'X-Autoreply'
  $xAutoRespond = Get-HeaderVal $headers 'X-Autorespond'
  $xVacation = Get-HeaderVal $headers 'X-Vacation'

  if ($xAutoReply -or $xAutoRespond -or $xVacation) {
    Log "DEBUG: Auto-generated detected via specific auto-reply headers"
    return $true
  }

  # Check for loop prevention headers
  $xLoop = Get-HeaderVal $headers 'X-Loop'
  $xAutoLoop = Get-HeaderVal $headers 'X-AutoLoop'

  if ($xLoop -or $xAutoLoop) {
    Log "DEBUG: Auto-generated detected via loop prevention headers"
    return $true
  }

  return $false
}
function ShouldExcludeByPolicy($meta){
  $relDir = $meta.RelDir
  if ($IncludePathPattern -and -not (MatchesAny $relDir $IncludePathPattern)) { return $true }
  if ($ExcludePathPattern -and (MatchesAny $relDir $ExcludePathPattern)) { return $true }

  # sender allow/deny
  if ($AllowSenders) {
    if ($meta.From) {
      if (-not (AddressMatches $meta.From $AllowSenders)) { return $true }
    } else {
      Log "Skip (policy: AllowSenders but From missing): Path=$relDir"
      return $true
    }
  }
  if ($RejectSenders -and (AddressMatches $meta.From $RejectSenders)) { return $true }
  if ($RejectDomains -and (AddressMatches $meta.From $RejectDomains)) { return $true }

  if ($RejectSubjectRegex) {
    foreach($rx in $RejectSubjectRegex){
      try { if ($meta.Subject -and ($meta.Subject -match $rx)) { return $true } }
      catch { Log "Warn: invalid subject regex '$rx' - $_" }
    }
  }
  if ($ExcludeMarketing) {
    if (Is-MarketingMessage $meta.Headers) { return $true }
  }
  if ($ExcludeAutoGenerated) {
    if (Is-AutoGeneratedMessage $meta.Headers $meta.Subject $meta.From) { return $true }
  }
  if ($RejectBodyRegex) {
    $b = $meta.BodyPlain
    if (-not $b) { $b = $meta.BodyRaw }
    if ($b) {
      foreach($rx in $RejectBodyRegex){
        try { if ($b -match $rx) { return $true } }
        catch { Log "Warn: invalid body regex '$rx' - $_" }
      }
    }
  }
  return $false
}

# ----------------- Cleaning for LLM/vectorization -----------------
function Normalize-Whitespace([string]$t){
  if (-not $t) { return $t }

  # Unicode normalization first
  try {
    $t = $t.Normalize([System.Text.NormalizationForm]::FormC)
  } catch {
    # Continue with original if normalization fails
  }

  # Handle various Unicode whitespace characters
  $t = $t -replace '\r',''
  $t = $t -replace '[\t\u00A0\u1680\u2000-\u200A\u202F\u205F\u3000]+',' '  # Various Unicode spaces
  $t = $t -replace ' *\n','`n'
  $t.Trim()
}

function Strip-QuotedSections([string]$t){
  if (-not $t) { return $t }
  $regexMarkers = @(
    '(?m)^On .*wrote:$',
    '(?m)^From:.*$',
    '(?m)^-----Original Message-----$',
    '(?m)^>+'
  )
  $opts = [Text.RegularExpressions.RegexOptions]::IgnoreCase -bor [Text.RegularExpressions.RegexOptions]::Multiline
  foreach($rx in $regexMarkers){
    $m = [regex]::Match($t,$rx, $opts)
    if ($m.Success) {
      $t = $t.Substring(0, $m.Index).Trim()
      break
    }
  }
  return $t
}

function Strip-Signature([string]$t){
  if (-not $t) { return $t }
  $sigMarkers = @(
    '^\s*--\s*$',
    '^\s*Sent from my iPhone',
    '^\s*Best regards',
    '^\s*Regards,',
    '^\s*Kind regards',
    '^\s*Thanks,',
    '^\s*Thank you,',
    '^\s*Cheers,'
  )
  $opts = [Text.RegularExpressions.RegexOptions]::IgnoreCase -bor [Text.RegularExpressions.RegexOptions]::Multiline
  $idx = -1
  foreach($m in $sigMarkers){
    $mt = [regex]::Match($t, $m, $opts)
    if ($mt.Success) { if ($idx -eq -1 -or $mt.Index -lt $idx) { $idx = $mt.Index } }
  }
  if ($idx -ge 0) { $t = $t.Substring(0,$idx).Trim() }
  return $t
}

function Strip-Disclaimers([string]$t){
  if (-not $t) { return $t }
  # Look only in the last 25% of text to reduce accidental truncation
  $len = $t.Length
  $start = [Math]::Floor($len * 0.75)
  if ($start -lt 0) { $start = 0 }
  $tail = $t.Substring($start)
  $rx = '(?is)(confidential|privileged|disclaimer|confidentiality notice|proprietary).*?$'
  $m = [regex]::Match($tail,$rx)
  if ($m.Success) { $t = $t.Substring(0, $start + $m.Index).Trim() }
  $rx2 = '(?is)(unsubscribe|manage (?:my|your) preferences|update preferences).*?$'
  $m2 = [regex]::Match($tail,$rx2)
  if ($m2.Success) { $t = $t.Substring(0, $start + $m2.Index).Trim() }
  return $t
}

function Clean-BodyForNLP([string]$body){
  if (-not $body) { return $body }
  $t = $body
  $t = $t -replace 'https?://\S+', 'URL'
  $t = Strip-QuotedSections $t
  $t = Strip-Disclaimers $t
  $t = Strip-Signature $t
  $t = Normalize-Whitespace $t
  return $t
}

function Split-IntoChunks([string]$text,[int]$size,[int]$overlap){
  $out = @()
  if (-not $text) { return ,@() }

  # Validate and adjust chunking parameters
  if ($size -le 0) {
    $size = 1000
    Log "WARN: Chunk size was invalid ($size), reset to default 1000"
  }
  if ($overlap -lt 0) {
    $overlap = 0
    Log "WARN: Chunk overlap was negative ($overlap), reset to 0"
  }
  if ($overlap -ge $size) {
    $overlap = [Math]::Floor($size / 5)
    Log "WARN: Chunk overlap >= size, adjusted overlap to $overlap (20% of size)"
  }
  $len = $text.Length
  $i = 0
  while ($i -lt $len) {
    $end = [Math]::Min($len, $i + $size)
    $chunk = $text.Substring($i, $end - $i)
    $out += $chunk
    if ($end -eq $len) { break }
    $i = [Math]::Max($i + $size - $overlap, $i + 1)
  }
  return $out
}

# ----------------- Nested attachments extraction -----------------
function Get-UniqueFilePath([string]$dir, [string]$fileName){
  $base = [System.IO.Path]::GetFileNameWithoutExtension($fileName)
  $ext  = [System.IO.Path]::GetExtension($fileName)
  $candidate = Trunc-ForPath -Dir $dir -Base (ConvertTo-SafeName $base) -Ext $ext
  if (-not (Test-Path -LiteralPath $candidate)) { return $candidate }

  # File exists - need to find unique name with collision counter
  $n = 2
  $collisionCount = 0
  while ($true) {
    $cand = Trunc-ForPath -Dir $dir -Base ("$base ($n)") -Ext $ext
    if (-not (Test-Path -LiteralPath $cand)) {
      # Log if multiple collisions occurred (potential path length issues)
      if ($collisionCount -gt 5 -and $script:LongPathSupport -and -not $script:LongPathSupport.Enabled) {
        Log "WARN: File collision required $collisionCount retries for: $fileName"
        Log "      Long path support disabled - consider enabling to reduce collisions"
      }
      return $cand
    }
    $n++
    $collisionCount++

    # Safety check to prevent infinite loops
    if ($n -gt 9999) {
      Log "ERROR: Excessive file collisions (>9999) for: $fileName in $dir"
      throw "Cannot create unique file path after 9999 attempts"
    }
  }
}

function Extract-AttachmentsFromMsg([string]$path,[string]$tempDir,[int]$depth){
  $res = @()
  $app = $null
  $item = $null
  $att = $null
  $a = $null

  # Validate recursion depth to prevent stack overflow
  if ($depth -lt 0) {
    Log "WARN: Maximum attachment extraction depth exceeded for: $path"
    return $res
  }

  # Safety check for absolute recursion limit
  $maxAbsoluteDepth = 10
  $currentDepth = $NestedDepth - $depth
  if ($currentDepth -gt $maxAbsoluteDepth) {
    Log "ERROR: Absolute recursion depth limit ($maxAbsoluteDepth) exceeded. Possible malicious attachment structure in: $path"
    return $res
  }

  # Track extraction depth in call stack
  if (-not (Get-Variable -Scope Script -Name ExtractionCallStack -ErrorAction SilentlyContinue)) {
    $script:ExtractionCallStack = New-Object System.Collections.Generic.Stack[string]
  }

  # Detect circular references
  $fileHash = Sha256File $path
  if ($fileHash -and $script:ExtractionCallStack.Contains($fileHash)) {
    Log "ERROR: Circular attachment reference detected. File hash $fileHash already in extraction stack"
    return $res
  }

  $script:ExtractionCallStack.Push($fileHash)

  try {
    $app = Open-OutlookCom
    if (-not $app) {
      Log "WARN: Outlook COM not available for nested attachment extraction"
      return $res
    }

    try {
      $item = $app.CreateItemFromTemplate($path)
    } catch {
      Log "WARN: Cannot open nested MSG file: $path - $_"
      return $res
    }

    if (-not $item) {
      Log "WARN: Failed to create item from template for nested MSG: $path"
      return $res
    }

    # Get attachments collection with error handling
    try {
      $att = $item.Attachments
    } catch {
      Log "WARN: Cannot access attachments in nested MSG: $path - $_"
      return $res
    }

    if (-not $att -or $att.Count -eq 0) {
      return $res
    }

    # Process each attachment with robust error handling
    for ($i=1; $i -le $att.Count; $i++){
      $a = $null
      try {
        $a = $att.Item($i)
        if (-not $a) { continue }

        $name = $null
        try {
          $name = $a.FileName
        } catch {
          Log "WARN: Cannot get filename for attachment $i in $path"
          continue
        }

        if (-not $name) {
          $name = "attachment_$i.bin"
        }

        $saveTo = Get-UniqueFilePath -dir $tempDir -fileName (ConvertTo-SafeName $name)

        try {
          $a.SaveAsFile($saveTo)
        } catch {
          Log "WARN: Cannot save attachment '$name' from $path - $_"
          continue
        }

        # Recurse if message files; NEVER include attached email body itself in outputs
        $ext = [IO.Path]::GetExtension($saveTo)
        $ext = if ($ext) { $ext.ToLowerInvariant() } else { '' }

        if ($IncludeNestedAttachments -and $depth -gt 0 -and ($ext -in @('.eml','.msg'))) {
          $res += Extract-AttachmentsFromMessageFile -path $saveTo -tempDir $tempDir -depth ($depth-1)
        } elseif ($ext -notin @('.eml','.msg')) {
          $res += $saveTo
        }
      } catch {
        Log "WARN: Error processing attachment $i in $path - $_"
      } finally {
        # Release COM object for individual attachment
        if ($a -is [System.__ComObject]) {
          try {
            [System.Runtime.InteropServices.Marshal]::ReleaseComObject($a) | Out-Null
          } catch {}
        }
        $a = $null
      }
    }
  } catch {
    Log "ERROR: Critical failure in nested MSG extraction for $path - $_"
  } finally {
    # Pop from extraction stack
    if ($script:ExtractionCallStack -and $script:ExtractionCallStack.Count -gt 0) {
      $null = $script:ExtractionCallStack.Pop()
    }

    # Ensure all COM objects are released in reverse order of creation
    if ($att -is [System.__ComObject]) {
      try {
        [System.Runtime.InteropServices.Marshal]::ReleaseComObject($att) | Out-Null
      } catch {}
    }
    if ($item -is [System.__ComObject]) {
      try {
        [System.Runtime.InteropServices.Marshal]::ReleaseComObject($item) | Out-Null
      } catch {}
    }

    # Force garbage collection to ensure COM cleanup
    [GC]::Collect()
    [GC]::WaitForPendingFinalizers()
  }

  return $res
}

function Extract-AttachmentsFromEml([string]$path,[string]$tempDir,[int]$depth){
  $out = @()

  # Validate recursion depth to prevent stack overflow
  if ($depth -lt 0) {
    Log "WARN: Maximum attachment extraction depth exceeded for: $path"
    return $out
  }

  # Safety check for absolute recursion limit
  $maxAbsoluteDepth = 10
  $currentDepth = $NestedDepth - $depth
  if ($currentDepth -gt $maxAbsoluteDepth) {
    Log "ERROR: Absolute recursion depth limit ($maxAbsoluteDepth) exceeded. Possible malicious attachment structure in: $path"
    return $out
  }

  try {
    $raw = Get-Content -LiteralPath $path -Raw -ErrorAction Stop

    # Validate minimum MIME structure
    if ($raw.Length -lt 100) {
      Log "WARN: EML file too small to contain valid MIME structure: $path"
      return $out
    }

    # very crude MIME split; we only need attachment parts
    $hdrText = $raw.Substring(0, [Math]::Min($raw.Length, 4096))
    $ctMatch = [regex]::Match($hdrText, '(?im)^Content-Type:\s*multipart/[\w-]+;\s*boundary="?([^";]+)"?')
    if ($ctMatch.Success) {
      $b = $ctMatch.Groups[1].Value
      $boundary = "--$b"
      $parts = $raw -split [regex]::Escape($boundary)
      foreach($p in $parts){
        $ps = $p -split "(`r?`n){2}", 2
        if ($ps.Count -lt 2) { continue }
        $ph = $ps[0]; $pc = $ps[1]
        # accept attachment or inline with filename
        $hasDispAttachment = [regex]::IsMatch($ph,'(?im)^Content-Disposition:\s*attachment(?:;|$)')
        $hasInlineWithName = [regex]::IsMatch($ph,'(?im)^Content-Disposition:\s*inline(?:;|$).*filename', [Text.RegularExpressions.RegexOptions]::IgnoreCase)
        if (-not ($hasDispAttachment -or $hasInlineWithName)) { continue }
        $fn = ''
        $m1 = [regex]::Match($ph,'(?im)filename\*?="?([^";\r\n]+)"?')
        if ($m1.Success) { $fn = $m1.Groups[1].Value }
        if (-not $fn){
          $m2 = [regex]::Match($ph,'(?im)^Content-Type:.*?name="?([^";\r\n]+)"?')
          if ($m2.Success) { $fn = $m2.Groups[1].Value }
        }
        if (-not $fn) { $fn = 'attachment.bin' }
        $enc = ''
        $m3 = [regex]::Match($ph,'(?im)^Content-Transfer-Encoding:\s*([-\w]+)')
        if ($m3.Success) { $enc = $m3.Groups[1].Value.ToLowerInvariant() }
        $bytes = $null
        if ($enc -eq 'base64') {
          $pc2 = ($pc -replace '\s','')
          try { $bytes = [Convert]::FromBase64String($pc2) } catch { continue }
        } elseif ($enc -eq 'quoted-printable') {
          $bytes = [System.Text.Encoding]::UTF8.GetBytes(($pc -replace '=[\r\n]+',''))
        } else {
          $bytes = [System.Text.Encoding]::UTF8.GetBytes($pc)
        }
        $save = Get-UniqueFilePath -dir $tempDir -fileName (ConvertTo-SafeName $fn)
        [System.IO.File]::WriteAllBytes($save, $bytes)
        $ext = [IO.Path]::GetExtension($save); $ext = if ($ext) { $ext.ToLowerInvariant() } else { '' }
        if ($IncludeNestedAttachments -and $depth -gt 0 -and ($ext -in @('.eml','.msg'))) {
          $out += Extract-AttachmentsFromMessageFile -path $save -tempDir $tempDir -depth ($depth-1)
        } elseif ($ext -notin @('.eml','.msg')) {
          $out += $save
        }
      }
    }
  } catch { Log "Warn: nested .eml extraction failed for $path : $_" }
  return $out
}

function Extract-AttachmentsFromMessageFile([Parameter(Mandatory)][string]$path,[Parameter(Mandatory)][string]$tempDir,[int]$depth){
  # Global safety check
  if ($depth -lt 0) {
    Log "WARN: Attachment extraction depth exhausted. Skipping: $path"
    return @()
  }

  # Validate file size to prevent DOS attacks
  $fileInfo = Get-Item -LiteralPath $path -ErrorAction SilentlyContinue
  if ($fileInfo -and $fileInfo.Length -gt 100MB) {
    Log "WARN: Attachment file too large for nested extraction (>100MB): $path"
    return @()
  }

  $ext = [IO.Path]::GetExtension($path); $ext = if ($ext) { $ext.ToLowerInvariant() } else { '' }
  if ($ext -eq '.msg') { return Extract-AttachmentsFromMsg -path $path -tempDir $tempDir -depth $depth }
  if ($ext -eq '.eml') {
    $sib = $path + '_attachments'
    $collected = @()
    if (Test-Path -LiteralPath $sib) {
      Get-ChildItem -LiteralPath $sib -File -ErrorAction SilentlyContinue | ForEach-Object {
        $ext2 = [IO.Path]::GetExtension($_.FullName); $ext2 = if ($ext2) { $ext2.ToLowerInvariant() } else { '' }
        if ($IncludeNestedAttachments -and $depth -gt 0 -and ($ext2 -in @('.eml','.msg'))) {
          $collected += Extract-AttachmentsFromMessageFile -path $_.FullName -tempDir $tempDir -depth ($depth-1)
        } elseif ($ext2 -notin @('.eml','.msg')) {
          $collected += $_.FullName
        }
      }
      return $collected
    } else {
      return Extract-AttachmentsFromEml -path $path -tempDir $tempDir -depth $depth
    }
  }
  return @()
}

# ----------------- Scan exports into message index -----------------
# Initialize output directory and logging FIRST
# Validate output directory is safe
if (-not (Test-SafeDirectory $OutRoot)) {
    throw "Output directory is in a restricted location. Please choose a different location."
}
$OutRoot = New-Directory $OutRoot

# Initialize log file with error handling
try {
    $script:LogFile = if ($LogPath) { $LogPath } else { Join-Path $OutRoot "build-conversations.log" }
    # Test write access
    Add-Content -LiteralPath $script:LogFile -Value "$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss') - Script started" -ErrorAction Stop
} catch {
    Write-Warning "Cannot write to log file: $script:LogFile - $_"
    Write-Warning "Logging will be disabled for this session"
    $script:LogFile = $null
}

$messages = @{}     # id -> meta
$convos   = @{}     # convoKey -> [System.Collections.Generic.List[meta]]

# Auto-detect email address from Outlook if not specified
if (-not $MyAddress -or $MyAddress.Trim() -eq '') {
    try {
        $outlookTest = New-Object -ComObject Outlook.Application
        $namespace = $outlookTest.GetNamespace('MAPI')
        $currentUser = $namespace.CurrentUser

        if ($currentUser) {
            # Try to get SMTP address
            try {
                $addressEntry = $currentUser.AddressEntry
                if ($addressEntry.Type -eq 'EX') {
                    # Exchange user
                    $exchangeUser = $addressEntry.GetExchangeUser()
                    if ($exchangeUser) {
                        $MyAddress = $exchangeUser.PrimarySmtpAddress
                        Log "Auto-detected email address from Outlook: $MyAddress"
                    }
                } else {
                    # SMTP user
                    $MyAddress = $addressEntry.Address
                    Log "Auto-detected email address from Outlook: $MyAddress"
                }
            } catch {
                Log "WARN: Could not auto-detect email address from Outlook: $_"
            }
        }

        # Cleanup COM objects
        if ($currentUser) { [System.Runtime.InteropServices.Marshal]::ReleaseComObject($currentUser) | Out-Null }
        if ($namespace) { [System.Runtime.InteropServices.Marshal]::ReleaseComObject($namespace) | Out-Null }
        if ($outlookTest) { [System.Runtime.InteropServices.Marshal]::ReleaseComObject($outlookTest) | Out-Null }
    } catch {
        Log "INFO: Outlook not available for email auto-detection: $_"
    }

    # If still not set, try to get from environment
    if (-not $MyAddress -or $MyAddress.Trim() -eq '') {
        if ($env:USERDNSDOMAIN -and $env:USERNAME) {
            # Corporate environment - construct likely email
            $MyAddress = "$env:USERNAME@$env:USERDNSDOMAIN".ToLowerInvariant()
            Log "Guessed email address from environment: $MyAddress"
        } elseif ($env:USERNAME) {
            # Fallback to username only
            $MyAddress = $env:USERNAME
            Log "Using username as email identifier: $MyAddress"
        } else {
            $MyAddress = 'unknown@unknown.com'
            Log "WARN: Could not determine email address. Using default: $MyAddress"
        }
    }
}

# If user wants to pick from Outlook, export to ExportsRoot first (BEFORE validation)
if ($PickFromOutlook) {
    # Validate Outlook COM availability early
    $testOutlook = $null
    try {
        $testOutlook = New-Object -ComObject Outlook.Application -ErrorAction Stop
        [System.Runtime.InteropServices.Marshal]::ReleaseComObject($testOutlook) | Out-Null
    } catch {
        throw "Cannot use -PickFromOutlook: Outlook COM not available. Ensure Microsoft Outlook is installed. Error: $_"
    }

    # Reassign ExportsRoot if needed
    if (-not $ExportsRoot -or $ExportsRoot.Trim() -eq '') {
        if ($OutRoot -and $OutRoot.Trim() -ne '') {
            $ExportsRoot = Join-Path $OutRoot '_picked_exports'
        } else {
            $ExportsRoot = Join-Path $env:TEMP 'EMAILOPS_Picked_Exports'
        }
    }
    New-Item -ItemType Directory -Path $ExportsRoot -Force | Out-Null
    Log "PickFromOutlook enabled. Destination export folder: $ExportsRoot"
    $exported = Invoke-OutlookFolderExport -DestinationRoot $ExportsRoot -IncludeSubfolders:$IncludeSubfolders -Format $OutlookExportFormat
    if ($exported -le 0) {
        Log "No items exported from Outlook. You can re-run and pick different folders."
    }
}

# NOW validate ExportsRoot exists (after potential PickFromOutlook reassignment)
if (-not (Test-Path -LiteralPath $ExportsRoot)) {
    throw "ExportsRoot not found: $ExportsRoot`nUse -ExportsRoot to specify directory containing .eml/.msg files, or use -PickFromOutlook to export from Outlook first."
}
$ExportsRoot = (Resolve-Path -LiteralPath $ExportsRoot).Path

Log "Scan start. ExportsRoot=$ExportsRoot OutRoot=$OutRoot"

# Preload existing manifests for incremental
$existing = @{} # convoKey -> @{ Path=..., Manifest=..., LastUtc=..., SmartSubject=... }
Get-ChildItem -LiteralPath $OutRoot -Directory -ErrorAction SilentlyContinue | ForEach-Object {
  $m = Join-Path $_.FullName 'manifest.json'
  if (Test-Path -LiteralPath $m) {
    try {
      $json = Get-Content -LiteralPath $m -Raw | ConvertFrom-Json
      $lastUtcParsed = $null
      try { if ($json.last_message_utc) { $lastUtcParsed = [DateTimeOffset]::Parse($json.last_message_utc).UtcDateTime } } catch {}
      $existing[$json.conversation_key] = @{
        Path = $_.FullName; Manifest = $json; LastUtc = $lastUtcParsed
        SmartSubject = $json.smart_subject
      }
    } catch { Log "Warn: failed to read manifest at $m : $_" }
  }
}

# Load candidate message files (use -LiteralPath with proper handling)
$allFiles = @()
# Get all files first, then filter by extension to avoid wildcard issues
try {
    $allFilesRaw = Get-ChildItem -LiteralPath $ExportsRoot -Recurse -File -ErrorAction SilentlyContinue
    $allFiles = $allFilesRaw | Where-Object { $_.Extension -match '^\.(eml|msg)$' }
} catch {
    Log "WARN: Error scanning exports directory: $_"
    $allFiles = @()
}
Log "Candidate message files found: $($allFiles.Count)"
if (-not $allFiles -or $allFiles.Count -eq 0) { Log "No .eml/.msg files found under $ExportsRoot. Pass -ExportsRoot to your export folder (contains .eml/.msg)." }

foreach ($f in $allFiles) {
  try {
    $relDir = Get-RelativePath -base $ExportsRoot -path $f.DirectoryName
    $meta = [ordered]@{
      File          = $f.FullName
      RelDir        = $relDir
      FileTimeUtc   = $f.LastWriteTimeUtc
      Kind          = $f.Extension.ToLowerInvariant().Trim('.')
      Subject       = $null
      SmartSubject  = $null
      From          = $null
      To            = @()
      CC            = @()
      SentOnUtc     = $null
      ReceivedUtc   = $null
      InternetId    = $null
      InReplyTo     = $null
      References    = @()
      ThreadIndex   = $null
      ThreadIndexRoot = $null
      ConversationID  = $null
      TopRefMsgId      = $null
      Headers       = @{}
      BodyRaw       = $null
      BodyPlain     = $null
      AttachDir     = $null
    }

    if ($meta.Kind -eq 'msg') {
      try {
        $m = Read-Msg $f.FullName
        $meta.Subject       = $m.Subject
        $meta.SmartSubject  = SmartSubject $m.Subject
        $meta.From          = if ($m.SenderSmtp) { $m.SenderSmtp } else { $m.SenderEmailAddress }
        $meta.To            = ParseAddresses $m.To
        $meta.CC            = ParseAddresses $m.CC
        $meta.SentOnUtc     = $m.SentOn
        $meta.ReceivedUtc   = $m.ReceivedTime
        $meta.InternetId    = $m.InternetMessageID
        $meta.ConversationID= $m.ConversationID
        $meta.BodyPlain     = $m.Body
        $meta.Headers       = $m.Headers
      } catch {
        Log "Warn: skipping .msg (cannot parse): $($f.FullName) : $_"
        continue
      }
    } else {
      $e = Read-Eml $f.FullName
      $h = $e.Headers
      $meta.Subject      = $h['Subject']
      $meta.SmartSubject = SmartSubject $meta.Subject
      $meta.From         = ($h['From'])
      $meta.To           = ParseAddresses ($h['To'])
      $meta.CC           = ParseAddresses ($h['Cc'])
      $meta.InternetId   = $h['Message-ID']
      $meta.InReplyTo    = $h['In-Reply-To']
      $meta.ThreadIndex  = $h['Thread-Index']
      $meta.ThreadIndexRoot = ThreadIndexRoot $meta.ThreadIndex
      if ($h['References']) { $meta.References = ($h['References'] -split '\s+') }
      $meta.TopRefMsgId  = if ($meta.References.Count -gt 0) { $meta.References[0] } else { $meta.InReplyTo }
      try { if ($h['Date']) { $meta.SentOnUtc = [datetime]::Parse($h['Date']).ToUniversalTime() } } catch {}
      $meta.BodyRaw = $e.BodyRaw
      $meta.BodyPlain = $e.BodyRaw
      $meta.Headers = $h
    }

    $meta.Id = $meta.InternetId
    if (-not $meta.Id) { $meta.Id = (HashString $f.FullName) }
    $meta.ConvoKey = PickConvoKey $meta
    $meta.SortUtc  = SortKeyUtc $meta $MyAddress

    # Guess attachments dir from common exporter pattern
    $attDirCandidate = $f.FullName + '_attachments'
    if (Test-Path -LiteralPath $attDirCandidate) { $meta.AttachDir = $attDirCandidate }

    if (ShouldExcludeByPolicy $meta) {
      Log "Skip (policy): Subject='$($meta.Subject)' From=$($meta.From) Path=$relDir"
      continue
    }

    $messages[$meta.Id] = $meta
    if (-not $convos.ContainsKey($meta.ConvoKey)) { $convos[$meta.ConvoKey] = New-Object 'System.Collections.Generic.List[object]' }
    $convos[$meta.ConvoKey].Add($meta)
  } catch {
    Log "Warn: failed to parse $($f.FullName) : $_"
  }
}

function Build-Graph-Leaves($list){
  $children = @{}; $byId = @{}
  foreach ($m in $list) { $children[$m.Id] = 0; $byId[$m.Id] = $m }
  foreach ($m in $list) {
    foreach ($ref in @($m.InReplyTo) + @($m.References)) {
      if ($ref -and $children.ContainsKey($ref)) { $children[$ref]++ }
    }
  }
  return $children.GetEnumerator() | Where-Object { $_.Value -eq 0 } | ForEach-Object { $byId[$_.Key] }
}

# Attachment copy with SHA-256 dedupe (nested-aware)
function Collect-AttachmentSourceFiles([object[]]$msgs,[string]$tmpRoot){
  $out = @()
  foreach($m in $msgs){
    if (-not $m.AttachDir) { continue }
    Get-ChildItem -LiteralPath $m.AttachDir -File -ErrorAction SilentlyContinue | ForEach-Object {
      try {
        $ext = [IO.Path]::GetExtension($_.FullName); $ext = if ($ext) { $ext.ToLowerInvariant() } else { '' }
        if ($ext -in @('.eml','.msg')) {
          if ($IncludeNestedAttachments) {
            $tmp = New-Directory (Join-Path $tmpRoot "nested")
            $out += Extract-AttachmentsFromMessageFile -path $_.FullName -tempDir $tmp -depth $NestedDepth
          }
          # never include the .eml/.msg file itself
        } else {
          $out += $_.FullName
          # Sweep sibling "<file>_attachments" if present
          $sib = $_.FullName + '_attachments'
          if ($IncludeNestedAttachments -and (Test-Path -LiteralPath $sib)) {
            Get-ChildItem -LiteralPath $sib -File -ErrorAction SilentlyContinue | ForEach-Object {
              $ext2 = [IO.Path]::GetExtension($_.FullName); $ext2 = if ($ext2) { $ext2.ToLowerInvariant() } else { '' }
              if ($ext2 -notin @('.eml','.msg')) { $out += $_.FullName }
            }
          }
        }
      } catch { Log "Warn: collect attachments failed: $($_.FullName) : $_" }
    }
  }
  return $out
}

function Get-MimeTypeFromExtension([string]$ext){
  switch ($ext.ToLowerInvariant()) {
    '.pdf' { 'application/pdf' }
    '.doc' { 'application/msword' }
    '.docx'{ 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' }
    '.xls' { 'application/vnd.ms-excel' }
    '.xlsx'{ 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' }
    '.ppt' { 'application/vnd.ms-powerpoint' }
    '.pptx'{ 'application/vnd.openxmlformats-officedocument.presentationml.presentation' }
    '.txt' { 'text/plain' }
    '.csv' { 'text/csv' }
    '.png' { 'image/png' }
    '.jpg' { 'image/jpeg' }
    '.jpeg'{ 'image/jpeg' }
    '.gif' { 'image/gif' }
    default { $null }
  }
}

function Copy-Attachments-Dedup([string]$dest,[object[]]$msgs){
  $dest = New-Directory $dest
  # Safe parent directory resolution instead of fragile '..' syntax
  $destParent = Split-Path -Path $dest -Parent
  if (-not $destParent) { $destParent = $dest }  # Fallback if at root
  $tmpRoot = New-Directory (Join-Path $destParent "_tmp_$(Get-Random)")

  # Track temp directory for cleanup
  if (Get-Variable -Scope Script -Name TempDirectories -ErrorAction SilentlyContinue) {
    $script:TempDirectories.Add($tmpRoot)
  }

  # Validate temp directory was created successfully
  if (-not (Test-Path -LiteralPath $tmpRoot)) {
    Log "ERROR: Failed to create temporary directory: $tmpRoot"
    throw "Cannot create temporary directory for attachment processing"
  }

  $shaToPath = @{}    # sha -> path inside $dest
  $pathToSha = @{}    # path -> sha (for faster metadata emit)

  # Seed index from existing dest (micro-optimization: avoid hashing when length differs)
  Get-ChildItem -LiteralPath $dest -File -ErrorAction SilentlyContinue | ForEach-Object {
    $sha = Sha256File $_.FullName
    $shaToPath[$sha] = $_.FullName
    $pathToSha[$_.FullName] = $sha
  }

  $sources = Collect-AttachmentSourceFiles -msgs $msgs -tmpRoot $tmpRoot
  foreach ($src in $sources) {
    try {
      $sha = Sha256File $src
      $nameOnly = [IO.Path]::GetFileName($src)
      $nameBase = [IO.Path]::GetFileNameWithoutExtension($nameOnly)
      $nameExt  = [IO.Path]::GetExtension($nameOnly)
      $target = Trunc-ForPath -Dir $dest -Base (ConvertTo-SafeName $nameBase) -Ext $nameExt

      if ($shaToPath.ContainsKey($sha)) {
        $existing = $shaToPath[$sha]
        if ($existing -ne $target) {
          if ($PreferNewestAttachmentName) {
            if (Test-Path -LiteralPath $existing) { Remove-Item -LiteralPath $existing -Force -ErrorAction SilentlyContinue }
            if ((Test-Path -LiteralPath $target)) {
              # Use optimized comparison
              $targetInfo = Get-Item -LiteralPath $target -ErrorAction SilentlyContinue
              $srcInfo = Get-Item -LiteralPath $src -ErrorAction SilentlyContinue
              # Quick size check before expensive hash
              if ($targetInfo.Length -ne $srcInfo.Length -or (Sha256File $target) -ne $sha) {
                $target = Get-UniqueFilePath -dir $dest -fileName $nameOnly
              }
            }
            Copy-Item -LiteralPath $src -Destination $target -Force
            $shaToPath[$sha] = $target
            $pathToSha[$target] = $sha
          }
          # else keep old name, skip
        } else {
          Copy-Item -LiteralPath $src -Destination $target -Force
        }
      } else {
        if ((Test-Path -LiteralPath $target)) {
          # Use optimized comparison
          $targetInfo = Get-Item -LiteralPath $target -ErrorAction SilentlyContinue
          $srcInfo = Get-Item -LiteralPath $src -ErrorAction SilentlyContinue
          # Quick size check before expensive hash
          if ($targetInfo.Length -ne $srcInfo.Length -or (Sha256File $target) -ne $sha) {
            $target = Get-UniqueFilePath -dir $dest -fileName $nameOnly
          }
        }
        Copy-Item -LiteralPath $src -Destination $target -Force
        $shaToPath[$sha] = $target
        $pathToSha[$target] = $sha
      }
    } catch {
      Log "Warn: copy attachment failed: $src : $_"
    }
  }

  # Emit metadata without rehashing
  $files = Get-ChildItem -LiteralPath $dest -File -ErrorAction SilentlyContinue
  $result = @()
  foreach($f in $files){
    $sha = if ($pathToSha.ContainsKey($f.FullName)) { $pathToSha[$f.FullName] } else { Sha256File $f.FullName }
    $result += [ordered]@{
      filename  = $f.Name
      extension = $f.Extension
      filetype  = Get-MimeTypeFromExtension $f.Extension
      size      = $f.Length
      sha256    = $sha
    }
  }

  # Enhanced temp cleanup with retry
  $cleanupSuccess = $false
  for ($retry = 0; $retry -lt 3; $retry++) {
    try {
      Remove-Item -LiteralPath $tmpRoot -Recurse -Force -ErrorAction Stop
      $cleanupSuccess = $true
      break
    } catch {
      if ($retry -eq 2) {
        Log "WARN: Failed to cleanup temp directory after 3 attempts: $tmpRoot - $_"
        Log "      Manual cleanup may be required"
      } else {
        Start-Sleep -Milliseconds 500
      }
    }
  }

  # Remove from tracking if cleanup successful
  if ($cleanupSuccess -and (Get-Variable -Scope Script -Name TempDirectories -ErrorAction SilentlyContinue)) {
    $script:TempDirectories.Remove($tmpRoot) | Out-Null
  }

  return $result
}

# ----------------- Write conversation pack -----------------
function Get-UtcStamp(){ [DateTime]::UtcNow.ToString('yyyyMMdd_HHmm') }

function Compute-ConvoDirName([string]$smart,[datetime]$lastUtc,[string]$key){
  $dtPart = if ($lastUtc) { $lastUtc.ToString('yyyyMMdd_HHmm') } else { Get-UtcStamp }
  return "{0} [{1}] [{2}]" -f (ConvertTo-SafeName $smart), $dtPart, (ShortKey ((HashString $key)))
}

function Write-Text([string]$path,[string]$text){
  if ($NoBomEncoding) {
    $utf8 = New-Object System.Text.UTF8Encoding($false)
    [System.IO.File]::WriteAllText($path, $text, $utf8)
  } else {
    Set-Content -LiteralPath $path -Value $text -Encoding UTF8
  }
}

function Write-Convo([string]$key,[object[]]$msgs,[string]$ExistingPath){
  $msgs = $msgs | Sort-Object -Property @{Expression='SortUtc';Descending=$true}
  $newest = $msgs[0]
  $smart  = $newest.SmartSubject
  $lastUtc  = ($msgs | Where-Object { $_.SortUtc } | Select-Object -First 1).SortUtc
  $startUtc = ($msgs | Where-Object { $_.SortUtc } | Sort-Object SortUtc | Select-Object -First 1).SortUtc

  $desiredName = Compute-ConvoDirName -smart $smart -lastUtc $lastUtc -key $key
  $desiredPath = Join-Path $OutRoot $desiredName
  $convDir = if ($ExistingPath -and (Test-Path -LiteralPath $ExistingPath)) { $ExistingPath } else { New-Directory $desiredPath }

  # Choose messages to output
  $emitList = $null
  if ($LeavesOnly) {
    $emitList = (Build-Graph-Leaves $msgs) | Sort-Object -Property @{Expression='SortUtc';Descending=$true}
  } else {
    $emitList = ($msgs | Sort-Object SortUtc)
  }

  # Conversation.txt and optional clean/chunks
  $rawTxt = New-Object System.Text.StringBuilder
  $cleanTxt = New-Object System.Text.StringBuilder
  $chunks = @()

  foreach ($m in $emitList) {
    [void]$rawTxt.AppendLine(('='*80))
    [void]$rawTxt.AppendLine(("{0:u} | From: {1} | To: {2}" -f $m.SortUtc, $m.From, ((@($m.To) -join '; '))))
    if ($m.CC -and @($m.CC).Count) { [void]$rawTxt.AppendLine(("Cc: {0}" -f ((@($m.CC) -join '; ')))) }
    [void]$rawTxt.AppendLine(("Subject: {0}" -f $m.Subject))
    [void]$rawTxt.AppendLine('')
    $body = $m.BodyPlain; if (-not $body) { $body = $m.BodyRaw }; if (-not $body) { $body = "(no body extracted)" }
    [void]$rawTxt.AppendLine($body)
    [void]$rawTxt.AppendLine('')

    if ($CleanBodies) {
      $clean = Clean-BodyForNLP $body
      if ($clean -and $clean.Length -ge $MinBodyChars) {
        [void]$cleanTxt.AppendLine(('='*80))
        [void]$cleanTxt.AppendLine(("{0:u} | From: {1} | To: {2}" -f $m.SortUtc, (NormalizeEmail $m.From), ((@($m.To) | ForEach-Object { NormalizeEmail $_ }) -join '; ')))
        [void]$cleanTxt.AppendLine('')
        [void]$cleanTxt.AppendLine($clean)
        [void]$cleanTxt.AppendLine('')

        if ($EmitChunks) {
          $parts = Split-IntoChunks -text $clean -size $ChunkSizeChars -overlap $ChunkOverlapChars
          $pos = 0
          foreach($p in $parts){
            $pos++
            $chunks += [ordered]@{
              conversation_key = $key
              message_id       = $m.Id
              sort_utc         = if ($m.SortUtc) { $m.SortUtc.ToString('o') } else { $null }
              subject          = $m.SmartSubject
              from             = (NormalizeEmail $m.From)
              to               = (@($m.To) | ForEach-Object { NormalizeEmail $_ })
              position         = $pos
              text             = $p
            }
          }
        }
      }
    }
  }
  Write-Text -path (Join-Path $convDir 'Conversation.txt') -text $rawTxt.ToString()
  if ($CleanBodies) { Write-Text -path (Join-Path $convDir 'Conversation.clean.txt') -text $cleanTxt.ToString() }
  if ($EmitChunks -and @($chunks).Count -gt 0) {
    $jl = $chunks | ForEach-Object { $_ | ConvertTo-Json -Depth 6 -Compress }
    Write-Text -path (Join-Path $convDir 'chunks.jsonl') -text ($jl -join "`n")
  }

  # Attachments
  $attMeta = Copy-Attachments-Dedup -dest (Join-Path $convDir 'attachments') -msgs $msgs
  if (-not $attMeta) { $attMeta = @() }

  # Manifest
  $participants = @()
  $allEmails = @()
  $allEmails += ($msgs | ForEach-Object { (NormalizeEmail $_.From) })
  $allEmails += ($msgs | ForEach-Object { @($_.'To') + @($_.'CC') } | ForEach-Object { NormalizeEmail $_ })
  $allEmails = $allEmails | Where-Object { $_ } | Select-Object -Unique
  foreach ($e in $allEmails) { $participants += [ordered]@{ name=$null; given_name=$null; surname=$null; smtp=$e; job_title=$null } } # placeholders

  $manifest = [ordered]@{
    conversation_key    = $key
    smart_subject       = $smart
    conversation_start_utc = if ($startUtc){ $startUtc.ToString('o') } else { $null }
    last_message_utc    = if ($lastUtc){ $lastUtc.ToString('o') } else { $null }
    from                = (NormalizeEmail $newest.From)
    to                  = (@($newest.To) | ForEach-Object { NormalizeEmail $_ })
    cc                  = (@($newest.CC) | ForEach-Object { NormalizeEmail $_ })
    participants        = $participants
    messages_count      = $msgs.Count
    has_attachment      = (@($attMeta).Count -gt 0)
    attachments         = $attMeta
    message_ids         = ($msgs | ForEach-Object { $_.Id })
    nlp                 = [ordered]@{
      cleaned_bodies      = [bool]$CleanBodies
      emit_chunks         = [bool]$EmitChunks
      chunk_size_chars    = $ChunkSizeChars
      chunk_overlap_chars = $ChunkOverlapChars
      min_body_chars      = $MinBodyChars
      leaves_only         = [bool]$LeavesOnly
    }
  }
  $json = ($manifest | ConvertTo-Json -Depth 6)
  Write-Text -path (Join-Path $convDir 'manifest.json') -text $json

  # If we reused old folder but desired name changed, try to rename
  if ($ExistingPath -and (Test-Path -LiteralPath $ExistingPath)) {
    if ($ExistingPath -ne $desiredPath) {
      try {
        if (-not (Test-Path -LiteralPath $desiredPath)) {
          Move-Item -LiteralPath $ExistingPath -Destination $desiredPath
          $convDir = $desiredPath
        } else {
          Log "Info: desired folder already exists; keeping existing path: $ExistingPath"
        }
      } catch {
        Log "Warn: failed to rename conversation folder: $ExistingPath -> $desiredPath : $_"
      }
    }
  }

  return @{ Path=$convDir; LastUtc=$lastUtc }
}

# ----------------- Main: process conversations -----------------
$allMsgs = $messages.Values | Sort-Object -Property @{Expression='SortUtc';Descending=$true}
$processedKeys = New-Object System.Collections.Generic.HashSet[string]
$exported = 0

# Progress tracking
$totalConvos = $convos.Keys.Count
$currentConvo = 0
$startTime = Get-Date

if ($totalConvos -gt 0) {
  Log "Processing $totalConvos unique conversations..."
}

foreach ($m in $allMsgs) {
  $k = $m.ConvoKey
  if ($processedKeys.Contains($k)) { continue }

  $list = $convos[$k]
  if (-not $list -or $list.Count -eq 0) { continue }

  # Progress reporting
  $currentConvo++
  if ($totalConvos -gt 10 -and $currentConvo % 10 -eq 0) {
    $pct = [Math]::Round(($currentConvo / $totalConvos) * 100, 1)
    $elapsed = (Get-Date) - $startTime
    $avgPerConvo = $elapsed.TotalSeconds / $currentConvo
    $remaining = [TimeSpan]::FromSeconds($avgPerConvo * ($totalConvos - $currentConvo))
    Log "Progress: $currentConvo/$totalConvos conversations ($pct%) - Est. remaining: $($remaining.ToString('mm\:ss'))"
  }

  $existingPack = $existing[$k]
  if ($existingPack -and $existingPack.LastUtc) {
    $newOnly = $list | Where-Object { $_.SortUtc -and $_.SortUtc -gt $existingPack.LastUtc }
    if ($newOnly.Count -gt 0) {
      Log "Incremental update: $k (+$($newOnly.Count) new)"
      $merged = @($list) | Sort-Object SortUtc -Descending
      $null = Write-Convo -key $k -msgs $merged -ExistingPath $existingPack.Path
      $exported++
    } else {
      Log "Skip (no newer): $k"
    }
  } else {
    Log "New conversation: $k ($($list.Count) msgs)"
    $null = Write-Convo -key $k -msgs $list -ExistingPath $null
    $exported++
  }

  $processedKeys.Add($k) | Out-Null
}

Close-OutlookCom

Log "Done. Conversations written or updated: $exported"
